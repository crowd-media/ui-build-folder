
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$1() { }
    const identity = x => x;
    function assign$4(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$4($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function compute_slots(slots) {
        const result = {};
        for (const key in slots) {
            result[key] = true;
        }
        return result;
    }
    function once(fn) {
        let ran = false;
        return function (...args) {
            if (ran)
                return;
            ran = true;
            fn.call(this, ...args);
        };
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop$1;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function append_styles(target, style_sheet_id, styles) {
        const append_styles_to = get_root_for_style(target);
        if (!append_styles_to.getElementById(style_sheet_id)) {
            const style = element('style');
            style.id = style_sheet_id;
            style.textContent = styles;
            append_stylesheet(append_styles_to, style);
        }
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash$1(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash$1(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { stylesheet } = info;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                info.rules = {};
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update$1(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch$1(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop$1, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch$1(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch$1(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch$1(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$2(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.47.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$1;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$1;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function commonjsRequire (path) {
    	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }

    var isMergeableObject = function isMergeableObject(value) {
    	return isNonNullObject(value)
    		&& !isSpecial(value)
    };

    function isNonNullObject(value) {
    	return !!value && typeof value === 'object'
    }

    function isSpecial(value) {
    	var stringValue = Object.prototype.toString.call(value);

    	return stringValue === '[object RegExp]'
    		|| stringValue === '[object Date]'
    		|| isReactElement(value)
    }

    // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
    var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

    function isReactElement(value) {
    	return value.$$typeof === REACT_ELEMENT_TYPE
    }

    function emptyTarget(val) {
    	return Array.isArray(val) ? [] : {}
    }

    function cloneUnlessOtherwiseSpecified(value, options) {
    	return (options.clone !== false && options.isMergeableObject(value))
    		? deepmerge(emptyTarget(value), value, options)
    		: value
    }

    function defaultArrayMerge(target, source, options) {
    	return target.concat(source).map(function(element) {
    		return cloneUnlessOtherwiseSpecified(element, options)
    	})
    }

    function getMergeFunction(key, options) {
    	if (!options.customMerge) {
    		return deepmerge
    	}
    	var customMerge = options.customMerge(key);
    	return typeof customMerge === 'function' ? customMerge : deepmerge
    }

    function getEnumerableOwnPropertySymbols(target) {
    	return Object.getOwnPropertySymbols
    		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
    			return target.propertyIsEnumerable(symbol)
    		})
    		: []
    }

    function getKeys(target) {
    	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
    }

    function propertyIsOnObject(object, property) {
    	try {
    		return property in object
    	} catch(_) {
    		return false
    	}
    }

    // Protects from prototype poisoning and unexpected merging up the prototype chain.
    function propertyIsUnsafe(target, key) {
    	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
    		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
    			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    }

    function mergeObject(target, source, options) {
    	var destination = {};
    	if (options.isMergeableObject(target)) {
    		getKeys(target).forEach(function(key) {
    			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    		});
    	}
    	getKeys(source).forEach(function(key) {
    		if (propertyIsUnsafe(target, key)) {
    			return
    		}

    		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
    			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
    		} else {
    			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    		}
    	});
    	return destination
    }

    function deepmerge(target, source, options) {
    	options = options || {};
    	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    	// implementations can use it. The caller may not replace it.
    	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

    	var sourceIsArray = Array.isArray(source);
    	var targetIsArray = Array.isArray(target);
    	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    	if (!sourceAndTargetTypesMatch) {
    		return cloneUnlessOtherwiseSpecified(source, options)
    	} else if (sourceIsArray) {
    		return options.arrayMerge(target, source, options)
    	} else {
    		return mergeObject(target, source, options)
    	}
    }

    deepmerge.all = function deepmergeAll(array, options) {
    	if (!Array.isArray(array)) {
    		throw new Error('first argument should be an array')
    	}

    	return array.reduce(function(prev, next) {
    		return deepmerge(prev, next, options)
    	}, {})
    };

    var deepmerge_1 = deepmerge;

    var cjs = deepmerge_1;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign$2 = function() {
        __assign$2 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };

    function __values$2(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __spreadArray$1(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var ErrorKind;
    (function (ErrorKind) {
        /** Argument is unclosed (e.g. `{0`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_CLOSING_BRACE"] = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE";
        /** Argument is empty (e.g. `{}`). */
        ErrorKind[ErrorKind["EMPTY_ARGUMENT"] = 2] = "EMPTY_ARGUMENT";
        /** Argument is malformed (e.g. `{foo!}``) */
        ErrorKind[ErrorKind["MALFORMED_ARGUMENT"] = 3] = "MALFORMED_ARGUMENT";
        /** Expect an argument type (e.g. `{foo,}`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_TYPE"] = 4] = "EXPECT_ARGUMENT_TYPE";
        /** Unsupported argument type (e.g. `{foo,foo}`) */
        ErrorKind[ErrorKind["INVALID_ARGUMENT_TYPE"] = 5] = "INVALID_ARGUMENT_TYPE";
        /** Expect an argument style (e.g. `{foo, number, }`) */
        ErrorKind[ErrorKind["EXPECT_ARGUMENT_STYLE"] = 6] = "EXPECT_ARGUMENT_STYLE";
        /** The number skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_NUMBER_SKELETON"] = 7] = "INVALID_NUMBER_SKELETON";
        /** The date time skeleton is invalid. */
        ErrorKind[ErrorKind["INVALID_DATE_TIME_SKELETON"] = 8] = "INVALID_DATE_TIME_SKELETON";
        /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */
        ErrorKind[ErrorKind["EXPECT_NUMBER_SKELETON"] = 9] = "EXPECT_NUMBER_SKELETON";
        /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */
        ErrorKind[ErrorKind["EXPECT_DATE_TIME_SKELETON"] = 10] = "EXPECT_DATE_TIME_SKELETON";
        /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */
        ErrorKind[ErrorKind["UNCLOSED_QUOTE_IN_ARGUMENT_STYLE"] = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE";
        /** Missing select argument options (e.g. `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_OPTIONS"] = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS";
        /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE"] = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_OFFSET_VALUE"] = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE";
        /** Expecting a selector in `select` argument (e.g `{foo, select}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR"] = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR";
        /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR"] = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR";
        /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */
        ErrorKind[ErrorKind["EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT"] = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT";
        /**
         * Expecting a message fragment after the `plural` or `selectordinal` selector
         * (e.g. `{foo, plural, one}`)
         */
        ErrorKind[ErrorKind["EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT"] = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT";
        /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */
        ErrorKind[ErrorKind["INVALID_PLURAL_ARGUMENT_SELECTOR"] = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR";
        /**
         * Duplicate selectors in `plural` or `selectordinal` argument.
         * (e.g. {foo, plural, one {#} one {#}})
         */
        ErrorKind[ErrorKind["DUPLICATE_PLURAL_ARGUMENT_SELECTOR"] = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR";
        /** Duplicate selectors in `select` argument.
         * (e.g. {foo, select, apple {apple} apple {apple}})
         */
        ErrorKind[ErrorKind["DUPLICATE_SELECT_ARGUMENT_SELECTOR"] = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR";
        /** Plural or select argument option must have `other` clause. */
        ErrorKind[ErrorKind["MISSING_OTHER_CLAUSE"] = 22] = "MISSING_OTHER_CLAUSE";
        /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */
        ErrorKind[ErrorKind["INVALID_TAG"] = 23] = "INVALID_TAG";
        /** The tag name is invalid. (e.g. `<123>foo</123>`) */
        ErrorKind[ErrorKind["INVALID_TAG_NAME"] = 25] = "INVALID_TAG_NAME";
        /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */
        ErrorKind[ErrorKind["UNMATCHED_CLOSING_TAG"] = 26] = "UNMATCHED_CLOSING_TAG";
        /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */
        ErrorKind[ErrorKind["UNCLOSED_TAG"] = 27] = "UNCLOSED_TAG";
    })(ErrorKind || (ErrorKind = {}));

    var TYPE;
    (function (TYPE) {
        /**
         * Raw text
         */
        TYPE[TYPE["literal"] = 0] = "literal";
        /**
         * Variable w/o any format, e.g `var` in `this is a {var}`
         */
        TYPE[TYPE["argument"] = 1] = "argument";
        /**
         * Variable w/ number format
         */
        TYPE[TYPE["number"] = 2] = "number";
        /**
         * Variable w/ date format
         */
        TYPE[TYPE["date"] = 3] = "date";
        /**
         * Variable w/ time format
         */
        TYPE[TYPE["time"] = 4] = "time";
        /**
         * Variable w/ select format
         */
        TYPE[TYPE["select"] = 5] = "select";
        /**
         * Variable w/ plural format
         */
        TYPE[TYPE["plural"] = 6] = "plural";
        /**
         * Only possible within plural argument.
         * This is the `#` symbol that will be substituted with the count.
         */
        TYPE[TYPE["pound"] = 7] = "pound";
        /**
         * XML-like tag
         */
        TYPE[TYPE["tag"] = 8] = "tag";
    })(TYPE || (TYPE = {}));
    var SKELETON_TYPE;
    (function (SKELETON_TYPE) {
        SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
        SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
    })(SKELETON_TYPE || (SKELETON_TYPE = {}));
    /**
     * Type Guards
     */
    function isLiteralElement(el) {
        return el.type === TYPE.literal;
    }
    function isArgumentElement(el) {
        return el.type === TYPE.argument;
    }
    function isNumberElement(el) {
        return el.type === TYPE.number;
    }
    function isDateElement(el) {
        return el.type === TYPE.date;
    }
    function isTimeElement(el) {
        return el.type === TYPE.time;
    }
    function isSelectElement(el) {
        return el.type === TYPE.select;
    }
    function isPluralElement(el) {
        return el.type === TYPE.plural;
    }
    function isPoundElement(el) {
        return el.type === TYPE.pound;
    }
    function isTagElement(el) {
        return el.type === TYPE.tag;
    }
    function isNumberSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);
    }
    function isDateTimeSkeleton(el) {
        return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);
    }

    // @generated from regex-gen.ts
    var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;

    /**
     * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
     * with some tweaks
     */
    var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
    /**
     * Parse Date time skeleton into Intl.DateTimeFormatOptions
     * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * @public
     * @param skeleton skeleton string
     */
    function parseDateTimeSkeleton(skeleton) {
        var result = {};
        skeleton.replace(DATE_TIME_REGEX, function (match) {
            var len = match.length;
            switch (match[0]) {
                // Era
                case 'G':
                    result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
                    break;
                // Year
                case 'y':
                    result.year = len === 2 ? '2-digit' : 'numeric';
                    break;
                case 'Y':
                case 'u':
                case 'U':
                case 'r':
                    throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
                // Quarter
                case 'q':
                case 'Q':
                    throw new RangeError('`q/Q` (quarter) patterns are not supported');
                // Month
                case 'M':
                case 'L':
                    result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
                    break;
                // Week
                case 'w':
                case 'W':
                    throw new RangeError('`w/W` (week) patterns are not supported');
                case 'd':
                    result.day = ['numeric', '2-digit'][len - 1];
                    break;
                case 'D':
                case 'F':
                case 'g':
                    throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
                // Weekday
                case 'E':
                    result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';
                    break;
                case 'e':
                    if (len < 4) {
                        throw new RangeError('`e..eee` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                case 'c':
                    if (len < 4) {
                        throw new RangeError('`c..ccc` (weekday) patterns are not supported');
                    }
                    result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
                    break;
                // Period
                case 'a': // AM, PM
                    result.hour12 = true;
                    break;
                case 'b': // am, pm, noon, midnight
                case 'B': // flexible day periods
                    throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
                // Hour
                case 'h':
                    result.hourCycle = 'h12';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'H':
                    result.hourCycle = 'h23';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'K':
                    result.hourCycle = 'h11';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'k':
                    result.hourCycle = 'h24';
                    result.hour = ['numeric', '2-digit'][len - 1];
                    break;
                case 'j':
                case 'J':
                case 'C':
                    throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
                // Minute
                case 'm':
                    result.minute = ['numeric', '2-digit'][len - 1];
                    break;
                // Second
                case 's':
                    result.second = ['numeric', '2-digit'][len - 1];
                    break;
                case 'S':
                case 'A':
                    throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');
                // Zone
                case 'z': // 1..3, 4: specific non-location format
                    result.timeZoneName = len < 4 ? 'short' : 'long';
                    break;
                case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
                case 'O': // 1, 4: miliseconds in day short, long
                case 'v': // 1, 4: generic non-location format
                case 'V': // 1, 2, 3, 4: time zone ID or city
                case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
                case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
                    throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');
            }
            return '';
        });
        return result;
    }

    // @generated from regex-gen.ts
    var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;

    function parseNumberSkeletonFromString(skeleton) {
        if (skeleton.length === 0) {
            throw new Error('Number skeleton cannot be empty');
        }
        // Parse the skeleton
        var stringTokens = skeleton
            .split(WHITE_SPACE_REGEX)
            .filter(function (x) { return x.length > 0; });
        var tokens = [];
        for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {
            var stringToken = stringTokens_1[_i];
            var stemAndOptions = stringToken.split('/');
            if (stemAndOptions.length === 0) {
                throw new Error('Invalid number skeleton');
            }
            var stem = stemAndOptions[0], options = stemAndOptions.slice(1);
            for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {
                var option = options_1[_a];
                if (option.length === 0) {
                    throw new Error('Invalid number skeleton');
                }
            }
            tokens.push({ stem: stem, options: options });
        }
        return tokens;
    }
    function icuUnitToEcma(unit) {
        return unit.replace(/^(.*?)-/, '');
    }
    var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
    var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g;
    var INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g;
    var CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
    function parseSignificantPrecision(str) {
        var result = {};
        if (str[str.length - 1] === 'r') {
            result.roundingPriority = 'morePrecision';
        }
        else if (str[str.length - 1] === 's') {
            result.roundingPriority = 'lessPrecision';
        }
        str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
            // @@@ case
            if (typeof g2 !== 'string') {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits = g1.length;
            }
            // @@@+ case
            else if (g2 === '+') {
                result.minimumSignificantDigits = g1.length;
            }
            // .### case
            else if (g1[0] === '#') {
                result.maximumSignificantDigits = g1.length;
            }
            // .@@## or .@@@ case
            else {
                result.minimumSignificantDigits = g1.length;
                result.maximumSignificantDigits =
                    g1.length + (typeof g2 === 'string' ? g2.length : 0);
            }
            return '';
        });
        return result;
    }
    function parseSign(str) {
        switch (str) {
            case 'sign-auto':
                return {
                    signDisplay: 'auto',
                };
            case 'sign-accounting':
            case '()':
                return {
                    currencySign: 'accounting',
                };
            case 'sign-always':
            case '+!':
                return {
                    signDisplay: 'always',
                };
            case 'sign-accounting-always':
            case '()!':
                return {
                    signDisplay: 'always',
                    currencySign: 'accounting',
                };
            case 'sign-except-zero':
            case '+?':
                return {
                    signDisplay: 'exceptZero',
                };
            case 'sign-accounting-except-zero':
            case '()?':
                return {
                    signDisplay: 'exceptZero',
                    currencySign: 'accounting',
                };
            case 'sign-never':
            case '+_':
                return {
                    signDisplay: 'never',
                };
        }
    }
    function parseConciseScientificAndEngineeringStem(stem) {
        // Engineering
        var result;
        if (stem[0] === 'E' && stem[1] === 'E') {
            result = {
                notation: 'engineering',
            };
            stem = stem.slice(2);
        }
        else if (stem[0] === 'E') {
            result = {
                notation: 'scientific',
            };
            stem = stem.slice(1);
        }
        if (result) {
            var signDisplay = stem.slice(0, 2);
            if (signDisplay === '+!') {
                result.signDisplay = 'always';
                stem = stem.slice(2);
            }
            else if (signDisplay === '+?') {
                result.signDisplay = 'exceptZero';
                stem = stem.slice(2);
            }
            if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {
                throw new Error('Malformed concise eng/scientific notation');
            }
            result.minimumIntegerDigits = stem.length;
        }
        return result;
    }
    function parseNotationOptions(opt) {
        var result = {};
        var signOpts = parseSign(opt);
        if (signOpts) {
            return signOpts;
        }
        return result;
    }
    /**
     * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
     */
    function parseNumberSkeleton(tokens) {
        var result = {};
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            switch (token.stem) {
                case 'percent':
                case '%':
                    result.style = 'percent';
                    continue;
                case '%x100':
                    result.style = 'percent';
                    result.scale = 100;
                    continue;
                case 'currency':
                    result.style = 'currency';
                    result.currency = token.options[0];
                    continue;
                case 'group-off':
                case ',_':
                    result.useGrouping = false;
                    continue;
                case 'precision-integer':
                case '.':
                    result.maximumFractionDigits = 0;
                    continue;
                case 'measure-unit':
                case 'unit':
                    result.style = 'unit';
                    result.unit = icuUnitToEcma(token.options[0]);
                    continue;
                case 'compact-short':
                case 'K':
                    result.notation = 'compact';
                    result.compactDisplay = 'short';
                    continue;
                case 'compact-long':
                case 'KK':
                    result.notation = 'compact';
                    result.compactDisplay = 'long';
                    continue;
                case 'scientific':
                    result = __assign$2(__assign$2(__assign$2({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign$2(__assign$2({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'engineering':
                    result = __assign$2(__assign$2(__assign$2({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign$2(__assign$2({}, all), parseNotationOptions(opt))); }, {}));
                    continue;
                case 'notation-simple':
                    result.notation = 'standard';
                    continue;
                // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
                case 'unit-width-narrow':
                    result.currencyDisplay = 'narrowSymbol';
                    result.unitDisplay = 'narrow';
                    continue;
                case 'unit-width-short':
                    result.currencyDisplay = 'code';
                    result.unitDisplay = 'short';
                    continue;
                case 'unit-width-full-name':
                    result.currencyDisplay = 'name';
                    result.unitDisplay = 'long';
                    continue;
                case 'unit-width-iso-code':
                    result.currencyDisplay = 'symbol';
                    continue;
                case 'scale':
                    result.scale = parseFloat(token.options[0]);
                    continue;
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
                case 'integer-width':
                    if (token.options.length > 1) {
                        throw new RangeError('integer-width stems only accept a single optional option');
                    }
                    token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {
                        if (g1) {
                            result.minimumIntegerDigits = g2.length;
                        }
                        else if (g3 && g4) {
                            throw new Error('We currently do not support maximum integer digits');
                        }
                        else if (g5) {
                            throw new Error('We currently do not support exact integer digits');
                        }
                        return '';
                    });
                    continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width
            if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {
                result.minimumIntegerDigits = token.stem.length;
                continue;
            }
            if (FRACTION_PRECISION_REGEX.test(token.stem)) {
                // Precision
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision
                // precision-integer case
                if (token.options.length > 1) {
                    throw new RangeError('Fraction-precision stems only accept a single optional option');
                }
                token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
                    // .000* case (before ICU67 it was .000+)
                    if (g2 === '*') {
                        result.minimumFractionDigits = g1.length;
                    }
                    // .### case
                    else if (g3 && g3[0] === '#') {
                        result.maximumFractionDigits = g3.length;
                    }
                    // .00## case
                    else if (g4 && g5) {
                        result.minimumFractionDigits = g4.length;
                        result.maximumFractionDigits = g4.length + g5.length;
                    }
                    else {
                        result.minimumFractionDigits = g1.length;
                        result.maximumFractionDigits = g1.length;
                    }
                    return '';
                });
                var opt = token.options[0];
                // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display
                if (opt === 'w') {
                    result = __assign$2(__assign$2({}, result), { trailingZeroDisplay: 'stripIfInteger' });
                }
                else if (opt) {
                    result = __assign$2(__assign$2({}, result), parseSignificantPrecision(opt));
                }
                continue;
            }
            // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision
            if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
                result = __assign$2(__assign$2({}, result), parseSignificantPrecision(token.stem));
                continue;
            }
            var signOpts = parseSign(token.stem);
            if (signOpts) {
                result = __assign$2(__assign$2({}, result), signOpts);
            }
            var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);
            if (conciseScientificAndEngineeringOpts) {
                result = __assign$2(__assign$2({}, result), conciseScientificAndEngineeringOpts);
            }
        }
        return result;
    }

    var _a$1;
    var SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*"));
    var SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
    function createLocation(start, end) {
        return { start: start, end: end };
    }
    // #region Ponyfills
    // Consolidate these variables up top for easier toggling during debugging
    var hasNativeStartsWith = !!String.prototype.startsWith;
    var hasNativeFromCodePoint = !!String.fromCodePoint;
    var hasNativeFromEntries = !!Object.fromEntries;
    var hasNativeCodePointAt = !!String.prototype.codePointAt;
    var hasTrimStart = !!String.prototype.trimStart;
    var hasTrimEnd = !!String.prototype.trimEnd;
    var hasNativeIsSafeInteger = !!Number.isSafeInteger;
    var isSafeInteger = hasNativeIsSafeInteger
        ? Number.isSafeInteger
        : function (n) {
            return (typeof n === 'number' &&
                isFinite(n) &&
                Math.floor(n) === n &&
                Math.abs(n) <= 0x1fffffffffffff);
        };
    // IE11 does not support y and u.
    var REGEX_SUPPORTS_U_AND_Y = true;
    try {
        var re = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        /**
         * legacy Edge or Xbox One browser
         * Unicode flag support: supported
         * Pattern_Syntax support: not supported
         * See https://github.com/formatjs/formatjs/issues/2822
         */
        REGEX_SUPPORTS_U_AND_Y = ((_a$1 = re.exec('a')) === null || _a$1 === void 0 ? void 0 : _a$1[0]) === 'a';
    }
    catch (_) {
        REGEX_SUPPORTS_U_AND_Y = false;
    }
    var startsWith = hasNativeStartsWith
        ? // Native
            function startsWith(s, search, position) {
                return s.startsWith(search, position);
            }
        : // For IE11
            function startsWith(s, search, position) {
                return s.slice(position, position + search.length) === search;
            };
    var fromCodePoint = hasNativeFromCodePoint
        ? String.fromCodePoint
        : // IE11
            function fromCodePoint() {
                var codePoints = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    codePoints[_i] = arguments[_i];
                }
                var elements = '';
                var length = codePoints.length;
                var i = 0;
                var code;
                while (length > i) {
                    code = codePoints[i++];
                    if (code > 0x10ffff)
                        throw RangeError(code + ' is not a valid code point');
                    elements +=
                        code < 0x10000
                            ? String.fromCharCode(code)
                            : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, (code % 0x400) + 0xdc00);
                }
                return elements;
            };
    var fromEntries = 
    // native
    hasNativeFromEntries
        ? Object.fromEntries
        : // Ponyfill
            function fromEntries(entries) {
                var obj = {};
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var _a = entries_1[_i], k = _a[0], v = _a[1];
                    obj[k] = v;
                }
                return obj;
            };
    var codePointAt = hasNativeCodePointAt
        ? // Native
            function codePointAt(s, index) {
                return s.codePointAt(index);
            }
        : // IE 11
            function codePointAt(s, index) {
                var size = s.length;
                if (index < 0 || index >= size) {
                    return undefined;
                }
                var first = s.charCodeAt(index);
                var second;
                return first < 0xd800 ||
                    first > 0xdbff ||
                    index + 1 === size ||
                    (second = s.charCodeAt(index + 1)) < 0xdc00 ||
                    second > 0xdfff
                    ? first
                    : ((first - 0xd800) << 10) + (second - 0xdc00) + 0x10000;
            };
    var trimStart = hasTrimStart
        ? // Native
            function trimStart(s) {
                return s.trimStart();
            }
        : // Ponyfill
            function trimStart(s) {
                return s.replace(SPACE_SEPARATOR_START_REGEX, '');
            };
    var trimEnd = hasTrimEnd
        ? // Native
            function trimEnd(s) {
                return s.trimEnd();
            }
        : // Ponyfill
            function trimEnd(s) {
                return s.replace(SPACE_SEPARATOR_END_REGEX, '');
            };
    // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.
    function RE(s, flag) {
        return new RegExp(s, flag);
    }
    // #endregion
    var matchIdentifierAtIndex;
    if (REGEX_SUPPORTS_U_AND_Y) {
        // Native
        var IDENTIFIER_PREFIX_RE_1 = RE('([^\\p{White_Space}\\p{Pattern_Syntax}]*)', 'yu');
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var _a;
            IDENTIFIER_PREFIX_RE_1.lastIndex = index;
            var match = IDENTIFIER_PREFIX_RE_1.exec(s);
            return (_a = match[1]) !== null && _a !== void 0 ? _a : '';
        };
    }
    else {
        // IE11
        matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {
            var match = [];
            while (true) {
                var c = codePointAt(s, index);
                if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {
                    break;
                }
                match.push(c);
                index += c >= 0x10000 ? 2 : 1;
            }
            return fromCodePoint.apply(void 0, match);
        };
    }
    var Parser = /** @class */ (function () {
        function Parser(message, options) {
            if (options === void 0) { options = {}; }
            this.message = message;
            this.position = { offset: 0, line: 1, column: 1 };
            this.ignoreTag = !!options.ignoreTag;
            this.requiresOtherClause = !!options.requiresOtherClause;
            this.shouldParseSkeletons = !!options.shouldParseSkeletons;
        }
        Parser.prototype.parse = function () {
            if (this.offset() !== 0) {
                throw Error('parser can only be used once');
            }
            return this.parseMessage(0, '', false);
        };
        Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {
            var elements = [];
            while (!this.isEOF()) {
                var char = this.char();
                if (char === 123 /* `{` */) {
                    var result = this.parseArgument(nestingLevel, expectingCloseTag);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else if (char === 125 /* `}` */ && nestingLevel > 0) {
                    break;
                }
                else if (char === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) {
                    var position = this.clonePosition();
                    this.bump();
                    elements.push({
                        type: TYPE.pound,
                        location: createLocation(position, this.clonePosition()),
                    });
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    this.peek() === 47 // char code for '/'
                ) {
                    if (expectingCloseTag) {
                        break;
                    }
                    else {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
                    }
                }
                else if (char === 60 /* `<` */ &&
                    !this.ignoreTag &&
                    _isAlpha(this.peek() || 0)) {
                    var result = this.parseTag(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
                else {
                    var result = this.parseLiteral(nestingLevel, parentArgType);
                    if (result.err) {
                        return result;
                    }
                    elements.push(result.val);
                }
            }
            return { val: elements, err: null };
        };
        /**
         * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the
         * [custom element name][] except that a dash is NOT always mandatory and uppercase letters
         * are accepted:
         *
         * ```
         * tag ::= "<" tagName (whitespace)* "/>" | "<" tagName (whitespace)* ">" message "</" tagName (whitespace)* ">"
         * tagName ::= [a-z] (PENChar)*
         * PENChar ::=
         *     "-" | "." | [0-9] | "_" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |
         *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
         *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
         * ```
         *
         * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name
         * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do
         * since other tag-based engines like React allow it
         */
        Parser.prototype.parseTag = function (nestingLevel, parentArgType) {
            var startPosition = this.clonePosition();
            this.bump(); // `<`
            var tagName = this.parseTagName();
            this.bumpSpace();
            if (this.bumpIf('/>')) {
                // Self closing tag
                return {
                    val: {
                        type: TYPE.literal,
                        value: "<".concat(tagName, "/>"),
                        location: createLocation(startPosition, this.clonePosition()),
                    },
                    err: null,
                };
            }
            else if (this.bumpIf('>')) {
                var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);
                if (childrenResult.err) {
                    return childrenResult;
                }
                var children = childrenResult.val;
                // Expecting a close tag
                var endTagStartPosition = this.clonePosition();
                if (this.bumpIf('</')) {
                    if (this.isEOF() || !_isAlpha(this.char())) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    var closingTagNameStartPosition = this.clonePosition();
                    var closingTagName = this.parseTagName();
                    if (tagName !== closingTagName) {
                        return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));
                    }
                    this.bumpSpace();
                    if (!this.bumpIf('>')) {
                        return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));
                    }
                    return {
                        val: {
                            type: TYPE.tag,
                            value: tagName,
                            children: children,
                            location: createLocation(startPosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                else {
                    return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));
                }
            }
            else {
                return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));
            }
        };
        /**
         * This method assumes that the caller has peeked ahead for the first tag character.
         */
        Parser.prototype.parseTagName = function () {
            var startOffset = this.offset();
            this.bump(); // the first tag name character
            while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {
                this.bump();
            }
            return this.message.slice(startOffset, this.offset());
        };
        Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {
            var start = this.clonePosition();
            var value = '';
            while (true) {
                var parseQuoteResult = this.tryParseQuote(parentArgType);
                if (parseQuoteResult) {
                    value += parseQuoteResult;
                    continue;
                }
                var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);
                if (parseUnquotedResult) {
                    value += parseUnquotedResult;
                    continue;
                }
                var parseLeftAngleResult = this.tryParseLeftAngleBracket();
                if (parseLeftAngleResult) {
                    value += parseLeftAngleResult;
                    continue;
                }
                break;
            }
            var location = createLocation(start, this.clonePosition());
            return {
                val: { type: TYPE.literal, value: value, location: location },
                err: null,
            };
        };
        Parser.prototype.tryParseLeftAngleBracket = function () {
            if (!this.isEOF() &&
                this.char() === 60 /* `<` */ &&
                (this.ignoreTag ||
                    // If at the opening tag or closing tag position, bail.
                    !_isAlphaOrSlash(this.peek() || 0))) {
                this.bump(); // `<`
                return '<';
            }
            return null;
        };
        /**
         * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes
         * a character that requires quoting (that is, "only where needed"), and works the same in
         * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.
         */
        Parser.prototype.tryParseQuote = function (parentArgType) {
            if (this.isEOF() || this.char() !== 39 /* `'` */) {
                return null;
            }
            // Parse escaped char following the apostrophe, or early return if there is no escaped char.
            // Check if is valid escaped character
            switch (this.peek()) {
                case 39 /* `'` */:
                    // double quote, should return as a single quote.
                    this.bump();
                    this.bump();
                    return "'";
                // '{', '<', '>', '}'
                case 123:
                case 60:
                case 62:
                case 125:
                    break;
                case 35: // '#'
                    if (parentArgType === 'plural' || parentArgType === 'selectordinal') {
                        break;
                    }
                    return null;
                default:
                    return null;
            }
            this.bump(); // apostrophe
            var codePoints = [this.char()]; // escaped char
            this.bump();
            // read chars until the optional closing apostrophe is found
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch === 39 /* `'` */) {
                    if (this.peek() === 39 /* `'` */) {
                        codePoints.push(39);
                        // Bump one more time because we need to skip 2 characters.
                        this.bump();
                    }
                    else {
                        // Optional closing apostrophe.
                        this.bump();
                        break;
                    }
                }
                else {
                    codePoints.push(ch);
                }
                this.bump();
            }
            return fromCodePoint.apply(void 0, codePoints);
        };
        Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {
            if (this.isEOF()) {
                return null;
            }
            var ch = this.char();
            if (ch === 60 /* `<` */ ||
                ch === 123 /* `{` */ ||
                (ch === 35 /* `#` */ &&
                    (parentArgType === 'plural' || parentArgType === 'selectordinal')) ||
                (ch === 125 /* `}` */ && nestingLevel > 0)) {
                return null;
            }
            else {
                this.bump();
                return fromCodePoint(ch);
            }
        };
        Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {
            var openingBracePosition = this.clonePosition();
            this.bump(); // `{`
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            if (this.char() === 125 /* `}` */) {
                this.bump();
                return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            // argument name
            var value = this.parseIdentifierIfPossible().value;
            if (!value) {
                return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bumpSpace();
            if (this.isEOF()) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            switch (this.char()) {
                // Simple argument: `{name}`
                case 125 /* `}` */: {
                    this.bump(); // `}`
                    return {
                        val: {
                            type: TYPE.argument,
                            // value does not include the opening and closing braces.
                            value: value,
                            location: createLocation(openingBracePosition, this.clonePosition()),
                        },
                        err: null,
                    };
                }
                // Argument with options: `{name, format, ...}`
                case 44 /* `,` */: {
                    this.bump(); // `,`
                    this.bumpSpace();
                    if (this.isEOF()) {
                        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
                    }
                    return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);
                }
                default:
                    return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));
            }
        };
        /**
         * Advance the parser until the end of the identifier, if it is currently on
         * an identifier character. Return an empty string otherwise.
         */
        Parser.prototype.parseIdentifierIfPossible = function () {
            var startingPosition = this.clonePosition();
            var startOffset = this.offset();
            var value = matchIdentifierAtIndex(this.message, startOffset);
            var endOffset = startOffset + value.length;
            this.bumpTo(endOffset);
            var endPosition = this.clonePosition();
            var location = createLocation(startingPosition, endPosition);
            return { value: value, location: location };
        };
        Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {
            var _a;
            // Parse this range:
            // {name, type, style}
            //        ^---^
            var typeStartPosition = this.clonePosition();
            var argType = this.parseIdentifierIfPossible().value;
            var typeEndPosition = this.clonePosition();
            switch (argType) {
                case '':
                    // Expecting a style string number, date, time, plural, selectordinal, or select.
                    return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
                case 'number':
                case 'date':
                case 'time': {
                    // Parse this range:
                    // {name, number, style}
                    //              ^-------^
                    this.bumpSpace();
                    var styleAndLocation = null;
                    if (this.bumpIf(',')) {
                        this.bumpSpace();
                        var styleStartPosition = this.clonePosition();
                        var result = this.parseSimpleArgStyleIfPossible();
                        if (result.err) {
                            return result;
                        }
                        var style = trimEnd(result.val);
                        if (style.length === 0) {
                            return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        var styleLocation = createLocation(styleStartPosition, this.clonePosition());
                        styleAndLocation = { style: style, styleLocation: styleLocation };
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_1 = createLocation(openingBracePosition, this.clonePosition());
                    // Extract style or skeleton
                    if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {
                        // Skeleton starts with `::`.
                        var skeleton = trimStart(styleAndLocation.style.slice(2));
                        if (argType === 'number') {
                            var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);
                            if (result.err) {
                                return result;
                            }
                            return {
                                val: { type: TYPE.number, value: value, location: location_1, style: result.val },
                                err: null,
                            };
                        }
                        else {
                            if (skeleton.length === 0) {
                                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);
                            }
                            var style = {
                                type: SKELETON_TYPE.dateTime,
                                pattern: skeleton,
                                location: styleAndLocation.styleLocation,
                                parsedOptions: this.shouldParseSkeletons
                                    ? parseDateTimeSkeleton(skeleton)
                                    : {},
                            };
                            var type = argType === 'date' ? TYPE.date : TYPE.time;
                            return {
                                val: { type: type, value: value, location: location_1, style: style },
                                err: null,
                            };
                        }
                    }
                    // Regular style or no style.
                    return {
                        val: {
                            type: argType === 'number'
                                ? TYPE.number
                                : argType === 'date'
                                    ? TYPE.date
                                    : TYPE.time,
                            value: value,
                            location: location_1,
                            style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null,
                        },
                        err: null,
                    };
                }
                case 'plural':
                case 'selectordinal':
                case 'select': {
                    // Parse this range:
                    // {name, plural, options}
                    //              ^---------^
                    var typeEndPosition_1 = this.clonePosition();
                    this.bumpSpace();
                    if (!this.bumpIf(',')) {
                        return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign$2({}, typeEndPosition_1)));
                    }
                    this.bumpSpace();
                    // Parse offset:
                    // {name, plural, offset:1, options}
                    //                ^-----^
                    //
                    // or the first option:
                    //
                    // {name, plural, one {...} other {...}}
                    //                ^--^
                    var identifierAndLocation = this.parseIdentifierIfPossible();
                    var pluralOffset = 0;
                    if (argType !== 'select' && identifierAndLocation.value === 'offset') {
                        if (!this.bumpIf(':')) {
                            return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
                        }
                        this.bumpSpace();
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
                        if (result.err) {
                            return result;
                        }
                        // Parse another identifier for option parsing
                        this.bumpSpace();
                        identifierAndLocation = this.parseIdentifierIfPossible();
                        pluralOffset = result.val;
                    }
                    var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);
                    if (optionsResult.err) {
                        return optionsResult;
                    }
                    var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                    if (argCloseResult.err) {
                        return argCloseResult;
                    }
                    var location_2 = createLocation(openingBracePosition, this.clonePosition());
                    if (argType === 'select') {
                        return {
                            val: {
                                type: TYPE.select,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                    else {
                        return {
                            val: {
                                type: TYPE.plural,
                                value: value,
                                options: fromEntries(optionsResult.val),
                                offset: pluralOffset,
                                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',
                                location: location_2,
                            },
                            err: null,
                        };
                    }
                }
                default:
                    return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));
            }
        };
        Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {
            // Parse: {value, number, ::currency/GBP }
            //
            if (this.isEOF() || this.char() !== 125 /* `}` */) {
                return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));
            }
            this.bump(); // `}`
            return { val: true, err: null };
        };
        /**
         * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659
         */
        Parser.prototype.parseSimpleArgStyleIfPossible = function () {
            var nestedBraces = 0;
            var startPosition = this.clonePosition();
            while (!this.isEOF()) {
                var ch = this.char();
                switch (ch) {
                    case 39 /* `'` */: {
                        // Treat apostrophe as quoting but include it in the style part.
                        // Find the end of the quoted literal text.
                        this.bump();
                        var apostrophePosition = this.clonePosition();
                        if (!this.bumpUntil("'")) {
                            return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));
                        }
                        this.bump();
                        break;
                    }
                    case 123 /* `{` */: {
                        nestedBraces += 1;
                        this.bump();
                        break;
                    }
                    case 125 /* `}` */: {
                        if (nestedBraces > 0) {
                            nestedBraces -= 1;
                        }
                        else {
                            return {
                                val: this.message.slice(startPosition.offset, this.offset()),
                                err: null,
                            };
                        }
                        break;
                    }
                    default:
                        this.bump();
                        break;
                }
            }
            return {
                val: this.message.slice(startPosition.offset, this.offset()),
                err: null,
            };
        };
        Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {
            var tokens = [];
            try {
                tokens = parseNumberSkeletonFromString(skeleton);
            }
            catch (e) {
                return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);
            }
            return {
                val: {
                    type: SKELETON_TYPE.number,
                    tokens: tokens,
                    location: location,
                    parsedOptions: this.shouldParseSkeletons
                        ? parseNumberSkeleton(tokens)
                        : {},
                },
                err: null,
            };
        };
        /**
         * @param nesting_level The current nesting level of messages.
         *     This can be positive when parsing message fragment in select or plural argument options.
         * @param parent_arg_type The parent argument's type.
         * @param parsed_first_identifier If provided, this is the first identifier-like selector of
         *     the argument. It is a by-product of a previous parsing attempt.
         * @param expecting_close_tag If true, this message is directly or indirectly nested inside
         *     between a pair of opening and closing tags. The nested message will not parse beyond
         *     the closing tag boundary.
         */
        Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {
            var _a;
            var hasOtherClause = false;
            var options = [];
            var parsedSelectors = new Set();
            var selector = parsedFirstIdentifier.value, selectorLocation = parsedFirstIdentifier.location;
            // Parse:
            // one {one apple}
            // ^--^
            while (true) {
                if (selector.length === 0) {
                    var startPosition = this.clonePosition();
                    if (parentArgType !== 'select' && this.bumpIf('=')) {
                        // Try parse `={number}` selector
                        var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
                        if (result.err) {
                            return result;
                        }
                        selectorLocation = createLocation(startPosition, this.clonePosition());
                        selector = this.message.slice(startPosition.offset, this.offset());
                    }
                    else {
                        break;
                    }
                }
                // Duplicate selector clauses
                if (parsedSelectors.has(selector)) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR
                        : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);
                }
                if (selector === 'other') {
                    hasOtherClause = true;
                }
                // Parse:
                // one {one apple}
                //     ^----------^
                this.bumpSpace();
                var openingBracePosition = this.clonePosition();
                if (!this.bumpIf('{')) {
                    return this.error(parentArgType === 'select'
                        ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT
                        : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
                }
                var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);
                if (fragmentResult.err) {
                    return fragmentResult;
                }
                var argCloseResult = this.tryParseArgumentClose(openingBracePosition);
                if (argCloseResult.err) {
                    return argCloseResult;
                }
                options.push([
                    selector,
                    {
                        value: fragmentResult.val,
                        location: createLocation(openingBracePosition, this.clonePosition()),
                    },
                ]);
                // Keep track of the existing selectors
                parsedSelectors.add(selector);
                // Prep next selector clause.
                this.bumpSpace();
                (_a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location);
            }
            if (options.length === 0) {
                return this.error(parentArgType === 'select'
                    ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR
                    : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));
            }
            if (this.requiresOtherClause && !hasOtherClause) {
                return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));
            }
            return { val: options, err: null };
        };
        Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {
            var sign = 1;
            var startingPosition = this.clonePosition();
            if (this.bumpIf('+')) ;
            else if (this.bumpIf('-')) {
                sign = -1;
            }
            var hasDigits = false;
            var decimal = 0;
            while (!this.isEOF()) {
                var ch = this.char();
                if (ch >= 48 /* `0` */ && ch <= 57 /* `9` */) {
                    hasDigits = true;
                    decimal = decimal * 10 + (ch - 48);
                    this.bump();
                }
                else {
                    break;
                }
            }
            var location = createLocation(startingPosition, this.clonePosition());
            if (!hasDigits) {
                return this.error(expectNumberError, location);
            }
            decimal *= sign;
            if (!isSafeInteger(decimal)) {
                return this.error(invalidNumberError, location);
            }
            return { val: decimal, err: null };
        };
        Parser.prototype.offset = function () {
            return this.position.offset;
        };
        Parser.prototype.isEOF = function () {
            return this.offset() === this.message.length;
        };
        Parser.prototype.clonePosition = function () {
            // This is much faster than `Object.assign` or spread.
            return {
                offset: this.position.offset,
                line: this.position.line,
                column: this.position.column,
            };
        };
        /**
         * Return the code point at the current position of the parser.
         * Throws if the index is out of bound.
         */
        Parser.prototype.char = function () {
            var offset = this.position.offset;
            if (offset >= this.message.length) {
                throw Error('out of bound');
            }
            var code = codePointAt(this.message, offset);
            if (code === undefined) {
                throw Error("Offset ".concat(offset, " is at invalid UTF-16 code unit boundary"));
            }
            return code;
        };
        Parser.prototype.error = function (kind, location) {
            return {
                val: null,
                err: {
                    kind: kind,
                    message: this.message,
                    location: location,
                },
            };
        };
        /** Bump the parser to the next UTF-16 code unit. */
        Parser.prototype.bump = function () {
            if (this.isEOF()) {
                return;
            }
            var code = this.char();
            if (code === 10 /* '\n' */) {
                this.position.line += 1;
                this.position.column = 1;
                this.position.offset += 1;
            }
            else {
                this.position.column += 1;
                // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.
                this.position.offset += code < 0x10000 ? 1 : 2;
            }
        };
        /**
         * If the substring starting at the current position of the parser has
         * the given prefix, then bump the parser to the character immediately
         * following the prefix and return true. Otherwise, don't bump the parser
         * and return false.
         */
        Parser.prototype.bumpIf = function (prefix) {
            if (startsWith(this.message, prefix, this.offset())) {
                for (var i = 0; i < prefix.length; i++) {
                    this.bump();
                }
                return true;
            }
            return false;
        };
        /**
         * Bump the parser until the pattern character is found and return `true`.
         * Otherwise bump to the end of the file and return `false`.
         */
        Parser.prototype.bumpUntil = function (pattern) {
            var currentOffset = this.offset();
            var index = this.message.indexOf(pattern, currentOffset);
            if (index >= 0) {
                this.bumpTo(index);
                return true;
            }
            else {
                this.bumpTo(this.message.length);
                return false;
            }
        };
        /**
         * Bump the parser to the target offset.
         * If target offset is beyond the end of the input, bump the parser to the end of the input.
         */
        Parser.prototype.bumpTo = function (targetOffset) {
            if (this.offset() > targetOffset) {
                throw Error("targetOffset ".concat(targetOffset, " must be greater than or equal to the current offset ").concat(this.offset()));
            }
            targetOffset = Math.min(targetOffset, this.message.length);
            while (true) {
                var offset = this.offset();
                if (offset === targetOffset) {
                    break;
                }
                if (offset > targetOffset) {
                    throw Error("targetOffset ".concat(targetOffset, " is at invalid UTF-16 code unit boundary"));
                }
                this.bump();
                if (this.isEOF()) {
                    break;
                }
            }
        };
        /** advance the parser through all whitespace to the next non-whitespace code unit. */
        Parser.prototype.bumpSpace = function () {
            while (!this.isEOF() && _isWhiteSpace(this.char())) {
                this.bump();
            }
        };
        /**
         * Peek at the *next* Unicode codepoint in the input without advancing the parser.
         * If the input has been exhausted, then this returns null.
         */
        Parser.prototype.peek = function () {
            if (this.isEOF()) {
                return null;
            }
            var code = this.char();
            var offset = this.offset();
            var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));
            return nextCode !== null && nextCode !== void 0 ? nextCode : null;
        };
        return Parser;
    }());
    /**
     * This check if codepoint is alphabet (lower & uppercase)
     * @param codepoint
     * @returns
     */
    function _isAlpha(codepoint) {
        return ((codepoint >= 97 && codepoint <= 122) ||
            (codepoint >= 65 && codepoint <= 90));
    }
    function _isAlphaOrSlash(codepoint) {
        return _isAlpha(codepoint) || codepoint === 47; /* '/' */
    }
    /** See `parseTag` function docs. */
    function _isPotentialElementNameChar(c) {
        return (c === 45 /* '-' */ ||
            c === 46 /* '.' */ ||
            (c >= 48 && c <= 57) /* 0..9 */ ||
            c === 95 /* '_' */ ||
            (c >= 97 && c <= 122) /** a..z */ ||
            (c >= 65 && c <= 90) /* A..Z */ ||
            c == 0xb7 ||
            (c >= 0xc0 && c <= 0xd6) ||
            (c >= 0xd8 && c <= 0xf6) ||
            (c >= 0xf8 && c <= 0x37d) ||
            (c >= 0x37f && c <= 0x1fff) ||
            (c >= 0x200c && c <= 0x200d) ||
            (c >= 0x203f && c <= 0x2040) ||
            (c >= 0x2070 && c <= 0x218f) ||
            (c >= 0x2c00 && c <= 0x2fef) ||
            (c >= 0x3001 && c <= 0xd7ff) ||
            (c >= 0xf900 && c <= 0xfdcf) ||
            (c >= 0xfdf0 && c <= 0xfffd) ||
            (c >= 0x10000 && c <= 0xeffff));
    }
    /**
     * Code point equivalent of regex `\p{White_Space}`.
     * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isWhiteSpace(c) {
        return ((c >= 0x0009 && c <= 0x000d) ||
            c === 0x0020 ||
            c === 0x0085 ||
            (c >= 0x200e && c <= 0x200f) ||
            c === 0x2028 ||
            c === 0x2029);
    }
    /**
     * Code point equivalent of regex `\p{Pattern_Syntax}`.
     * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
     */
    function _isPatternSyntax(c) {
        return ((c >= 0x0021 && c <= 0x0023) ||
            c === 0x0024 ||
            (c >= 0x0025 && c <= 0x0027) ||
            c === 0x0028 ||
            c === 0x0029 ||
            c === 0x002a ||
            c === 0x002b ||
            c === 0x002c ||
            c === 0x002d ||
            (c >= 0x002e && c <= 0x002f) ||
            (c >= 0x003a && c <= 0x003b) ||
            (c >= 0x003c && c <= 0x003e) ||
            (c >= 0x003f && c <= 0x0040) ||
            c === 0x005b ||
            c === 0x005c ||
            c === 0x005d ||
            c === 0x005e ||
            c === 0x0060 ||
            c === 0x007b ||
            c === 0x007c ||
            c === 0x007d ||
            c === 0x007e ||
            c === 0x00a1 ||
            (c >= 0x00a2 && c <= 0x00a5) ||
            c === 0x00a6 ||
            c === 0x00a7 ||
            c === 0x00a9 ||
            c === 0x00ab ||
            c === 0x00ac ||
            c === 0x00ae ||
            c === 0x00b0 ||
            c === 0x00b1 ||
            c === 0x00b6 ||
            c === 0x00bb ||
            c === 0x00bf ||
            c === 0x00d7 ||
            c === 0x00f7 ||
            (c >= 0x2010 && c <= 0x2015) ||
            (c >= 0x2016 && c <= 0x2017) ||
            c === 0x2018 ||
            c === 0x2019 ||
            c === 0x201a ||
            (c >= 0x201b && c <= 0x201c) ||
            c === 0x201d ||
            c === 0x201e ||
            c === 0x201f ||
            (c >= 0x2020 && c <= 0x2027) ||
            (c >= 0x2030 && c <= 0x2038) ||
            c === 0x2039 ||
            c === 0x203a ||
            (c >= 0x203b && c <= 0x203e) ||
            (c >= 0x2041 && c <= 0x2043) ||
            c === 0x2044 ||
            c === 0x2045 ||
            c === 0x2046 ||
            (c >= 0x2047 && c <= 0x2051) ||
            c === 0x2052 ||
            c === 0x2053 ||
            (c >= 0x2055 && c <= 0x205e) ||
            (c >= 0x2190 && c <= 0x2194) ||
            (c >= 0x2195 && c <= 0x2199) ||
            (c >= 0x219a && c <= 0x219b) ||
            (c >= 0x219c && c <= 0x219f) ||
            c === 0x21a0 ||
            (c >= 0x21a1 && c <= 0x21a2) ||
            c === 0x21a3 ||
            (c >= 0x21a4 && c <= 0x21a5) ||
            c === 0x21a6 ||
            (c >= 0x21a7 && c <= 0x21ad) ||
            c === 0x21ae ||
            (c >= 0x21af && c <= 0x21cd) ||
            (c >= 0x21ce && c <= 0x21cf) ||
            (c >= 0x21d0 && c <= 0x21d1) ||
            c === 0x21d2 ||
            c === 0x21d3 ||
            c === 0x21d4 ||
            (c >= 0x21d5 && c <= 0x21f3) ||
            (c >= 0x21f4 && c <= 0x22ff) ||
            (c >= 0x2300 && c <= 0x2307) ||
            c === 0x2308 ||
            c === 0x2309 ||
            c === 0x230a ||
            c === 0x230b ||
            (c >= 0x230c && c <= 0x231f) ||
            (c >= 0x2320 && c <= 0x2321) ||
            (c >= 0x2322 && c <= 0x2328) ||
            c === 0x2329 ||
            c === 0x232a ||
            (c >= 0x232b && c <= 0x237b) ||
            c === 0x237c ||
            (c >= 0x237d && c <= 0x239a) ||
            (c >= 0x239b && c <= 0x23b3) ||
            (c >= 0x23b4 && c <= 0x23db) ||
            (c >= 0x23dc && c <= 0x23e1) ||
            (c >= 0x23e2 && c <= 0x2426) ||
            (c >= 0x2427 && c <= 0x243f) ||
            (c >= 0x2440 && c <= 0x244a) ||
            (c >= 0x244b && c <= 0x245f) ||
            (c >= 0x2500 && c <= 0x25b6) ||
            c === 0x25b7 ||
            (c >= 0x25b8 && c <= 0x25c0) ||
            c === 0x25c1 ||
            (c >= 0x25c2 && c <= 0x25f7) ||
            (c >= 0x25f8 && c <= 0x25ff) ||
            (c >= 0x2600 && c <= 0x266e) ||
            c === 0x266f ||
            (c >= 0x2670 && c <= 0x2767) ||
            c === 0x2768 ||
            c === 0x2769 ||
            c === 0x276a ||
            c === 0x276b ||
            c === 0x276c ||
            c === 0x276d ||
            c === 0x276e ||
            c === 0x276f ||
            c === 0x2770 ||
            c === 0x2771 ||
            c === 0x2772 ||
            c === 0x2773 ||
            c === 0x2774 ||
            c === 0x2775 ||
            (c >= 0x2794 && c <= 0x27bf) ||
            (c >= 0x27c0 && c <= 0x27c4) ||
            c === 0x27c5 ||
            c === 0x27c6 ||
            (c >= 0x27c7 && c <= 0x27e5) ||
            c === 0x27e6 ||
            c === 0x27e7 ||
            c === 0x27e8 ||
            c === 0x27e9 ||
            c === 0x27ea ||
            c === 0x27eb ||
            c === 0x27ec ||
            c === 0x27ed ||
            c === 0x27ee ||
            c === 0x27ef ||
            (c >= 0x27f0 && c <= 0x27ff) ||
            (c >= 0x2800 && c <= 0x28ff) ||
            (c >= 0x2900 && c <= 0x2982) ||
            c === 0x2983 ||
            c === 0x2984 ||
            c === 0x2985 ||
            c === 0x2986 ||
            c === 0x2987 ||
            c === 0x2988 ||
            c === 0x2989 ||
            c === 0x298a ||
            c === 0x298b ||
            c === 0x298c ||
            c === 0x298d ||
            c === 0x298e ||
            c === 0x298f ||
            c === 0x2990 ||
            c === 0x2991 ||
            c === 0x2992 ||
            c === 0x2993 ||
            c === 0x2994 ||
            c === 0x2995 ||
            c === 0x2996 ||
            c === 0x2997 ||
            c === 0x2998 ||
            (c >= 0x2999 && c <= 0x29d7) ||
            c === 0x29d8 ||
            c === 0x29d9 ||
            c === 0x29da ||
            c === 0x29db ||
            (c >= 0x29dc && c <= 0x29fb) ||
            c === 0x29fc ||
            c === 0x29fd ||
            (c >= 0x29fe && c <= 0x2aff) ||
            (c >= 0x2b00 && c <= 0x2b2f) ||
            (c >= 0x2b30 && c <= 0x2b44) ||
            (c >= 0x2b45 && c <= 0x2b46) ||
            (c >= 0x2b47 && c <= 0x2b4c) ||
            (c >= 0x2b4d && c <= 0x2b73) ||
            (c >= 0x2b74 && c <= 0x2b75) ||
            (c >= 0x2b76 && c <= 0x2b95) ||
            c === 0x2b96 ||
            (c >= 0x2b97 && c <= 0x2bff) ||
            (c >= 0x2e00 && c <= 0x2e01) ||
            c === 0x2e02 ||
            c === 0x2e03 ||
            c === 0x2e04 ||
            c === 0x2e05 ||
            (c >= 0x2e06 && c <= 0x2e08) ||
            c === 0x2e09 ||
            c === 0x2e0a ||
            c === 0x2e0b ||
            c === 0x2e0c ||
            c === 0x2e0d ||
            (c >= 0x2e0e && c <= 0x2e16) ||
            c === 0x2e17 ||
            (c >= 0x2e18 && c <= 0x2e19) ||
            c === 0x2e1a ||
            c === 0x2e1b ||
            c === 0x2e1c ||
            c === 0x2e1d ||
            (c >= 0x2e1e && c <= 0x2e1f) ||
            c === 0x2e20 ||
            c === 0x2e21 ||
            c === 0x2e22 ||
            c === 0x2e23 ||
            c === 0x2e24 ||
            c === 0x2e25 ||
            c === 0x2e26 ||
            c === 0x2e27 ||
            c === 0x2e28 ||
            c === 0x2e29 ||
            (c >= 0x2e2a && c <= 0x2e2e) ||
            c === 0x2e2f ||
            (c >= 0x2e30 && c <= 0x2e39) ||
            (c >= 0x2e3a && c <= 0x2e3b) ||
            (c >= 0x2e3c && c <= 0x2e3f) ||
            c === 0x2e40 ||
            c === 0x2e41 ||
            c === 0x2e42 ||
            (c >= 0x2e43 && c <= 0x2e4f) ||
            (c >= 0x2e50 && c <= 0x2e51) ||
            c === 0x2e52 ||
            (c >= 0x2e53 && c <= 0x2e7f) ||
            (c >= 0x3001 && c <= 0x3003) ||
            c === 0x3008 ||
            c === 0x3009 ||
            c === 0x300a ||
            c === 0x300b ||
            c === 0x300c ||
            c === 0x300d ||
            c === 0x300e ||
            c === 0x300f ||
            c === 0x3010 ||
            c === 0x3011 ||
            (c >= 0x3012 && c <= 0x3013) ||
            c === 0x3014 ||
            c === 0x3015 ||
            c === 0x3016 ||
            c === 0x3017 ||
            c === 0x3018 ||
            c === 0x3019 ||
            c === 0x301a ||
            c === 0x301b ||
            c === 0x301c ||
            c === 0x301d ||
            (c >= 0x301e && c <= 0x301f) ||
            c === 0x3020 ||
            c === 0x3030 ||
            c === 0xfd3e ||
            c === 0xfd3f ||
            (c >= 0xfe45 && c <= 0xfe46));
    }

    function pruneLocation(els) {
        els.forEach(function (el) {
            delete el.location;
            if (isSelectElement(el) || isPluralElement(el)) {
                for (var k in el.options) {
                    delete el.options[k].location;
                    pruneLocation(el.options[k].value);
                }
            }
            else if (isNumberElement(el) && isNumberSkeleton(el.style)) {
                delete el.style.location;
            }
            else if ((isDateElement(el) || isTimeElement(el)) &&
                isDateTimeSkeleton(el.style)) {
                delete el.style.location;
            }
            else if (isTagElement(el)) {
                pruneLocation(el.children);
            }
        });
    }
    function parse$1(message, opts) {
        if (opts === void 0) { opts = {}; }
        opts = __assign$2({ shouldParseSkeletons: true, requiresOtherClause: true }, opts);
        var result = new Parser(message, opts).parse();
        if (result.err) {
            var error = SyntaxError(ErrorKind[result.err.kind]);
            // @ts-expect-error Assign to error object
            error.location = result.err.location;
            // @ts-expect-error Assign to error object
            error.originalMessage = result.err.message;
            throw error;
        }
        if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {
            pruneLocation(result.val);
        }
        return result.val;
    }

    //
    // Main
    //
    function memoize(fn, options) {
        var cache = options && options.cache ? options.cache : cacheDefault;
        var serializer = options && options.serializer ? options.serializer : serializerDefault;
        var strategy = options && options.strategy ? options.strategy : strategyDefault;
        return strategy(fn, {
            cache: cache,
            serializer: serializer,
        });
    }
    //
    // Strategy
    //
    function isPrimitive(value) {
        return (value == null || typeof value === 'number' || typeof value === 'boolean'); // || typeof value === "string" 'unsafe' primitive for our needs
    }
    function monadic(fn, cache, serializer, arg) {
        var cacheKey = isPrimitive(arg) ? arg : serializer(arg);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.call(this, arg);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function variadic(fn, cache, serializer) {
        var args = Array.prototype.slice.call(arguments, 3);
        var cacheKey = serializer(args);
        var computedValue = cache.get(cacheKey);
        if (typeof computedValue === 'undefined') {
            computedValue = fn.apply(this, args);
            cache.set(cacheKey, computedValue);
        }
        return computedValue;
    }
    function assemble(fn, context, strategy, cache, serialize) {
        return strategy.bind(context, fn, cache, serialize);
    }
    function strategyDefault(fn, options) {
        var strategy = fn.length === 1 ? monadic : variadic;
        return assemble(fn, this, strategy, options.cache.create(), options.serializer);
    }
    function strategyVariadic(fn, options) {
        return assemble(fn, this, variadic, options.cache.create(), options.serializer);
    }
    function strategyMonadic(fn, options) {
        return assemble(fn, this, monadic, options.cache.create(), options.serializer);
    }
    //
    // Serializer
    //
    var serializerDefault = function () {
        return JSON.stringify(arguments);
    };
    //
    // Cache
    //
    function ObjectWithoutPrototypeCache() {
        this.cache = Object.create(null);
    }
    ObjectWithoutPrototypeCache.prototype.get = function (key) {
        return this.cache[key];
    };
    ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
        this.cache[key] = value;
    };
    var cacheDefault = {
        create: function create() {
            // @ts-ignore
            return new ObjectWithoutPrototypeCache();
        },
    };
    var strategies = {
        variadic: strategyVariadic,
        monadic: strategyMonadic,
    };

    var ErrorCode;
    (function (ErrorCode) {
        // When we have a placeholder but no value to format
        ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
        // When value supplied is invalid
        ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
        // When we need specific Intl API but it's not available
        ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
    })(ErrorCode || (ErrorCode = {}));
    var FormatError = /** @class */ (function (_super) {
        __extends(FormatError, _super);
        function FormatError(msg, code, originalMessage) {
            var _this = _super.call(this, msg) || this;
            _this.code = code;
            _this.originalMessage = originalMessage;
            return _this;
        }
        FormatError.prototype.toString = function () {
            return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
        };
        return FormatError;
    }(Error));
    var InvalidValueError = /** @class */ (function (_super) {
        __extends(InvalidValueError, _super);
        function InvalidValueError(variableId, value, options, originalMessage) {
            return _super.call(this, "Invalid values for \"".concat(variableId, "\": \"").concat(value, "\". Options are \"").concat(Object.keys(options).join('", "'), "\""), ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueError;
    }(FormatError));
    var InvalidValueTypeError = /** @class */ (function (_super) {
        __extends(InvalidValueTypeError, _super);
        function InvalidValueTypeError(value, type, originalMessage) {
            return _super.call(this, "Value for \"".concat(value, "\" must be of type ").concat(type), ErrorCode.INVALID_VALUE, originalMessage) || this;
        }
        return InvalidValueTypeError;
    }(FormatError));
    var MissingValueError = /** @class */ (function (_super) {
        __extends(MissingValueError, _super);
        function MissingValueError(variableId, originalMessage) {
            return _super.call(this, "The intl string context variable \"".concat(variableId, "\" was not provided to the string \"").concat(originalMessage, "\""), ErrorCode.MISSING_VALUE, originalMessage) || this;
        }
        return MissingValueError;
    }(FormatError));

    var PART_TYPE;
    (function (PART_TYPE) {
        PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
        PART_TYPE[PART_TYPE["object"] = 1] = "object";
    })(PART_TYPE || (PART_TYPE = {}));
    function mergeLiteral(parts) {
        if (parts.length < 2) {
            return parts;
        }
        return parts.reduce(function (all, part) {
            var lastPart = all[all.length - 1];
            if (!lastPart ||
                lastPart.type !== PART_TYPE.literal ||
                part.type !== PART_TYPE.literal) {
                all.push(part);
            }
            else {
                lastPart.value += part.value;
            }
            return all;
        }, []);
    }
    function isFormatXMLElementFn(el) {
        return typeof el === 'function';
    }
    // TODO(skeleton): add skeleton support
    function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
    // For debugging
    originalMessage) {
        // Hot path for straight simple msg translations
        if (els.length === 1 && isLiteralElement(els[0])) {
            return [
                {
                    type: PART_TYPE.literal,
                    value: els[0].value,
                },
            ];
        }
        var result = [];
        for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
            var el = els_1[_i];
            // Exit early for string parts.
            if (isLiteralElement(el)) {
                result.push({
                    type: PART_TYPE.literal,
                    value: el.value,
                });
                continue;
            }
            // TODO: should this part be literal type?
            // Replace `#` in plural rules with the actual numeric value.
            if (isPoundElement(el)) {
                if (typeof currentPluralValue === 'number') {
                    result.push({
                        type: PART_TYPE.literal,
                        value: formatters.getNumberFormat(locales).format(currentPluralValue),
                    });
                }
                continue;
            }
            var varName = el.value;
            // Enforce that all required values are provided by the caller.
            if (!(values && varName in values)) {
                throw new MissingValueError(varName, originalMessage);
            }
            var value = values[varName];
            if (isArgumentElement(el)) {
                if (!value || typeof value === 'string' || typeof value === 'number') {
                    value =
                        typeof value === 'string' || typeof value === 'number'
                            ? String(value)
                            : '';
                }
                result.push({
                    type: typeof value === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                    value: value,
                });
                continue;
            }
            // Recursively format plural and select parts' option — which can be a
            // nested pattern structure. The choosing of the option to use is
            // abstracted-by and delegated-to the part helper object.
            if (isDateElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.date[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTimeElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.time[el.style]
                    : isDateTimeSkeleton(el.style)
                        ? el.style.parsedOptions
                        : formats.time.medium;
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getDateTimeFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isNumberElement(el)) {
                var style = typeof el.style === 'string'
                    ? formats.number[el.style]
                    : isNumberSkeleton(el.style)
                        ? el.style.parsedOptions
                        : undefined;
                if (style && style.scale) {
                    value =
                        value *
                            (style.scale || 1);
                }
                result.push({
                    type: PART_TYPE.literal,
                    value: formatters
                        .getNumberFormat(locales, style)
                        .format(value),
                });
                continue;
            }
            if (isTagElement(el)) {
                var children = el.children, value_1 = el.value;
                var formatFn = values[value_1];
                if (!isFormatXMLElementFn(formatFn)) {
                    throw new InvalidValueTypeError(value_1, 'function', originalMessage);
                }
                var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
                var chunks = formatFn(parts.map(function (p) { return p.value; }));
                if (!Array.isArray(chunks)) {
                    chunks = [chunks];
                }
                result.push.apply(result, chunks.map(function (c) {
                    return {
                        type: typeof c === 'string' ? PART_TYPE.literal : PART_TYPE.object,
                        value: c,
                    };
                }));
            }
            if (isSelectElement(el)) {
                var opt = el.options[value] || el.options.other;
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
                continue;
            }
            if (isPluralElement(el)) {
                var opt = el.options["=".concat(value)];
                if (!opt) {
                    if (!Intl.PluralRules) {
                        throw new FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", ErrorCode.MISSING_INTL_API, originalMessage);
                    }
                    var rule = formatters
                        .getPluralRules(locales, { type: el.pluralType })
                        .select(value - (el.offset || 0));
                    opt = el.options[rule] || el.options.other;
                }
                if (!opt) {
                    throw new InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
                }
                result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
                continue;
            }
        }
        return mergeLiteral(result);
    }

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    // -- MessageFormat --------------------------------------------------------
    function mergeConfig(c1, c2) {
        if (!c2) {
            return c1;
        }
        return __assign$2(__assign$2(__assign$2({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
            all[k] = __assign$2(__assign$2({}, c1[k]), (c2[k] || {}));
            return all;
        }, {}));
    }
    function mergeConfigs(defaultConfig, configs) {
        if (!configs) {
            return defaultConfig;
        }
        return Object.keys(defaultConfig).reduce(function (all, k) {
            all[k] = mergeConfig(defaultConfig[k], configs[k]);
            return all;
        }, __assign$2({}, defaultConfig));
    }
    function createFastMemoizeCache(store) {
        return {
            create: function () {
                return {
                    get: function (key) {
                        return store[key];
                    },
                    set: function (key, value) {
                        store[key] = value;
                    },
                };
            },
        };
    }
    function createDefaultFormatters(cache) {
        if (cache === void 0) { cache = {
            number: {},
            dateTime: {},
            pluralRules: {},
        }; }
        return {
            getNumberFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArray$1([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.number),
                strategy: strategies.variadic,
            }),
            getDateTimeFormat: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArray$1([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.dateTime),
                strategy: strategies.variadic,
            }),
            getPluralRules: memoize(function () {
                var _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArray$1([void 0], args, false)))();
            }, {
                cache: createFastMemoizeCache(cache.pluralRules),
                strategy: strategies.variadic,
            }),
        };
    }
    var IntlMessageFormat = /** @class */ (function () {
        function IntlMessageFormat(message, locales, overrideFormats, opts) {
            var _this = this;
            if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
            this.formatterCache = {
                number: {},
                dateTime: {},
                pluralRules: {},
            };
            this.format = function (values) {
                var parts = _this.formatToParts(values);
                // Hot path for straight simple msg translations
                if (parts.length === 1) {
                    return parts[0].value;
                }
                var result = parts.reduce(function (all, part) {
                    if (!all.length ||
                        part.type !== PART_TYPE.literal ||
                        typeof all[all.length - 1] !== 'string') {
                        all.push(part.value);
                    }
                    else {
                        all[all.length - 1] += part.value;
                    }
                    return all;
                }, []);
                if (result.length <= 1) {
                    return result[0] || '';
                }
                return result;
            };
            this.formatToParts = function (values) {
                return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
            };
            this.resolvedOptions = function () { return ({
                locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
            }); };
            this.getAst = function () { return _this.ast; };
            if (typeof message === 'string') {
                this.message = message;
                if (!IntlMessageFormat.__parse) {
                    throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
                }
                // Parse string messages into an AST.
                this.ast = IntlMessageFormat.__parse(message, {
                    ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
                });
            }
            else {
                this.ast = message;
            }
            if (!Array.isArray(this.ast)) {
                throw new TypeError('A message must be provided as a String or AST.');
            }
            // Creates a new object with the specified `formats` merged with the default
            // formats.
            this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
            // Defined first because it's used to build the format pattern.
            this.locales = locales;
            this.formatters =
                (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
        }
        Object.defineProperty(IntlMessageFormat, "defaultLocale", {
            get: function () {
                if (!IntlMessageFormat.memoizedDefaultLocale) {
                    IntlMessageFormat.memoizedDefaultLocale =
                        new Intl.NumberFormat().resolvedOptions().locale;
                }
                return IntlMessageFormat.memoizedDefaultLocale;
            },
            enumerable: false,
            configurable: true
        });
        IntlMessageFormat.memoizedDefaultLocale = null;
        IntlMessageFormat.__parse = parse$1;
        // Default format options used as the prototype of the `formats` provided to the
        // constructor. These are used when constructing the internal Intl.NumberFormat
        // and Intl.DateTimeFormat instances.
        IntlMessageFormat.formats = {
            number: {
                integer: {
                    maximumFractionDigits: 0,
                },
                currency: {
                    style: 'currency',
                },
                percent: {
                    style: 'percent',
                },
            },
            date: {
                short: {
                    month: 'numeric',
                    day: 'numeric',
                    year: '2-digit',
                },
                medium: {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                },
                long: {
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
                full: {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric',
                },
            },
            time: {
                short: {
                    hour: 'numeric',
                    minute: 'numeric',
                },
                medium: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                },
                long: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
                full: {
                    hour: 'numeric',
                    minute: 'numeric',
                    second: 'numeric',
                    timeZoneName: 'short',
                },
            },
        };
        return IntlMessageFormat;
    }());

    /*
    Copyright (c) 2014, Yahoo! Inc. All rights reserved.
    Copyrights licensed under the New BSD License.
    See the accompanying LICENSE file for terms.
    */
    var o = IntlMessageFormat;

    const r={},i=(e,n,t)=>t?(n in r||(r[n]={}),e in r[n]||(r[n][e]=t),t):t,l=(e,n)=>{if(null==n)return;if(n in r&&e in r[n])return r[n][e];const t=E(n);for(let o=0;o<t.length;o++){const r=c(t[o],e);if(r)return i(e,n,r)}};let a;const s=writable({});function u(e){return e in a}function c(e,n){if(!u(e))return null;const t=function(e){return a[e]||null}(e);return function(e,n){if(null==n)return;if(n in e)return e[n];const t=n.split(".");let o=e;for(let e=0;e<t.length;e++)if("object"==typeof o){if(e>0){const n=t.slice(e,t.length).join(".");if(n in o){o=o[n];break}}o=o[t[e]];}else o=void 0;return o}(t,n)}function m(e,...n){delete r[e],s.update((o=>(o[e]=cjs.all([o[e]||{},...n]),o)));}derived([s],(([e])=>Object.keys(e)));s.subscribe((e=>a=e));const d={};function g(e){return d[e]}function h(e){return null!=e&&E(e).some((e=>{var n;return null===(n=g(e))||void 0===n?void 0:n.size}))}function w(e,n){const t=Promise.all(n.map((n=>(function(e,n){d[e].delete(n),0===d[e].size&&delete d[e];}(e,n),n().then((e=>e.default||e))))));return t.then((n=>m(e,...n)))}const p={};function b(e){if(!h(e))return e in p?p[e]:Promise.resolve();const n=function(e){return E(e).map((e=>{const n=g(e);return [e,n?[...n]:[]]})).filter((([,e])=>e.length>0))}(e);return p[e]=Promise.all(n.map((([e,n])=>w(e,n)))).then((()=>{if(h(e))return b(e);delete p[e];})),p[e]}/*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */function v(e,n){var t={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&n.indexOf(o)<0&&(t[o]=e[o]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(o=Object.getOwnPropertySymbols(e);r<o.length;r++)n.indexOf(o[r])<0&&Object.prototype.propertyIsEnumerable.call(e,o[r])&&(t[o[r]]=e[o[r]]);}return t}const j={fallbackLocale:null,loadingDelay:200,formats:{number:{scientific:{notation:"scientific"},engineering:{notation:"engineering"},compactLong:{notation:"compact",compactDisplay:"long"},compactShort:{notation:"compact",compactDisplay:"short"}},date:{short:{month:"numeric",day:"numeric",year:"2-digit"},medium:{month:"short",day:"numeric",year:"numeric"},long:{month:"long",day:"numeric",year:"numeric"},full:{weekday:"long",month:"long",day:"numeric",year:"numeric"}},time:{short:{hour:"numeric",minute:"numeric"},medium:{hour:"numeric",minute:"numeric",second:"numeric"},long:{hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"short"},full:{hour:"numeric",minute:"numeric",second:"numeric",timeZoneName:"short"}}},warnOnMissingMessages:!0,handleMissingMessage:void 0,ignoreTag:!0};function M(){return j}const k=writable(!1);let T;const L=writable(null);function x(e){return e.split("-").map(((e,n,t)=>t.slice(0,n+1).join("-"))).reverse()}function E(e,n=M().fallbackLocale){const t=x(e);return n?[...new Set([...t,...x(n)])]:t}function P(){return null!=T?T:void 0}L.subscribe((e=>{T=null!=e?e:void 0,"undefined"!=typeof window&&null!=e&&document.documentElement.setAttribute("lang",e);}));const D=Object.assign(Object.assign({},L),{set:e=>{if(e&&function(e){if(null==e)return;const n=E(e);for(let e=0;e<n.length;e++){const t=n[e];if(u(t))return t}}(e)&&h(e)){const{loadingDelay:n}=M();let t;return "undefined"!=typeof window&&null!=P()&&n?t=window.setTimeout((()=>k.set(!0)),n):k.set(!0),b(e).then((()=>{L.set(e);})).finally((()=>{clearTimeout(t),k.set(!1);}))}return L.set(e)}}),C=e=>{const n=Object.create(null);return t=>{const o=JSON.stringify(t);return o in n?n[o]:n[o]=e(t)}},G=(e,n)=>{const{formats:t}=M();if(e in t&&n in t[e])return t[e][n];throw new Error(`[svelte-i18n] Unknown "${n}" ${e} format.`)},J=C((e=>{var{locale:n,format:t}=e,o=v(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format numbers');return t&&(o=G("number",t)),new Intl.NumberFormat(n,o)})),U=C((e=>{var{locale:n,format:t}=e,o=v(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format dates');return t?o=G("date",t):0===Object.keys(o).length&&(o=G("date","short")),new Intl.DateTimeFormat(n,o)})),V=C((e=>{var{locale:n,format:t}=e,o=v(e,["locale","format"]);if(null==n)throw new Error('[svelte-i18n] A "locale" must be set to format time values');return t?o=G("time",t):0===Object.keys(o).length&&(o=G("time","short")),new Intl.DateTimeFormat(n,o)})),_=(e={})=>{var{locale:n=P()}=e,t=v(e,["locale"]);return J(Object.assign({locale:n},t))},q=(e={})=>{var{locale:n=P()}=e,t=v(e,["locale"]);return U(Object.assign({locale:n},t))},B=(e={})=>{var{locale:n=P()}=e,t=v(e,["locale"]);return V(Object.assign({locale:n},t))},H=C(((e,n=P())=>new o(e,n,M().formats,{ignoreTag:M().ignoreTag}))),K=(e,n={})=>{var t,o,r,i;let a=n;"object"==typeof e&&(a=e,e=a.id);const{values:s,locale:u=P(),default:c}=a;if(null==u)throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");let m=l(e,u);if(m){if("string"!=typeof m)return console.warn(`[svelte-i18n] Message with id "${e}" must be of type "string", found: "${typeof m}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`),m}else m=null!==(i=null!==(r=null===(o=(t=M()).handleMissingMessage)||void 0===o?void 0:o.call(t,{locale:u,id:e,defaultValue:c}))&&void 0!==r?r:c)&&void 0!==i?i:e;if(!s)return m;let f=m;try{f=H(m,u).format(s);}catch(n){console.warn(`[svelte-i18n] Message "${e}" has syntax error:`,n.message);}return f},Q=(e,n)=>B(n).format(e),R=(e,n)=>q(n).format(e),W=(e,n)=>_(n).format(e),X=(e,n=P())=>l(e,n),Y=derived([D,s],(()=>K));derived([D],(()=>Q));derived([D],(()=>R));derived([D],(()=>W));derived([D,s],(()=>X));

    /* src/GlobalStyle.svelte generated by Svelte v3.47.0 */

    function add_css$j(target) {
    	append_styles(target, "svelte-1ds1say", "html,body{position:relative;width:100%;height:100%}body{margin:0;padding:0;font-weight:lighter}input,button,select,textarea{font-family:inherit;font-size:inherit}button{color:currentColor;transition:color 0.2s ease-in-out;cursor:pointer}a{text-decoration:none;color:currentColor;transition:color 0.2s ease-in-out}p{margin:0px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2xvYmFsU3R5bGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUNVLElBQUksQUFBQyxDQUNMLElBQUksQUFBRSxDQUFBLEFBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxBQUNkLENBQUEsQUFFUSxJQUFJLEFBQUUsQ0FBQSxBQUNaLE1BQU0sQ0FBRSxDQUFDLENBQ1QsT0FBTyxDQUFFLENBQUMsQ0FDVixXQUFXLENBQUUsT0FBTyxBQUN0QixDQUFBLEFBRVEsS0FBSyxBQUFDLENBQ04sTUFBTSxBQUFDLENBQ1AsTUFBTSxBQUFDLENBQ1AsUUFBUSxBQUFFLENBQUEsQUFDaEIsV0FBVyxDQUFFLE9BQU8sQ0FDcEIsU0FBUyxDQUFFLE9BQU8sQUFDcEIsQ0FBQSxBQUVRLE1BQU0sQUFBRSxDQUFBLEFBQ2QsS0FBSyxDQUFFLFlBQVksQ0FDbkIsVUFBVSxDQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUNsQyxNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFBLEFBRVEsQ0FBQyxBQUFFLENBQUEsQUFDVCxlQUFlLENBQUUsSUFBSSxDQUNyQixLQUFLLENBQUUsWUFBWSxDQUNuQixVQUFVLENBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLEFBQ3BDLENBQUEsQUFFUSxDQUFDLEFBQUUsQ0FBQSxBQUNULE1BQU0sQ0FBRSxHQUFHLEFBQ2IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHbG9iYWxTdHlsZS5zdmVsdGUiXX0= */");
    }

    function create_fragment$N(ctx) {
    	const block = {
    		c: noop$1,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('GlobalStyle', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GlobalStyle> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class GlobalStyle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$J, create_fragment$N, safe_not_equal, {}, add_css$j);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GlobalStyle",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    var moment$1 = {exports: {}};

    (function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    }(commonjsGlobal, (function () {
        var hookCallback;

        function hooks() {
            return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
            hookCallback = callback;
        }

        function isArray(input) {
            return (
                input instanceof Array ||
                Object.prototype.toString.call(input) === '[object Array]'
            );
        }

        function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
                input != null &&
                Object.prototype.toString.call(input) === '[object Object]'
            );
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
                return Object.getOwnPropertyNames(obj).length === 0;
            } else {
                var k;
                for (k in obj) {
                    if (hasOwnProp(obj, k)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function isUndefined(input) {
            return input === void 0;
        }

        function isNumber(input) {
            return (
                typeof input === 'number' ||
                Object.prototype.toString.call(input) === '[object Number]'
            );
        }

        function isDate(input) {
            return (
                input instanceof Date ||
                Object.prototype.toString.call(input) === '[object Date]'
            );
        }

        function map(arr, fn) {
            var res = [],
                i,
                arrLen = arr.length;
            for (i = 0; i < arrLen; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }

        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }

            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }

            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }

            return a;
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty: false,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: false,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: false,
                userInvalidated: false,
                iso: false,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: false,
                weekdayMismatch: false,
            };
        }

        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }

        var some;
        if (Array.prototype.some) {
            some = Array.prototype.some;
        } else {
            some = function (fun) {
                var t = Object(this),
                    len = t.length >>> 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                    }
                }

                return false;
            };
        }

        function isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    }),
                    isNowValid =
                        !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                if (m._strict) {
                    isNowValid =
                        isNowValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }

                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                    m._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
            }
            return m._isValid;
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            } else {
                getParsingFlags(m).userInvalidated = true;
            }

            return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

        function copyConfig(to, from) {
            var i,
                prop,
                val,
                momentPropertiesLen = momentProperties.length;

            if (!isUndefined(from._isAMomentObject)) {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
                to._i = from._i;
            }
            if (!isUndefined(from._f)) {
                to._f = from._f;
            }
            if (!isUndefined(from._l)) {
                to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
                to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
                to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
                to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
                to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
                to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
                to._locale = from._locale;
            }

            if (momentPropertiesLen > 0) {
                for (i = 0; i < momentPropertiesLen; i++) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (!isUndefined(val)) {
                        to[prop] = val;
                    }
                }
            }

            return to;
        }

        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
                this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                hooks.updateOffset(this);
                updateInProgress = false;
            }
        }

        function isMoment(obj) {
            return (
                obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
            );
        }

        function warn(msg) {
            if (
                hooks.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' &&
                console.warn
            ) {
                console.warn('Deprecation warning: ' + msg);
            }
        }

        function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(null, msg);
                }
                if (firstTime) {
                    var args = [],
                        arg,
                        i,
                        key,
                        argLen = arguments.length;
                    for (i = 0; i < argLen; i++) {
                        arg = '';
                        if (typeof arguments[i] === 'object') {
                            arg += '\n[' + i + '] ';
                            for (key in arguments[0]) {
                                if (hasOwnProp(arguments[0], key)) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                            }
                            arg = arg.slice(0, -2); // Remove trailing comma and space
                        } else {
                            arg = arguments[i];
                        }
                        args.push(arg);
                    }
                    warn(
                        msg +
                            '\nArguments: ' +
                            Array.prototype.slice.call(args).join('') +
                            '\n' +
                            new Error().stack
                    );
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        function set(config) {
            var prop, i;
            for (i in config) {
                if (hasOwnProp(config, i)) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
                (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                    '|' +
                    /\d{1,2}/.source
            );
        }

        function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
                prop;
            for (prop in childConfig) {
                if (hasOwnProp(childConfig, prop)) {
                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                    } else {
                        delete res[prop];
                    }
                }
            }
            for (prop in parentConfig) {
                if (
                    hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])
                ) {
                    // make sure changes to properties don't modify parent config
                    res[prop] = extend({}, res[prop]);
                }
            }
            return res;
        }

        function Locale(config) {
            if (config != null) {
                this.set(config);
            }
        }

        var keys;

        if (Object.keys) {
            keys = Object.keys;
        } else {
            keys = function (obj) {
                var i,
                    res = [];
                for (i in obj) {
                    if (hasOwnProp(obj, i)) {
                        res.push(i);
                    }
                }
                return res;
            };
        }

        var defaultCalendar = {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        };

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar['sameElse'];
            return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = '' + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (
                (sign ? (forceSign ? '+' : '') : '-') +
                Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                absNumber
            );
        }

        var formattingTokens =
                /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(
                        func.apply(this, arguments),
                        token
                    );
                };
            }
        }

        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
                i,
                length;

            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }

            return function (mom) {
                var output = '',
                    i;
                for (i = 0; i < length; i++) {
                    output += isFunction(array[i])
                        ? array[i].call(mom, format)
                        : array[i];
                }
                return output;
            };
        }

        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
                formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(
                    localFormattingTokens,
                    replaceLongDateFormatTokens
                );
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }

            return format;
        }

        var defaultLongDateFormat = {
            LTS: 'h:mm:ss A',
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        };

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
                return format;
            }

            this._longDateFormat[key] = formatUpper
                .match(formattingTokens)
                .map(function (tok) {
                    if (
                        tok === 'MMMM' ||
                        tok === 'MM' ||
                        tok === 'DD' ||
                        tok === 'dddd'
                    ) {
                        return tok.slice(1);
                    }
                    return tok;
                })
                .join('');

            return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
            return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
            return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            w: 'a week',
            ww: '%d weeks',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
                ? output(number, withoutSuffix, string, isFuture)
                : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
            return typeof units === 'string'
                ? aliases[units] || aliases[units.toLowerCase()]
                : undefined;
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;

            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }

            return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [],
                u;
            for (u in unitsObj) {
                if (hasOwnProp(unitsObj, u)) {
                    units.push({ unit: u, priority: priorities[u] });
                }
            }
            units.sort(function (a, b) {
                return a.priority - b.priority;
            });
            return units;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }

        function absFloor(number) {
            if (number < 0) {
                // -0 -> 0
                return Math.ceil(number) || 0;
            } else {
                return Math.floor(number);
            }
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                value = absFloor(coercedNumber);
            }

            return value;
        }

        function makeGetSet(unit, keepTime) {
            return function (value) {
                if (value != null) {
                    set$1(this, unit, value);
                    hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get(this, unit);
                }
            };
        }

        function get(mom, unit) {
            return mom.isValid()
                ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
                : NaN;
        }

        function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
                if (
                    unit === 'FullYear' &&
                    isLeapYear(mom.year()) &&
                    mom.month() === 1 &&
                    mom.date() === 29
                ) {
                    value = toInt(value);
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                        value,
                        mom.month(),
                        daysInMonth(value, mom.month())
                    );
                } else {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }
        }

        // MOMENTS

        function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units]();
            }
            return this;
        }

        function stringSet(units, value) {
            if (typeof units === 'object') {
                units = normalizeObjectUnits(units);
                var prioritized = getPrioritizedUnits(units),
                    i,
                    prioritizedLen = prioritized.length;
                for (i = 0; i < prioritizedLen; i++) {
                    this[prioritized[i].unit](units[prioritized[i].unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units](value);
                }
            }
            return this;
        }

        var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord =
                /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
                ? regex
                : function (isStrict, localeData) {
                      return isStrict && strictRegex ? strictRegex : regex;
                  };
        }

        function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return regexEscape(
                s
                    .replace('\\', '')
                    .replace(
                        /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                        function (matched, p1, p2, p3, p4) {
                            return p1 || p2 || p3 || p4;
                        }
                    )
            );
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
            var i,
                func = callback,
                tokenLen;
            if (typeof token === 'string') {
                token = [token];
            }
            if (isNumber(callback)) {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            tokenLen = token.length;
            for (i = 0; i < tokenLen; i++) {
                tokens[token[i]] = func;
            }
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }

        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
            return ((n % x) + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
        } else {
            indexOf = function (o) {
                // I know
                var i;
                for (i = 0; i < this.length; ++i) {
                    if (this[i] === o) {
                        return i;
                    }
                }
                return -1;
            };
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
                return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
                ? isLeapYear(year)
                    ? 29
                    : 28
                : 31 - ((modMonth % 7) % 2);
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });

        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });

        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
        });

        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });

        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });

        // LOCALES

        var defaultLocaleMonths =
                'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                    '_'
                ),
            defaultLocaleMonthsShort =
                'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
            if (!m) {
                return isArray(this._months)
                    ? this._months
                    : this._months['standalone'];
            }
            return isArray(this._months)
                ? this._months[m.month()]
                : this._months[
                      (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                          ? 'format'
                          : 'standalone'
                  ][m.month()];
        }

        function localeMonthsShort(m, format) {
            if (!m) {
                return isArray(this._monthsShort)
                    ? this._monthsShort
                    : this._monthsShort['standalone'];
            }
            return isArray(this._monthsShort)
                ? this._monthsShort[m.month()]
                : this._monthsShort[
                      MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                  ][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
            var i,
                ii,
                mom,
                llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
                // this is not used
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
                for (i = 0; i < 12; ++i) {
                    mom = createUTC([2000, i]);
                    this._shortMonthsParse[i] = this.monthsShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
                return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp(
                        '^' + this.months(mom, '').replace('.', '') + '$',
                        'i'
                    );
                    this._shortMonthsParse[i] = new RegExp(
                        '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                        'i'
                    );
                }
                if (!strict && !this._monthsParse[i]) {
                    regex =
                        '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'MMMM' &&
                    this._longMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'MMM' &&
                    this._shortMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
                // No op
                return mom;
            }

            if (typeof value === 'string') {
                if (/^\d+$/.test(value)) {
                    value = toInt(value);
                } else {
                    value = mom.localeData().monthsParse(value);
                    // TODO: Another silent failure?
                    if (!isNumber(value)) {
                        return mom;
                    }
                }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }

        function getSetMonth(value) {
            if (value != null) {
                setMonth(this, value);
                hooks.updateOffset(this, true);
                return this;
            } else {
                return get(this, 'Month');
            }
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsShortStrictRegex;
                } else {
                    return this._monthsShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsShortRegex')) {
                    this._monthsShortRegex = defaultMonthsShortRegex;
                }
                return this._monthsShortStrictRegex && isStrict
                    ? this._monthsShortStrictRegex
                    : this._monthsShortRegex;
            }
        }

        function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsStrictRegex;
                } else {
                    return this._monthsRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    this._monthsRegex = defaultMonthsRegex;
                }
                return this._monthsStrictRegex && isStrict
                    ? this._monthsStrictRegex
                    : this._monthsRegex;
            }
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom;
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                shortPieces.push(this.monthsShort(mom, ''));
                longPieces.push(this.months(mom, ''));
                mixedPieces.push(this.months(mom, ''));
                mixedPieces.push(this.monthsShort(mom, ''));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
                shortPieces[i] = regexEscape(shortPieces[i]);
                longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
                mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._monthsShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });

        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });

        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);

        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
            array[YEAR] =
                input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
            array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
            return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                date = new Date(y + 400, m, d, h, M, s, ms);
                if (isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
            } else {
                date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
        }

        function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                args = Array.prototype.slice.call(arguments);
                // preserve leap years using a full 400 year cycle, then reset
                args[0] = y + 400;
                date = new Date(Date.UTC.apply(null, args));
                if (isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
            } else {
                date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,
                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                resYear,
                resDayOfYear;

            if (dayOfYear <= 0) {
                resYear = year - 1;
                resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
                resYear = year + 1;
                resDayOfYear = dayOfYear - daysInYear(year);
            } else {
                resYear = year;
                resDayOfYear = dayOfYear;
            }

            return {
                year: resYear,
                dayOfYear: resDayOfYear,
            };
        }

        function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                resWeek,
                resYear;

            if (week < 1) {
                resYear = mom.year() - 1;
                resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                resWeek = week - weeksInYear(mom.year(), dow, doy);
                resYear = mom.year() + 1;
            } else {
                resYear = mom.year();
                resWeek = week;
            }

            return {
                week: resWeek,
                year: resYear,
            };
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);

        addWeekParseToken(
            ['w', 'ww', 'W', 'WW'],
            function (input, week, config, token) {
                week[token.substr(0, 1)] = toInt(input);
            }
        );

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
            return this._week.dow;
        }

        function localeFirstDayOfYear() {
            return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');

        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });

        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });

        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });

        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
        });

        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });

        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
            if (typeof input !== 'string') {
                return input;
            }

            if (!isNaN(input)) {
                return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === 'number') {
                return input;
            }

            return null;
        }

        function parseIsoWeekday(input, locale) {
            if (typeof input === 'string') {
                return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays =
                'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
                ? this._weekdays
                : this._weekdays[
                      m && m !== true && this._weekdays.isFormat.test(format)
                          ? 'format'
                          : 'standalone'
                  ];
            return m === true
                ? shiftWeekdays(weekdays, this._week.dow)
                : m
                ? weekdays[m.day()]
                : weekdays;
        }

        function localeWeekdaysShort(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                : m
                ? this._weekdaysShort[m.day()]
                : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                : m
                ? this._weekdaysMin[m.day()]
                : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i,
                ii,
                mom,
                llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._minWeekdaysParse = [];

                for (i = 0; i < 7; ++i) {
                    mom = createUTC([2000, 1]).day(i);
                    this._minWeekdaysParse[i] = this.weekdaysMin(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._shortWeekdaysParse[i] = this.weekdaysShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
                return handleStrictParse$1.call(this, weekdayName, format, strict);
            }

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._minWeekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already

                mom = createUTC([2000, 1]).day(i);
                if (strict && !this._fullWeekdaysParse[i]) {
                    this._fullWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._shortWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._minWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                }
                if (!this._weekdaysParse[i]) {
                    regex =
                        '^' +
                        this.weekdays(mom, '') +
                        '|^' +
                        this.weekdaysShort(mom, '') +
                        '|^' +
                        this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'dddd' &&
                    this._fullWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'ddd' &&
                    this._shortWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'dd' &&
                    this._minWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
                return this.day() || 7;
            }
        }

        function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysStrictRegex;
                } else {
                    return this._weekdaysRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    this._weekdaysRegex = defaultWeekdaysRegex;
                }
                return this._weekdaysStrictRegex && isStrict
                    ? this._weekdaysStrictRegex
                    : this._weekdaysRegex;
            }
        }

        function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysShortStrictRegex;
                } else {
                    return this._weekdaysShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                }
                return this._weekdaysShortStrictRegex && isStrict
                    ? this._weekdaysShortStrictRegex
                    : this._weekdaysShortRegex;
            }
        }

        function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysMinStrictRegex;
                } else {
                    return this._weekdaysMinRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                }
                return this._weekdaysMinStrictRegex && isStrict
                    ? this._weekdaysMinStrictRegex
                    : this._weekdaysMinRegex;
            }
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom,
                minp,
                shortp,
                longp;
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, 1]).day(i);
                minp = regexEscape(this.weekdaysMin(mom, ''));
                shortp = regexEscape(this.weekdaysShort(mom, ''));
                longp = regexEscape(this.weekdays(mom, ''));
                minPieces.push(minp);
                shortPieces.push(shortp);
                longPieces.push(longp);
                mixedPieces.push(minp);
                mixedPieces.push(shortp);
                mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._weekdaysShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
            this._weekdaysMinStrictRegex = new RegExp(
                '^(' + minPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        function hFormat() {
            return this.hours() % 12 || 12;
        }

        function kFormat() {
            return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);

        addFormatToken('hmm', 0, 0, function () {
            return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });

        addFormatToken('hmmss', 0, 0, function () {
            return (
                '' +
                hFormat.apply(this) +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        addFormatToken('Hmm', 0, 0, function () {
            return '' + this.hours() + zeroFill(this.minutes(), 2);
        });

        addFormatToken('Hmmss', 0, 0, function () {
            return (
                '' +
                this.hours() +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(
                    this.hours(),
                    this.minutes(),
                    lowercase
                );
            });
        }

        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);

        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);

        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }

        var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
        };

        // internal storage for locale config files
        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
            var i,
                minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
                if (arr1[i] !== arr2[i]) {
                    return i;
                }
            }
            return minl;
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0,
                j,
                next,
                locale,
                split;

            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (
                        next &&
                        next.length >= j &&
                        commonPrefix(split, next) >= j - 1
                    ) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return globalLocale;
        }

        function isLocaleNameSane(name) {
            // Prevent names that look like filesystem paths, i.e contain '/' or '\'
            return name.match('^[^/\\\\]*$') != null;
        }

        function loadLocale(name) {
            var oldLocale = null,
                aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
                locales[name] === undefined &&
                'object' !== 'undefined' &&
                module &&
                module.exports &&
                isLocaleNameSane(name)
            ) {
                try {
                    oldLocale = globalLocale._abbr;
                    aliasedRequire = commonjsRequire;
                    aliasedRequire('./locale/' + name);
                    getSetGlobalLocale(oldLocale);
                } catch (e) {
                    // mark as not found to avoid repeating expensive file require call causing high CPU
                    // when trying to find en-US, en_US, en-us for every format call
                    locales[name] = null; // null means not found
                }
            }
            return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
                if (isUndefined(values)) {
                    data = getLocale(key);
                } else {
                    data = defineLocale(key, values);
                }

                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                } else {
                    if (typeof console !== 'undefined' && console.warn) {
                        //warn user if arguments are passed but the locale could not be set
                        console.warn(
                            'Locale ' + key + ' not found. Did you forget to load it?'
                        );
                    }
                }
            }

            return globalLocale._abbr;
        }

        function defineLocale(name, config) {
            if (config !== null) {
                var locale,
                    parentConfig = baseConfig;
                config.abbr = name;
                if (locales[name] != null) {
                    deprecateSimple(
                        'defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                            'an existing locale. moment.defineLocale(localeName, ' +
                            'config) should only be used for creating a new locale ' +
                            'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                    );
                    parentConfig = locales[name]._config;
                } else if (config.parentLocale != null) {
                    if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                    } else {
                        locale = loadLocale(config.parentLocale);
                        if (locale != null) {
                            parentConfig = locale._config;
                        } else {
                            if (!localeFamilies[config.parentLocale]) {
                                localeFamilies[config.parentLocale] = [];
                            }
                            localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config,
                            });
                            return null;
                        }
                    }
                }
                locales[name] = new Locale(mergeConfigs(parentConfig, config));

                if (localeFamilies[name]) {
                    localeFamilies[name].forEach(function (x) {
                        defineLocale(x.name, x.config);
                    });
                }

                // backwards compat for now: also set the locale
                // make sure we set the locale AFTER all child locales have been
                // created, so we won't end up with the child locale set.
                getSetGlobalLocale(name);

                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }

        function updateLocale(name, config) {
            if (config != null) {
                var locale,
                    tmpLocale,
                    parentConfig = baseConfig;

                if (locales[name] != null && locales[name].parentLocale != null) {
                    // Update existing child locale in-place to avoid memory-leaks
                    locales[name].set(mergeConfigs(locales[name]._config, config));
                } else {
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    if (tmpLocale == null) {
                        // updateLocale is called for creating a new locale
                        // Set abbr so it will have a name (getters return
                        // undefined otherwise).
                        config.abbr = name;
                    }
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;
                }

                // backwards compat for now: also set the locale
                getSetGlobalLocale(name);
            } else {
                // pass null for config to unupdate, useful for tests
                if (locales[name] != null) {
                    if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) {
                            getSetGlobalLocale(name);
                        }
                    } else if (locales[name] != null) {
                        delete locales[name];
                    }
                }
            }
            return locales[name];
        }

        // returns locale data
        function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }

            if (!key) {
                return globalLocale;
            }

            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }

            return chooseLocale(key);
        }

        function listLocales() {
            return keys(locales);
        }

        function checkOverflow(m) {
            var overflow,
                a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH] < 0 || a[MONTH] > 11
                        ? MONTH
                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                        ? DATE
                        : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                        ? MINUTE
                        : a[SECOND] < 0 || a[SECOND] > 59
                        ? SECOND
                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                        ? MILLISECOND
                        : -1;

                if (
                    getParsingFlags(m)._overflowDayOfYear &&
                    (overflow < YEAR || overflow > DATE)
                ) {
                    overflow = DATE;
                }
                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                    overflow = WEEK;
                }
                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                    overflow = WEEKDAY;
                }

                getParsingFlags(m).overflow = overflow;
            }

            return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex =
                /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex =
                /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/],
                ['YYYYMM', /\d{6}/, false],
                ['YYYY', /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 =
                /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60,
            };

        // date from iso format
        function configFromISO(config) {
            var i,
                l,
                string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                allowTime,
                dateFormat,
                timeFormat,
                tzFormat,
                isoDatesLen = isoDates.length,
                isoTimesLen = isoTimes.length;

            if (match) {
                getParsingFlags(config).iso = true;
                for (i = 0, l = isoDatesLen; i < l; i++) {
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                    }
                }
                if (dateFormat == null) {
                    config._isValid = false;
                    return;
                }
                if (match[3]) {
                    for (i = 0, l = isoTimesLen; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                            // match[2] should be 'T' or space
                            timeFormat = (match[2] || ' ') + isoTimes[i][0];
                            break;
                        }
                    }
                    if (timeFormat == null) {
                        config._isValid = false;
                        return;
                    }
                }
                if (!allowTime && timeFormat != null) {
                    config._isValid = false;
                    return;
                }
                if (match[4]) {
                    if (tzRegex.exec(match[4])) {
                        tzFormat = 'Z';
                    } else {
                        config._isValid = false;
                        return;
                    }
                }
                config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }

        function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
        ) {
            var result = [
                untruncateYear(yearStr),
                defaultLocaleMonthsShort.indexOf(monthStr),
                parseInt(dayStr, 10),
                parseInt(hourStr, 10),
                parseInt(minuteStr, 10),
            ];

            if (secondStr) {
                result.push(parseInt(secondStr, 10));
            }

            return result;
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
                return 2000 + year;
            } else if (year <= 999) {
                return 1900 + year;
            }
            return year;
        }

        function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
                .replace(/\([^)]*\)|[\n\t]/g, ' ')
                .replace(/(\s\s+)/g, ' ')
                .replace(/^\s\s*/, '')
                .replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(
                        parsedInput[0],
                        parsedInput[1],
                        parsedInput[2]
                    ).getDay();
                if (weekdayProvided !== weekdayActual) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return false;
                }
            }
            return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
                return obsOffsets[obsOffset];
            } else if (militaryOffset) {
                // the only allowed military tz is Z
                return 0;
            } else {
                var hm = parseInt(numOffset, 10),
                    m = hm % 100,
                    h = (hm - m) / 100;
                return h * 60 + m;
            }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                parsedArray;
            if (match) {
                parsedArray = extractFromRFC2822Strings(
                    match[4],
                    match[3],
                    match[2],
                    match[5],
                    match[6],
                    match[7]
                );
                if (!checkWeekday(match[1], parsedArray, config)) {
                    return;
                }

                config._a = parsedArray;
                config._tzm = calculateOffset(match[8], match[9], match[10]);

                config._d = createUTCDate.apply(null, config._a);
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                getParsingFlags(config).rfc2822 = true;
            } else {
                config._isValid = false;
            }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }

            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            if (config._strict) {
                config._isValid = false;
            } else {
                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }
        }

        hooks.createFromInputFallback = deprecate(
            'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }

        function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
                return [
                    nowValue.getUTCFullYear(),
                    nowValue.getUTCMonth(),
                    nowValue.getUTCDate(),
                ];
            }
            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
            var i,
                date,
                input = [],
                currentDate,
                expectedWeekday,
                yearToUse;

            if (config._d) {
                return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                if (
                    config._dayOfYear > daysInYear(yearToUse) ||
                    config._dayOfYear === 0
                ) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }

                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] =
                    config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
                config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0
            ) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
                null,
                input
            );
            expectedWeekday = config._useUTC
                ? config._d.getUTCDay()
                : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
                config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
                config._w &&
                typeof config._w.d !== 'undefined' &&
                config._w.d !== expectedWeekday
            ) {
                getParsingFlags(config).weekdayMismatch = true;
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;

                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(
                    w.GG,
                    config._a[YEAR],
                    weekOfYear(createLocal(), 1, 4).year
                );
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
                if (weekday < 1 || weekday > 7) {
                    weekdayOverflow = true;
                }
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;

                curWeek = weekOfYear(createLocal(), dow, doy);

                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                // Default to current week.
                week = defaults(w.w, curWeek.week);

                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from beginning of week
                    weekday = w.e + dow;
                    if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                    }
                } else {
                    // default to beginning of week
                    weekday = dow;
                }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
                getParsingFlags(config)._overflowWeekday = true;
            } else {
                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear;
            }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
            if (config._f === hooks.RFC_2822) {
                configFromRFC2822(config);
                return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i,
                parsedInput,
                tokens,
                token,
                skipped,
                stringLength = string.length,
                totalParsedInputLength = 0,
                era,
                tokenLen;

            tokens =
                expandFormat(config._f, config._locale).match(formattingTokens) || [];
            tokenLen = tokens.length;
            for (i = 0; i < tokenLen; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                    [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(
                        string.indexOf(parsedInput) + parsedInput.length
                    );
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    } else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                } else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
                stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
                config._a[HOUR] <= 12 &&
                getParsingFlags(config).bigHour === true &&
                config._a[HOUR] > 0
            ) {
                getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
                config._locale,
                config._a[HOUR],
                config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
            }

            configFromArray(config);
            checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore,
                validFormatFound,
                bestFormatIsValid = false,
                configfLen = config._f.length;

            if (configfLen === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }

            for (i = 0; i < configfLen; i++) {
                currentScore = 0;
                validFormatFound = false;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);

                if (isValid(tempConfig)) {
                    validFormatFound = true;
                }

                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;

                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                getParsingFlags(tempConfig).score = currentScore;

                if (!bestFormatIsValid) {
                    if (
                        scoreToBeat == null ||
                        currentScore < scoreToBeat ||
                        validFormatFound
                    ) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                        if (validFormatFound) {
                            bestFormatIsValid = true;
                        }
                    }
                } else {
                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }
            }

            extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
            if (config._d) {
                return;
            }

            var i = normalizeObjectUnits(config._i),
                dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
                [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
                function (obj) {
                    return obj && parseInt(obj, 10);
                }
            );

            configFromArray(config);
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }

            return res;
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === '')) {
                return createInvalid({ nullInput: true });
            }

            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
                config._d = input;
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else {
                configFromInput(config);
            }

            if (!isValid(config)) {
                config._d = null;
            }

            return config;
        }

        function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
                config._d = new Date(hooks.now());
            } else if (isDate(input)) {
                config._d = new Date(input.valueOf());
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (isObject(input)) {
                configFromObject(config);
            } else if (isNumber(input)) {
                // from milliseconds
                config._d = new Date(input);
            } else {
                hooks.createFromInputFallback(config);
            }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
                strict = format;
                format = undefined;
            }

            if (locale === true || locale === false) {
                strict = locale;
                locale = undefined;
            }

            if (
                (isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)
            ) {
                input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            ),
            prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (!moments[i].isValid() || moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }

        // TODO: Use [].sort instead?
        function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isBefore', args);
        }

        function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isAfter', args);
        }

        var now = function () {
            return Date.now ? Date.now() : +new Date();
        };

        var ordering = [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
        ];

        function isDurationValid(m) {
            var key,
                unitHasDecimal = false,
                i,
                orderLen = ordering.length;
            for (key in m) {
                if (
                    hasOwnProp(m, key) &&
                    !(
                        indexOf.call(ordering, key) !== -1 &&
                        (m[key] == null || !isNaN(m[key]))
                    )
                ) {
                    return false;
                }
            }

            for (i = 0; i < orderLen; ++i) {
                if (m[ordering[i]]) {
                    if (unitHasDecimal) {
                        return false; // only allow non-integers for smallest unit
                    }
                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                    }
                }
            }

            return true;
        }

        function isValid$1() {
            return this._isValid;
        }

        function createInvalid$1() {
            return createDuration(NaN);
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
                +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
        }

        function isDuration(obj) {
            return obj instanceof Duration;
        }

        function absRound(number) {
            if (number < 0) {
                return Math.round(-1 * number) * -1;
            } else {
                return Math.round(number);
            }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if (
                    (dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
                ) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset(),
                    sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return (
                    sign +
                    zeroFill(~~(offset / 60), 2) +
                    separator +
                    zeroFill(~~offset % 60, 2)
                );
            });
        }

        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
            var matches = (string || '').match(matcher),
                chunk,
                parts,
                minutes;

            if (matches === null) {
                return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff =
                    (isMoment(input) || isDate(input)
                        ? input.valueOf()
                        : createLocal(input).valueOf()) - res.valueOf();
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(res._d.valueOf() + diff);
                hooks.updateOffset(res, false);
                return res;
            } else {
                return createLocal(input).local();
            }
        }

        function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
                localAdjust;
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(matchShortOffset, input);
                    if (input === null) {
                        return this;
                    }
                } else if (Math.abs(input) < 16 && !keepMinutes) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(
                            this,
                            createDuration(input - offset, 'm'),
                            1,
                            false
                        );
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }

        function getSetZone(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }

                this.utcOffset(input, keepLocalTime);

                return this;
            } else {
                return -this.utcOffset();
            }
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }

        function setOffsetToParsedOffset() {
            if (this._tzm != null) {
                this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === 'string') {
                var tZone = offsetFromString(matchOffset, this._i);
                if (tZone != null) {
                    this.utcOffset(tZone);
                } else {
                    this.utcOffset(0, true);
                }
            }
            return this;
        }

        function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
                return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
                return this._isDSTShifted;
            }

            var c = {},
                other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted =
                    this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
                this._isDSTShifted = false;
            }

            return this._isDSTShifted;
        }

        function isLocal() {
            return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex =
                /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;

            if (isDuration(input)) {
                duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months,
                };
            } else if (isNumber(input) || !isNaN(+input)) {
                duration = {};
                if (key) {
                    duration[key] = +input;
                } else {
                    duration.milliseconds = +input;
                }
            } else if ((match = aspNetRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
                };
            } else if ((match = isoRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign),
                };
            } else if (duration == null) {
                // checks for null or undefined
                duration = {};
            } else if (
                typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)
            ) {
                diffRes = momentsDifference(
                    createLocal(duration.from),
                    createLocal(duration.to)
                );

                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, '_isValid')) {
                ret._isValid = input._isValid;
            }

            return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
                other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, 'M');

            return res;
        }

        function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
                return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }

            return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(
                        name,
                        'moment().' +
                            name +
                            '(period, number) is deprecated. Please use moment().' +
                            name +
                            '(number, period). ' +
                            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                    );
                    tmp = val;
                    val = period;
                    period = tmp;
                }

                dur = createDuration(val, period);
                addSubtract(this, dur, direction);
                return this;
            };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);

            if (!mom.isValid()) {
                // No op
                return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
                setMonth(mom, get(mom, 'Month') + months * isAdding);
            }
            if (days) {
                set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
            }
            if (milliseconds) {
                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
                hooks.updateOffset(mom, days || months);
            }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
            return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
            return (
                isMoment(input) ||
                isDate(input) ||
                isString(input) ||
                isNumber(input) ||
                isNumberOrStringArray(input) ||
                isMomentInputObject(input) ||
                input === null ||
                input === undefined
            );
        }

        function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'years',
                    'year',
                    'y',
                    'months',
                    'month',
                    'M',
                    'days',
                    'day',
                    'd',
                    'dates',
                    'date',
                    'D',
                    'hours',
                    'hour',
                    'h',
                    'minutes',
                    'minute',
                    'm',
                    'seconds',
                    'second',
                    's',
                    'milliseconds',
                    'millisecond',
                    'ms',
                ],
                i,
                property,
                propertyLen = properties.length;

            for (i = 0; i < propertyLen; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
                dataTypeTest = false;
            if (arrayTest) {
                dataTypeTest =
                    input.filter(function (item) {
                        return !isNumber(item) && isString(input);
                    }).length === 0;
            }
            return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'sameDay',
                    'nextDay',
                    'lastDay',
                    'nextWeek',
                    'lastWeek',
                    'sameElse',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, 'days', true);
            return diff < -6
                ? 'sameElse'
                : diff < -1
                ? 'lastWeek'
                : diff < 0
                ? 'lastDay'
                : diff < 1
                ? 'sameDay'
                : diff < 2
                ? 'nextDay'
                : diff < 7
                ? 'nextWeek'
                : 'sameElse';
        }

        function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
                if (!arguments[0]) {
                    time = undefined;
                    formats = undefined;
                } else if (isMomentInput(arguments[0])) {
                    time = arguments[0];
                    formats = undefined;
                } else if (isCalendarSpec(arguments[0])) {
                    formats = arguments[0];
                    time = undefined;
                }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                format = hooks.calendarFormat(this, sod) || 'sameElse',
                output =
                    formats &&
                    (isFunction(formats[format])
                        ? formats[format].call(this, now)
                        : formats[format]);

            return this.format(
                output || this.localeData().calendar(format, this, createLocal(now))
            );
        }

        function clone() {
            return new Moment(this);
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() > localInput.valueOf();
            } else {
                return localInput.valueOf() < this.clone().startOf(units).valueOf();
            }
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() < localInput.valueOf();
            } else {
                return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
        }

        function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
                localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                return false;
            }
            inclusivity = inclusivity || '()';
            return (
                (inclusivity[0] === '('
                    ? this.isAfter(localFrom, units)
                    : !this.isBefore(localFrom, units)) &&
                (inclusivity[1] === ')'
                    ? this.isBefore(localTo, units)
                    : !this.isAfter(localTo, units))
            );
        }

        function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
                inputMs;
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() === localInput.valueOf();
            } else {
                inputMs = localInput.valueOf();
                return (
                    this.clone().startOf(units).valueOf() <= inputMs &&
                    inputMs <= this.clone().endOf(units).valueOf()
                );
            }
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
                return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
                return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
                case 'year':
                    output = monthDiff(this, that) / 12;
                    break;
                case 'month':
                    output = monthDiff(this, that);
                    break;
                case 'quarter':
                    output = monthDiff(this, that) / 3;
                    break;
                case 'second':
                    output = (this - that) / 1e3;
                    break; // 1000
                case 'minute':
                    output = (this - that) / 6e4;
                    break; // 1000 * 60
                case 'hour':
                    output = (this - that) / 36e5;
                    break; // 1000 * 60 * 60
                case 'day':
                    output = (this - that - zoneDelta) / 864e5;
                    break; // 1000 * 60 * 60 * 24, negate dst
                case 'week':
                    output = (this - that - zoneDelta) / 6048e5;
                    break; // 1000 * 60 * 60 * 24 * 7, negate dst
                default:
                    output = this - that;
            }

            return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
            if (a.date() < b.date()) {
                // end-of-month calculations work correct when the start month has more
                // days than the end month.
                return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2,
                adjust;

            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
            if (!this.isValid()) {
                return null;
            }
            var utc = keepOffset !== true,
                m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
                return formatMoment(
                    m,
                    utc
                        ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                        : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
                );
            }
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                if (utc) {
                    return this.toDate().toISOString();
                } else {
                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                        .toISOString()
                        .replace('Z', formatMoment(m, 'Z'));
                }
            }
            return formatMoment(
                m,
                utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
            if (!this.isValid()) {
                return 'moment.invalid(/* ' + this._i + ' */)';
            }
            var func = 'moment',
                zone = '',
                prefix,
                year,
                datetime,
                suffix;
            if (!this.isLocal()) {
                func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                zone = 'Z';
            }
            prefix = '[' + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
            datetime = '-MM-DD[T]HH:mm:ss.SSS';
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
            if (!inputString) {
                inputString = this.isUtc()
                    ? hooks.defaultFormatUtc
                    : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ to: this, from: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ from: this, to: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }

        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );

        function localeData() {
            return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return new Date(y, m, d).valueOf();
            }
        }

        function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return Date.UTC(y, m, d);
            }
        }

        function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year(), 0, 1);
                    break;
                case 'quarter':
                    time = startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3),
                        1
                    );
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month(), 1);
                    break;
                case 'week':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday()
                    );
                    break;
                case 'isoWeek':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1)
                    );
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date());
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time -= mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    );
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_MINUTE);
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_SECOND);
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                    break;
                case 'quarter':
                    time =
                        startOfDate(
                            this.year(),
                            this.month() - (this.month() % 3) + 3,
                            1
                        ) - 1;
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                    break;
                case 'week':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - this.weekday() + 7
                        ) - 1;
                    break;
                case 'isoWeek':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1) + 7
                        ) - 1;
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time +=
                        MS_PER_HOUR -
                        mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR
                        ) -
                        1;
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
            return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
            return new Date(this.valueOf());
        }

        function toArray() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hour(),
                m.minute(),
                m.second(),
                m.millisecond(),
            ];
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds(),
            };
        }

        function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
            return isValid(this);
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
            return getParsingFlags(this).overflow;
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict,
            };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');

        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);

        addParseToken(
            ['N', 'NN', 'NNN', 'NNNN', 'NNNNN'],
            function (input, array, config, token) {
                var era = config._locale.erasParse(input, token, config._strict);
                if (era) {
                    getParsingFlags(config).era = era;
                } else {
                    getParsingFlags(config).invalidEra = input;
                }
            }
        );

        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);

        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
                match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
                array[YEAR] = parseInt(input, 10);
            }
        });

        function localeEras(m, format) {
            var i,
                l,
                date,
                eras = this._eras || getLocale('en')._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
                switch (typeof eras[i].since) {
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].since).startOf('day');
                        eras[i].since = date.valueOf();
                        break;
                }

                switch (typeof eras[i].until) {
                    case 'undefined':
                        eras[i].until = +Infinity;
                        break;
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].until).startOf('day').valueOf();
                        eras[i].until = date.valueOf();
                        break;
                }
            }
            return eras;
        }

        function localeErasParse(eraName, format, strict) {
            var i,
                l,
                eras = this.eras(),
                name,
                abbr,
                narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
                name = eras[i].name.toUpperCase();
                abbr = eras[i].abbr.toUpperCase();
                narrow = eras[i].narrow.toUpperCase();

                if (strict) {
                    switch (format) {
                        case 'N':
                        case 'NN':
                        case 'NNN':
                            if (abbr === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNN':
                            if (name === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNNN':
                            if (narrow === eraName) {
                                return eras[i];
                            }
                            break;
                    }
                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                    return eras[i];
                }
            }
        }

        function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
                return hooks(era.since).year();
            } else {
                return hooks(era.since).year() + (year - era.offset) * dir;
            }
        }

        function getEraName() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].name;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].name;
                }
            }

            return '';
        }

        function getEraNarrow() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].narrow;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].narrow;
                }
            }

            return '';
        }

        function getEraAbbr() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].abbr;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].abbr;
                }
            }

            return '';
        }

        function getEraYear() {
            var i,
                l,
                dir,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                dir = eras[i].since <= eras[i].until ? +1 : -1;

                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (
                    (eras[i].since <= val && val <= eras[i].until) ||
                    (eras[i].until <= val && val <= eras[i].since)
                ) {
                    return (
                        (this.year() - hooks(eras[i].since).year()) * dir +
                        eras[i].offset
                    );
                }
            }

            return this.year();
        }

        function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNameRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, '_erasAbbrRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNarrowRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
            var abbrPieces = [],
                namePieces = [],
                narrowPieces = [],
                mixedPieces = [],
                i,
                l,
                eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
                namePieces.push(regexEscape(eras[i].name));
                abbrPieces.push(regexEscape(eras[i].abbr));
                narrowPieces.push(regexEscape(eras[i].narrow));

                mixedPieces.push(regexEscape(eras[i].name));
                mixedPieces.push(regexEscape(eras[i].abbr));
                mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
            this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
            this._erasNarrowRegex = new RegExp(
                '^(' + narrowPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });

        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);

        addWeekParseToken(
            ['gggg', 'ggggg', 'GGGG', 'GGGGG'],
            function (input, week, config, token) {
                week[token.substr(0, 2)] = toInt(input);
            }
        );

        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy
            );
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.isoWeek(),
                this.isoWeekday(),
                1,
                4
            );
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
                return weekOfYear(this, dow, doy).year;
            } else {
                weeksTarget = weeksInYear(input, dow, doy);
                if (week > weeksTarget) {
                    week = weeksTarget;
                }
                return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
            return input == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month((input - 1) * 3 + (this.month() % 3));
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
                ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                : locale._dayOfMonthOrdinalParseLenient;
        });

        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
            var dayOfYear =
                Math.round(
                    (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
                ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });

        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });

        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
            return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
            return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
            return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
            return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
            return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
            return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);

        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
            addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
            addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
            return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;

        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
            proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
                return 'Moment<' + this.format() + '>';
            };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
            'dates accessor is deprecated. Use date instead.',
            getSetDayOfMonth
        );
        proto.months = deprecate(
            'months accessor is deprecated. Use month instead',
            getSetMonth
        );
        proto.years = deprecate(
            'years accessor is deprecated. Use year instead',
            getSetYear
        );
        proto.zone = deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
            getSetZone
        );
        proto.isDSTShifted = deprecate(
            'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
            isDaylightSavingTimeShifted
        );

        function createUnix(input) {
            return createLocal(input * 1000);
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
            return string;
        }

        var proto$1 = Locale.prototype;

        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;

        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';

            if (index != null) {
                return get$1(format, index, field, 'month');
            }

            var i,
                out = [];
            for (i = 0; i < 12; i++) {
                out[i] = get$1(format, i, field, 'month');
            }
            return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === 'boolean') {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            } else {
                format = localeSorted;
                index = format;
                localeSorted = false;

                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            }

            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0,
                i,
                out = [];

            if (index != null) {
                return get$1(format, (index + shift) % 7, field, 'day');
            }

            for (i = 0; i < 7; i++) {
                out[i] = get$1(format, (i + shift) % 7, field, 'day');
            }
            return out;
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
            eras: [
                {
                    since: '0001-01-01',
                    until: +Infinity,
                    offset: 1,
                    name: 'Anno Domini',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: 'Before Christ',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        toInt((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        // Side effect imports

        hooks.lang = deprecate(
            'moment.lang is deprecated. Use moment.locale instead.',
            getSetGlobalLocale
        );
        hooks.langData = deprecate(
            'moment.langData is deprecated. Use moment.localeData instead.',
            getLocale
        );

        var mathAbs = Math.abs;

        function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
            if (number < 0) {
                return Math.floor(number);
            } else {
                return Math.ceil(number);
            }
        }

        function bubble() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds,
                minutes,
                hours,
                years,
                monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
                !(
                    (milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0)
                )
            ) {
                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                days = 0;
                months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
        }

        function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
        }

        function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
        }

        function as(units) {
            if (!this.isValid()) {
                return NaN;
            }
            var days,
                months,
                milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === 'month' || units === 'quarter' || units === 'year') {
                days = this._days + milliseconds / 864e5;
                months = this._months + daysToMonths(days);
                switch (units) {
                    case 'month':
                        return months;
                    case 'quarter':
                        return months / 3;
                    case 'year':
                        return months / 12;
                }
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(monthsToDays(this._months));
                switch (units) {
                    case 'week':
                        return days / 7 + milliseconds / 6048e5;
                    case 'day':
                        return days + milliseconds / 864e5;
                    case 'hour':
                        return days * 24 + milliseconds / 36e5;
                    case 'minute':
                        return days * 1440 + milliseconds / 6e4;
                    case 'second':
                        return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond':
                        return Math.floor(days * 864e5) + milliseconds;
                    default:
                        throw new Error('Unknown unit ' + units);
                }
            }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
            if (!this.isValid()) {
                return NaN;
            }
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }

        function makeAs(alias) {
            return function () {
                return this.as(alias);
            };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
            return createDuration(this);
        }

        function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
            return function () {
                return this.isValid() ? this._data[name] : NaN;
            };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
            return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
                ss: 44, // a few seconds to seconds
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month/week
                w: null, // weeks to month
                M: 11, // months to year
            };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as('s')),
                minutes = round(duration.as('m')),
                hours = round(duration.as('h')),
                days = round(duration.as('d')),
                months = round(duration.as('M')),
                weeks = round(duration.as('w')),
                years = round(duration.as('y')),
                a =
                    (seconds <= thresholds.ss && ['s', seconds]) ||
                    (seconds < thresholds.s && ['ss', seconds]) ||
                    (minutes <= 1 && ['m']) ||
                    (minutes < thresholds.m && ['mm', minutes]) ||
                    (hours <= 1 && ['h']) ||
                    (hours < thresholds.h && ['hh', hours]) ||
                    (days <= 1 && ['d']) ||
                    (days < thresholds.d && ['dd', days]);

            if (thresholds.w != null) {
                a =
                    a ||
                    (weeks <= 1 && ['w']) ||
                    (weeks < thresholds.w && ['ww', weeks]);
            }
            a = a ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
                return round;
            }
            if (typeof roundingFunction === 'function') {
                round = roundingFunction;
                return true;
            }
            return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === 's') {
                thresholds.ss = limit - 1;
            }
            return true;
        }

        function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var withSuffix = false,
                th = thresholds,
                locale,
                output;

            if (typeof argWithSuffix === 'object') {
                argThresholds = argWithSuffix;
                argWithSuffix = false;
            }
            if (typeof argWithSuffix === 'boolean') {
                withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === 'object') {
                th = Object.assign({}, thresholds, argThresholds);
                if (argThresholds.s != null && argThresholds.ss == null) {
                    th.ss = argThresholds.s - 1;
                }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
            return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
                days = abs$1(this._days),
                months = abs$1(this._months),
                minutes,
                hours,
                years,
                s,
                total = this.asSeconds(),
                totalSign,
                ymSign,
                daysSign,
                hmsSign;

            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

            totalSign = total < 0 ? '-' : '';
            ymSign = sign(this._months) !== sign(total) ? '-' : '';
            daysSign = sign(this._days) !== sign(total) ? '-' : '';
            hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

            return (
                totalSign +
                'P' +
                (years ? ymSign + years + 'Y' : '') +
                (months ? ymSign + months + 'M' : '') +
                (days ? daysSign + days + 'D' : '') +
                (hours || minutes || seconds ? 'T' : '') +
                (hours ? hmsSign + hours + 'H' : '') +
                (minutes ? hmsSign + minutes + 'M' : '') +
                (seconds ? hmsSign + s + 'S' : '')
            );
        }

        var proto$2 = Duration.prototype;

        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;

        proto$2.toIsoString = deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
            toISOString$1
        );
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.3';

        setHookCallback(createLocal);

        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
            DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
            DATE: 'YYYY-MM-DD', // <input type="date" />
            TIME: 'HH:mm', // <input type="time" />
            TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
            TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
            WEEK: 'GGGG-[W]WW', // <input type="week" />
            MONTH: 'YYYY-MM', // <input type="month" />
        };

        return hooks;

    })));
    }(moment$1));

    var moment = moment$1.exports;

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }

    // We need muted to start false because a muted video can
    // be autoplayed without user interacting with the dom
    const muted = writable(false);

    /* src/assets/Controls/VolumeHigh.svelte generated by Svelte v3.47.0 */

    const file$F = "src/assets/Controls/VolumeHigh.svelte";

    function create_fragment$M(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$F, 9, 2, 245);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$F, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VolumeHigh', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 25 25" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VolumeHigh> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class VolumeHigh extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$I, create_fragment$M, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VolumeHigh",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get size() {
    		throw new Error("<VolumeHigh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<VolumeHigh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<VolumeHigh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<VolumeHigh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VolumeHigh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VolumeHigh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<VolumeHigh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<VolumeHigh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<VolumeHigh>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<VolumeHigh>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/Controls/VolumeOff.svelte generated by Svelte v3.47.0 */

    const file$E = "src/assets/Controls/VolumeOff.svelte";

    function create_fragment$L(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12,4L9.91,6.09L12,8.18M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$E, 9, 2, 245);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$E, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VolumeOff', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 25 25" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VolumeOff> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class VolumeOff extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$H, create_fragment$L, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VolumeOff",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get size() {
    		throw new Error("<VolumeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<VolumeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<VolumeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<VolumeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VolumeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VolumeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<VolumeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<VolumeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<VolumeOff>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<VolumeOff>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/Controls/Replay.svelte generated by Svelte v3.47.0 */

    const file$D = "src/assets/Controls/Replay.svelte";

    function create_fragment$K(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			attr_dev(path0, "d", "M21.6311 7.14844L20.3213 8.4887L23.3311 11.5684L20.3213 14.648L21.6311 15.9883L25.9501 11.569L25.9494 11.5684L25.9501 11.5677L21.6311 7.14844Z");
    			attr_dev(path0, "fill", /*color*/ ctx[2]);
    			add_location(path0, file$D, 9, 2, 257);
    			attr_dev(path1, "d", "M10.0625 15.9883V11.5684H23.0213");
    			attr_dev(path1, "stroke", /*color*/ ctx[2]);
    			attr_dev(path1, "stroke-width", "2");
    			attr_dev(path1, "stroke-linecap", "square");
    			add_location(path1, file$D, 13, 2, 438);
    			attr_dev(path2, "d", "M13.3015 28.1445L14.6113 26.8043L11.6016 23.7246L14.6113 20.6449L13.3015 19.3047L8.98254 23.7239L8.9832 23.7246L8.98254 23.7253L13.3015 28.1445Z");
    			attr_dev(path2, "fill", /*color*/ ctx[2]);
    			add_location(path2, file$D, 19, 2, 560);
    			attr_dev(path3, "d", "M24.8701 19.3047V23.7246H11.9113");
    			attr_dev(path3, "stroke", /*color*/ ctx[2]);
    			attr_dev(path3, "stroke-width", "2");
    			attr_dev(path3, "stroke-linecap", "square");
    			add_location(path3, file$D, 23, 2, 743);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$D, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path0, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(path1, "stroke", /*color*/ ctx[2]);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(path2, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(path3, "stroke", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Replay', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "5 5 25 25" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Replay> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Replay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$G, create_fragment$K, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Replay",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get size() {
    		throw new Error("<Replay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Replay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Replay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Replay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Replay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Replay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Replay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Replay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Replay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Replay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/Controls/SkipNext.svelte generated by Svelte v3.47.0 */

    const file$C = "src/assets/Controls/SkipNext.svelte";

    function create_fragment$J(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12.3726 9.49033C12.5713 9.381 12.7944 9.33236 13.0173 9.34976C13.2402 9.36717 13.4543 9.44994 13.636 9.58898L20.2178 14.6125V10.6456C20.2178 10.3013 20.3458 9.97117 20.5737 9.72774C20.8015 9.4843 21.1105 9.34754 21.4327 9.34754C21.7548 9.34754 22.0638 9.4843 22.2917 9.72774C22.5195 9.97117 22.6475 10.3013 22.6475 10.6456V23.6262C22.6475 23.9705 22.5195 24.3007 22.2917 24.5441C22.0638 24.7875 21.7548 24.9243 21.4327 24.9243C21.1105 24.9243 20.8015 24.7875 20.5737 24.5441C20.3458 24.3007 20.2178 23.9705 20.2178 23.6262V19.6593L13.6336 24.6828C13.4519 24.821 13.2382 24.9031 13.0158 24.9202C12.7934 24.9372 12.5709 24.8885 12.3726 24.7793C12.1744 24.6702 12.0081 24.5049 11.892 24.3015C11.7758 24.0981 11.7143 23.8645 11.7142 23.6262V10.6456C11.714 10.407 11.7753 10.1729 11.8915 9.96909C12.0076 9.76528 12.1741 9.59962 12.3726 9.49033Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$C, 9, 2, 245);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$C, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SkipNext', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "5 5 25 25" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SkipNext> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class SkipNext extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$F, create_fragment$J, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SkipNext",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get size() {
    		throw new Error("<SkipNext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<SkipNext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<SkipNext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<SkipNext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<SkipNext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<SkipNext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<SkipNext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<SkipNext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<SkipNext>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<SkipNext>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Controls.svelte generated by Svelte v3.47.0 */
    const file$B = "src/components/Controls.svelte";

    function add_css$i(target) {
    	append_styles(target, "svelte-1vj2tif", "button.svelte-1vj2tif{border:none;background:none;cursor:pointer;display:flex;align-items:center;justify-content:center;color:rgb(var(--body));background-color:rgb(var(--background));border-radius:0.5em;height:2.7em;width:2.7em}button.svelte-1vj2tif:hover{color:rgb(var(--primary))}.mute.svelte-1vj2tif{color:rgb(var(--background));background-color:rgb(var(--primary))}.mute.svelte-1vj2tif:hover{color:rgb(var(--body))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udHJvbHMuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdDRSxNQUFNLGVBQUMsQ0FBQSxBQUNMLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLE9BQU8sQ0FDZixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLEtBQUssQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQ0FDdkIsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQ3hDLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLE1BQU0sQ0FBRSxLQUFLLENBQ2IsS0FBSyxDQUFFLEtBQUssQUFDZCxDQUFBLEFBRUEscUJBQU0sTUFBTSxBQUFDLENBQUEsQUFDWCxLQUFLLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEFBQzVCLENBQUEsQUFFQSxLQUFLLGVBQUMsQ0FBQSxBQUNKLEtBQUssQ0FBRSxJQUFJLElBQUksWUFBWSxDQUFDLENBQUMsQ0FDN0IsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEFBQ3ZDLENBQUEsQUFFQSxvQkFBSyxNQUFNLEFBQUMsQ0FBQSxBQUNWLEtBQUssQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQUFDekIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDb250cm9scy5zdmVsdGUiXX0= */");
    }

    // (23:2) {:else}
    function create_else_block$6(ctx) {
    	let volumeoff;
    	let current;

    	volumeoff = new VolumeOff({
    			props: { size: /*size*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(volumeoff.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(volumeoff, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const volumeoff_changes = {};
    			if (dirty & /*size*/ 1) volumeoff_changes.size = /*size*/ ctx[0];
    			volumeoff.$set(volumeoff_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(volumeoff.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(volumeoff.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(volumeoff, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(23:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:2) {#if !$muted}
    function create_if_block$g(ctx) {
    	let volumehigh;
    	let current;

    	volumehigh = new VolumeHigh({
    			props: { size: /*size*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(volumehigh.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(volumehigh, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const volumehigh_changes = {};
    			if (dirty & /*size*/ 1) volumehigh_changes.size = /*size*/ ctx[0];
    			volumehigh.$set(volumehigh_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(volumehigh.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(volumehigh.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(volumehigh, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(21:2) {#if !$muted}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let button0;
    	let replay;
    	let t0;
    	let button1;
    	let current_block_type_index;
    	let if_block;
    	let t1;
    	let button2;
    	let skipnext;
    	let current;
    	let mounted;
    	let dispose;

    	replay = new Replay({
    			props: { size: /*size*/ ctx[0] },
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$g, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*$muted*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	skipnext = new SkipNext({
    			props: { size: /*size*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			create_component(replay.$$.fragment);
    			t0 = space();
    			button1 = element("button");
    			if_block.c();
    			t1 = space();
    			button2 = element("button");
    			create_component(skipnext.$$.fragment);
    			attr_dev(button0, "class", "svelte-1vj2tif");
    			add_location(button0, file$B, 10, 0, 415);
    			attr_dev(button1, "class", "mute svelte-1vj2tif");
    			add_location(button1, file$B, 14, 0, 491);
    			attr_dev(button2, "class", "svelte-1vj2tif");
    			add_location(button2, file$B, 27, 0, 659);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			mount_component(replay, button0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button1, anchor);
    			if_blocks[current_block_type_index].m(button1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button2, anchor);
    			mount_component(skipnext, button2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[4], false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const replay_changes = {};
    			if (dirty & /*size*/ 1) replay_changes.size = /*size*/ ctx[0];
    			replay.$set(replay_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(button1, null);
    			}

    			const skipnext_changes = {};
    			if (dirty & /*size*/ 1) skipnext_changes.size = /*size*/ ctx[0];
    			skipnext.$set(skipnext_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(replay.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(skipnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(replay.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(skipnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			destroy_component(replay);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button1);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button2);
    			destroy_component(skipnext);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let $muted;
    	validate_store(muted, 'muted');
    	component_subscribe($$self, muted, $$value => $$invalidate(1, $muted = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Controls', slots, []);
    	let { size } = $$props;
    	const dispatch = createEventDispatcher();
    	const writable_props = ['size'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Controls> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => dispatch("replay");

    	const click_handler_1 = () => {
    		set_store_value(muted, $muted = !$muted, $muted);
    	};

    	const click_handler_2 = () => dispatch("skip");

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		muted,
    		VolumeHigh,
    		VolumeOff,
    		Replay,
    		SkipNext,
    		size,
    		dispatch,
    		$muted
    	});

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(0, size = $$props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [size, $muted, dispatch, click_handler, click_handler_1, click_handler_2];
    }

    class Controls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$E, create_fragment$I, safe_not_equal, { size: 0 }, add_css$i);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Controls",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*size*/ ctx[0] === undefined && !('size' in props)) {
    			console.warn("<Controls> was created without expected prop 'size'");
    		}
    	}

    	get size() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const theme_store = writable();

    const timerShouldReset = writable(false);
    const timerShouldBeHidden = writable(false);

    /* src/components/CircularTimer.svelte generated by Svelte v3.47.0 */
    const file$A = "src/components/CircularTimer.svelte";

    function add_css$h(target) {
    	append_styles(target, "svelte-eagm1b", "p.svelte-eagm1b{z-index:1;background:rgb(var(--primary-dimmed));color:rgb(var(--body));height:100%;width:100%;border-radius:50%;display:flex;align-items:center;justify-content:center}.pie-pressure.svelte-eagm1b{display:flex;align-items:center;justify-content:center;width:25px;height:25px;margin:auto;position:relative;background-clip:padding-box;border-radius:50%;border:solid 3px transparent}.pie-pressure.svelte-eagm1b::before{z-index:0;content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;margin:-3px;border-radius:inherit;background:repeating-conic-gradient(\n      rgba(var(--background), 0.3) 0deg,\n      rgba(var(--background), 0.3) 7.5deg,\n      #ffffff00 7.5deg,\n      #ffffff00 15deg\n    )}.pie-pressure.svelte-eagm1b:after{z-index:0;content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;margin:-3px;border-radius:inherit;background:var(--gradient)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2lyY3VsYXJUaW1lci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUVFLENBQUMsY0FBQyxDQUFBLEFBQ0EsT0FBTyxDQUFFLENBQUMsQ0FDVixVQUFVLENBQUUsSUFBSSxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FDdEMsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixNQUFNLENBQUUsSUFBSSxDQUNaLEtBQUssQ0FBRSxJQUFJLENBQ1gsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxBQUN6QixDQUFBLEFBRUEsYUFBYSxjQUFDLENBQUEsQUFDWixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLElBQUksQ0FDWixNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLGVBQWUsQ0FBRSxXQUFXLENBQzVCLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE1BQU0sQ0FBRSxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsQUFDL0IsQ0FBQSxBQUVBLDJCQUFhLFFBQVEsQUFBQyxDQUFBLEFBQ3BCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsT0FBTyxDQUFFLEVBQUUsQ0FDWCxRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsQ0FBQyxDQUNOLEtBQUssQ0FBRSxDQUFDLENBQ1IsTUFBTSxDQUFFLENBQUMsQ0FDVCxJQUFJLENBQUUsQ0FBQyxDQUNQLE1BQU0sQ0FBRSxJQUFJLENBQ1osYUFBYSxDQUFFLE9BQU8sQ0FDdEIsVUFBVSxDQUFFO01BQ1YsS0FBSyxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFBO01BQ2pDLEtBQUssSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQTtNQUNuQyxTQUFTLENBQUMsTUFBTSxDQUFBO01BQ2hCLFNBQVMsQ0FBQyxLQUFBO0tBQ1gsQUFDSCxDQUFBLEFBRUEsMkJBQWEsTUFBTSxBQUFDLENBQUEsQUFDbEIsT0FBTyxDQUFFLENBQUMsQ0FDVixPQUFPLENBQUUsRUFBRSxDQUNYLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxDQUFDLENBQ04sS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsQ0FBQyxDQUNULElBQUksQ0FBRSxDQUFDLENBQ1AsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsT0FBTyxDQUN0QixVQUFVLENBQUUsSUFBSSxVQUFVLENBQUMsQUFDN0IsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJDaXJjdWxhclRpbWVyLnN2ZWx0ZSJdfQ== */");
    }

    function create_fragment$H(ctx) {
    	let div;
    	let p;
    	let t_value = /*timeLeft*/ ctx[0].toFixed(0) + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "svelte-eagm1b");
    			add_location(p, file$A, 42, 2, 1511);
    			attr_dev(div, "class", "pie-pressure svelte-eagm1b");
    			attr_dev(div, "style", /*style*/ ctx[1]);
    			add_location(div, file$A, 41, 0, 1474);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*timeLeft*/ 1 && t_value !== (t_value = /*timeLeft*/ ctx[0].toFixed(0) + "")) set_data_dev(t, t_value);

    			if (dirty & /*style*/ 2) {
    				attr_dev(div, "style", /*style*/ ctx[1]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const TotalTime = 15;
    const AboutToEndTreshold = 5;

    function instance$D($$self, $$props, $$invalidate) {
    	let $timerShouldReset;
    	let $theme_store;
    	validate_store(timerShouldReset, 'timerShouldReset');
    	component_subscribe($$self, timerShouldReset, $$value => $$invalidate(3, $timerShouldReset = $$value));
    	validate_store(theme_store, 'theme_store');
    	component_subscribe($$self, theme_store, $$value => $$invalidate(5, $theme_store = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CircularTimer', slots, []);
    	let { isAboutToEnd = false } = $$props;
    	const dispatch = createEventDispatcher();
    	const IntervalStep = 1 / 60;

    	const background = $theme_store.background
    	? $theme_store.background.replaceAll(" ", "").split(",").map(Number)
    	: [0, 0, 0];

    	const red = [255, 0, 0];
    	let timeLeft = TotalTime;
    	let style = "";
    	let interval;

    	interval = setInterval(
    		() => {
    			$$invalidate(0, timeLeft = Math.max(timeLeft - IntervalStep, 0));

    			if (timeLeft === 0) {
    				clearInterval(interval);
    				interval = null;
    			}

    			const elapsedTimePerrcentage = Math.min(1, 2.5 * timeLeft / TotalTime);
    			let color = [];

    			for (let i = 0; i < 3; i++) {
    				color.push(elapsedTimePerrcentage * background[i] + (1 - elapsedTimePerrcentage) * red[i]);
    			}

    			$$invalidate(1, style = `--gradient: conic-gradient(
            rgb(${color.join(",")}) ${timeLeft * (100 / TotalTime)}%,
            rgba(var(--body), 0) ${timeLeft * (100 / TotalTime)}%,
            rgba(var(--body),0 )
        );
`);
    		},
    		IntervalStep * 1000
    	);

    	const writable_props = ['isAboutToEnd'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CircularTimer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('isAboutToEnd' in $$props) $$invalidate(2, isAboutToEnd = $$props.isAboutToEnd);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		theme_store,
    		timerShouldReset,
    		isAboutToEnd,
    		dispatch,
    		TotalTime,
    		IntervalStep,
    		AboutToEndTreshold,
    		background,
    		red,
    		timeLeft,
    		style,
    		interval,
    		$timerShouldReset,
    		$theme_store
    	});

    	$$self.$inject_state = $$props => {
    		if ('isAboutToEnd' in $$props) $$invalidate(2, isAboutToEnd = $$props.isAboutToEnd);
    		if ('timeLeft' in $$props) $$invalidate(0, timeLeft = $$props.timeLeft);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('interval' in $$props) interval = $$props.interval;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$timerShouldReset*/ 8) {
    			// reset to initial seconds if timerShouldReset is true
    			$timerShouldReset && ($$invalidate(0, timeLeft = TotalTime), set_store_value(timerShouldReset, $timerShouldReset = false, $timerShouldReset));
    		}

    		if ($$self.$$.dirty & /*timeLeft*/ 1) {
    			!timeLeft && dispatch("timerEnded");
    		}

    		if ($$self.$$.dirty & /*timeLeft*/ 1) {
    			$$invalidate(2, isAboutToEnd = timeLeft < AboutToEndTreshold);
    		}
    	};

    	return [timeLeft, style, isAboutToEnd, $timerShouldReset];
    }

    class CircularTimer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$D, create_fragment$H, safe_not_equal, { isAboutToEnd: 2 }, add_css$h);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CircularTimer",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get isAboutToEnd() {
    		throw new Error("<CircularTimer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isAboutToEnd(value) {
    		throw new Error("<CircularTimer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const initial_chat_store = [];
    const private_chat_store = writable(initial_chat_store);
    const chat_store = derived(private_chat_store, (x) => x);

    const suggestionsShouldCollapse = writable(false);

    const chatScrollDown = writable(false);

    const defaults$1 = {
        org_id: "cm8",
        head_id: "alana",
        theme: "light",
        language: undefined,
        api_base: "https://soccomm.aflr.io",
        font: "Nunito",
        vm_version: 1,
        time_pressure: true,
    };
    const body_data = writable(defaults$1);
    /**
     * Updates the store values only if they exist in the type
     *
     * @param data - data coming from the body html tag
     */
    const load_body_data = (data) => {
        const new_store = defaults$1;
        for (let idx = 0; idx < Object.keys(data).length; idx++) {
            const key = Object.keys(data)[idx];
            const value = data[key];
            if (Object.prototype.hasOwnProperty.call(new_store, key)) {
                new_store[key] = value;
            }
        }
        // sorry whoever is reading this, i don't know why "1" or "true" are not being
        // converted to boolean
        new_store.time_pressure =
            data?.time_pressure === "1" || data?.time_pressure === "true";
        body_data.set(new_store);
    };

    const MESSAGE_FILE_URL_TEMPLATE = "./lang/{locale}.json";
    const setupI18n = async (_locale = "en-US") => {
        const messsagesFileUrl = MESSAGE_FILE_URL_TEMPLATE.replace("{locale}", _locale);
        let messages;
        try {
            const response = await fetch(messsagesFileUrl);
            messages = (await response.json());
            // for some reason, in the compiled version a "Not Found" error does not throw, so we check manually
            if (messages?.detail === "Not Found") {
                throw new Error("");
            }
            s.set({ [_locale]: messages });
            await D.set(_locale);
        }
        catch (err) {
            console.error(`Language ${_locale} not supported`);
            await setupI18n(); // Default
        }
    };
    // Readable store to tell us when locale is ready
    const isLocaleLoaded = derived(D, ($locale) => typeof $locale === "string");

    /* src/components/SuggestionContainer.svelte generated by Svelte v3.47.0 */
    const file$z = "src/components/SuggestionContainer.svelte";

    function add_css$g(target) {
    	append_styles(target, "svelte-134gduz", ".suggestion-container.svelte-134gduz.svelte-134gduz{display:inline-flex;flex-direction:column;flex-shrink:0;display:block;border-radius:0.7em 0.7em 0px 0px;margin:1em 1em -1.25em 1em;padding-bottom:0.5em;position:relative;width:calc(100% - 2em);background-color:rgba(var(--body), 0.6);box-shadow:0 4px 20px 0 rgba(var(--shadow), 0.2);top:0px;transition:all 0.2s ease-in-out}.suggestions-hidden.svelte-134gduz.svelte-134gduz{margin-bottom:-2em}.suggestion.svelte-134gduz.svelte-134gduz{display:flex;flex-direction:row;align-items:center;justify-content:space-between;font-size:medium;color:rgb(var(--background));text-align:center;padding:0.3em;scroll-snap-align:center;margin:0.2em 1em;border-bottom:1px solid rgb(var(--background))}.suggestion.svelte-134gduz>p.svelte-134gduz{min-width:1em}.suggestion-title-container.svelte-134gduz.svelte-134gduz{color:rgb(var(--body));background-color:rgb(var(--primary));font-size:small;border-radius:0.7em 0.7em 0 0;height:3em;display:grid;grid-template-columns:30% 40% 30%;padding:0 10%}.suggestion-title.svelte-134gduz.svelte-134gduz{align-self:center;text-transform:uppercase;text-align:center;font-size:smaller;font-weight:bold;transition:all 0.2s ease-in-out}.align-top.svelte-134gduz.svelte-134gduz{margin-top:-1.1em}.past-selected.svelte-134gduz.svelte-134gduz{color:rgb(var(--primary));background-color:rgba(var(--primary), 0.1)}.suggestion.selectable.svelte-134gduz.svelte-134gduz:hover{color:rgb(var(--primary));cursor:pointer}.blinking.svelte-134gduz.svelte-134gduz{animation:svelte-134gduz-blinking 3s ease-in infinite;border-radius:1em;padding:0 0.5em}@keyframes svelte-134gduz-blinking{0%{background-color:rgb(var(--primary));color:rgb(var(--body))}50%{color:rgb(var(--background))}100%{color:rgb(var(--background))}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3VnZ2VzdGlvbkNvbnRhaW5lci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBb0hFLHFCQUFxQiw4QkFBQyxDQUFBLEFBQ3BCLE9BQU8sQ0FBRSxXQUFXLENBQ3BCLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLFdBQVcsQ0FBRSxDQUFDLENBQ2QsT0FBTyxDQUFFLEtBQUssQ0FDZCxhQUFhLENBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUNsQyxNQUFNLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUMzQixjQUFjLENBQUUsS0FBSyxDQUNyQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN2QixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDeEMsVUFBVSxDQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDakQsR0FBRyxDQUFFLEdBQUcsQ0FDUixVQUFVLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEFBQ2xDLENBQUEsQUFFQSxtQkFBbUIsOEJBQUMsQ0FBQSxBQUNsQixhQUFhLENBQUUsSUFBSSxBQUNyQixDQUFBLEFBRUEsV0FBVyw4QkFBQyxDQUFBLEFBQ1YsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsR0FBRyxDQUNuQixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsYUFBYSxDQUM5QixTQUFTLENBQUUsTUFBTSxDQUNqQixLQUFLLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQzdCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsaUJBQWlCLENBQUUsTUFBTSxDQUN6QixNQUFNLENBQUUsS0FBSyxDQUFDLEdBQUcsQ0FDakIsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLEFBQ2pELENBQUEsQUFFQSwwQkFBVyxDQUFHLENBQUMsZUFBQyxDQUFBLEFBQ2QsU0FBUyxDQUFFLEdBQUcsQUFDaEIsQ0FBQSxBQUVBLDJCQUEyQiw4QkFBQyxDQUFBLEFBQzFCLEtBQUssQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQ0FDdkIsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQ3JDLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLGFBQWEsQ0FBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQzlCLE1BQU0sQ0FBRSxHQUFHLENBQ1gsT0FBTyxDQUFFLElBQUksQ0FDYixxQkFBcUIsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FDbEMsT0FBTyxDQUFFLENBQUMsQ0FBQyxHQUFHLEFBQ2hCLENBQUEsQUFFQSxpQkFBaUIsOEJBQUMsQ0FBQSxBQUNoQixVQUFVLENBQUUsTUFBTSxDQUNsQixjQUFjLENBQUUsU0FBUyxDQUN6QixVQUFVLENBQUUsTUFBTSxDQUNsQixTQUFTLENBQUUsT0FBTyxDQUNsQixXQUFXLENBQUUsSUFBSSxDQUNqQixVQUFVLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEFBQ2xDLENBQUEsQUFFQSxVQUFVLDhCQUFDLENBQUEsQUFDVCxVQUFVLENBQUUsTUFBTSxBQUNwQixDQUFBLEFBRUEsY0FBYyw4QkFBQyxDQUFBLEFBQ2IsS0FBSyxDQUFFLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUMxQixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDN0MsQ0FBQSxBQUVBLFdBQVcseUNBQVcsTUFBTSxBQUFDLENBQUEsQUFDM0IsS0FBSyxDQUFFLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUMxQixNQUFNLENBQUUsT0FBTyxBQUNqQixDQUFBLEFBRUEsU0FBUyw4QkFBQyxDQUFBLEFBQ1IsU0FBUyxDQUFFLHVCQUFRLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQ3ZDLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxDQUFDLENBQUMsS0FBSyxBQUNsQixDQUFBLEFBRUEsV0FBVyx1QkFBUyxDQUFBLEFBQ2xCLEVBQUUsQUFBQyxDQUFBLEFBQ0QsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQ3JDLEtBQUssQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQUFDekIsQ0FBQSxBQUNBLEdBQUcsQUFBQyxDQUFBLEFBQ0YsS0FBSyxDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxBQUMvQixDQUFBLEFBQ0EsSUFBSSxBQUFDLENBQUEsQUFDSCxLQUFLLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLEFBQy9CLENBQUEsQUFDRixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlN1Z2dlc3Rpb25Db250YWluZXIuc3ZlbHRlIl19 */");
    }

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	child_ctx[28] = i;
    	return child_ctx;
    }

    // (58:4) {:else}
    function create_else_block_1$2(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "width", "35px");
    			set_style(div, "height", "10px");
    			add_location(div, file$z, 58, 6, 2173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(58:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:4) {#if suggestionsExist && $body_data.time_pressure && !$timerShouldBeHidden}
    function create_if_block_3$4(ctx) {
    	let circulartimer;
    	let updating_isAboutToEnd;
    	let current;

    	function circulartimer_isAboutToEnd_binding(value) {
    		/*circulartimer_isAboutToEnd_binding*/ ctx[14](value);
    	}

    	let circulartimer_props = {};

    	if (/*isAboutToEnd*/ ctx[3] !== void 0) {
    		circulartimer_props.isAboutToEnd = /*isAboutToEnd*/ ctx[3];
    	}

    	circulartimer = new CircularTimer({
    			props: circulartimer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(circulartimer, 'isAboutToEnd', circulartimer_isAboutToEnd_binding));
    	circulartimer.$on("timerEnded", /*timerEnded_handler*/ ctx[15]);

    	const block = {
    		c: function create() {
    			create_component(circulartimer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(circulartimer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const circulartimer_changes = {};

    			if (!updating_isAboutToEnd && dirty & /*isAboutToEnd*/ 8) {
    				updating_isAboutToEnd = true;
    				circulartimer_changes.isAboutToEnd = /*isAboutToEnd*/ ctx[3];
    				add_flush_callback(() => updating_isAboutToEnd = false);
    			}

    			circulartimer.$set(circulartimer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(circulartimer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(circulartimer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(circulartimer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(53:4) {#if suggestionsExist && $body_data.time_pressure && !$timerShouldBeHidden}",
    		ctx
    	});

    	return block;
    }

    // (66:2) {#if currentSuggestions}
    function create_if_block$f(ctx) {
    	let each_1_anchor;
    	let each_value = /*currentSuggestions*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentSuggestions, $chatScrollDown, optionSelected, elementToColorRef, suggestionToChoseIdx, suggestionsHidden*/ 3349) {
    				each_value = /*currentSuggestions*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(66:2) {#if currentSuggestions}",
    		ctx
    	});

    	return block;
    }

    // (68:6) {#if option?.text && !suggestionsHidden}
    function create_if_block_1$8(ctx) {
    	let div;
    	let p0;
    	let t0_value = /*idx*/ ctx[28] + 1 + "";
    	let t0;
    	let t1;
    	let t2;
    	let p1;
    	let t3;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*idx*/ ctx[28] === /*suggestionToChoseIdx*/ ctx[10]) return create_if_block_2$5;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	function click_handler() {
    		return /*click_handler*/ ctx[21](/*option*/ ctx[26]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			p1 = element("p");
    			t3 = space();
    			attr_dev(p0, "class", "svelte-134gduz");
    			add_location(p0, file$z, 78, 10, 2953);
    			attr_dev(p1, "class", "svelte-134gduz");
    			add_location(p1, file$z, 88, 10, 3211);
    			attr_dev(div, "class", "suggestion selectable svelte-134gduz");
    			toggle_class(div, "past-selected", /*option*/ ctx[26].selected);
    			add_location(div, file$z, 68, 8, 2533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, t0);
    			append_dev(div, t1);
    			if_block.m(div, null);
    			append_dev(div, t2);
    			append_dev(div, p1);
    			append_dev(div, t3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "introstart", /*introstart_handler*/ ctx[17], false, false, false),
    					listen_dev(div, "outrostart", /*outrostart_handler*/ ctx[18], false, false, false),
    					listen_dev(div, "introend", /*introend_handler*/ ctx[19], false, false, false),
    					listen_dev(div, "outroend", /*outroend_handler*/ ctx[20], false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if_block.p(ctx, dirty);

    			if (dirty & /*currentSuggestions*/ 1) {
    				toggle_class(div, "past-selected", /*option*/ ctx[26].selected);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, {}, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(68:6) {#if option?.text && !suggestionsHidden}",
    		ctx
    	});

    	return block;
    }

    // (84:10) {:else}
    function create_else_block$5(ctx) {
    	let p;
    	let t_value = /*option*/ ctx[26].text + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "svelte-134gduz");
    			add_location(p, file$z, 84, 12, 3136);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentSuggestions*/ 1 && t_value !== (t_value = /*option*/ ctx[26].text + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(84:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (80:10) {#if idx === suggestionToChoseIdx}
    function create_if_block_2$5(ctx) {
    	let p;
    	let t_value = /*option*/ ctx[26].text + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "svelte-134gduz");
    			add_location(p, file$z, 80, 12, 3027);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    			/*p_binding*/ ctx[16](p);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentSuggestions*/ 1 && t_value !== (t_value = /*option*/ ctx[26].text + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			/*p_binding*/ ctx[16](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(80:10) {#if idx === suggestionToChoseIdx}",
    		ctx
    	});

    	return block;
    }

    // (67:4) {#each currentSuggestions as option, idx}
    function create_each_block$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*option*/ ctx[26]?.text && !/*suggestionsHidden*/ ctx[4] && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*option*/ ctx[26]?.text && !/*suggestionsHidden*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*currentSuggestions, suggestionsHidden*/ 17) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(67:4) {#each currentSuggestions as option, idx}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div3;
    	let div2;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let div0;
    	let t1_value = /*$_*/ ctx[7]("chat-component.suggestions.title") + "";
    	let t1;
    	let t2;
    	let div1;
    	let t3;
    	let div3_class_value;
    	let current;
    	const if_block_creators = [create_if_block_3$4, create_else_block_1$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*suggestionsExist*/ ctx[1] && /*$body_data*/ ctx[5].time_pressure && !/*$timerShouldBeHidden*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*currentSuggestions*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "suggestion-title svelte-134gduz");
    			toggle_class(div0, "align-top", /*suggestionsHidden*/ ctx[4]);
    			add_location(div0, file$z, 60, 4, 2227);
    			set_style(div1, "width", "35px");
    			set_style(div1, "height", "10px");
    			add_location(div1, file$z, 63, 4, 2356);
    			attr_dev(div2, "class", "suggestion-title-container svelte-134gduz");
    			add_location(div2, file$z, 51, 2, 1898);
    			attr_dev(div3, "class", div3_class_value = "" + (null_to_empty(`suggestion-container ${/*suggestionsHidden*/ ctx[4] ? "suggestions-hidden" : ""}`) + " svelte-134gduz"));
    			add_location(div3, file$z, 46, 0, 1799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			append_dev(div0, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div3, t3);
    			if (if_block1) if_block1.m(div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div2, t0);
    			}

    			if ((!current || dirty & /*$_*/ 128) && t1_value !== (t1_value = /*$_*/ ctx[7]("chat-component.suggestions.title") + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*suggestionsHidden*/ 16) {
    				toggle_class(div0, "align-top", /*suggestionsHidden*/ ctx[4]);
    			}

    			if (/*currentSuggestions*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$f(ctx);
    					if_block1.c();
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*suggestionsHidden*/ 16 && div3_class_value !== (div3_class_value = "" + (null_to_empty(`suggestion-container ${/*suggestionsHidden*/ ctx[4] ? "suggestions-hidden" : ""}`) + " svelte-134gduz"))) {
    				attr_dev(div3, "class", div3_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let suggestionsHidden;
    	let $suggestionsShouldCollapse;
    	let $chat_store;
    	let $body_data;
    	let $timerShouldBeHidden;
    	let $_;
    	let $chatScrollDown;
    	validate_store(suggestionsShouldCollapse, 'suggestionsShouldCollapse');
    	component_subscribe($$self, suggestionsShouldCollapse, $$value => $$invalidate(12, $suggestionsShouldCollapse = $$value));
    	validate_store(chat_store, 'chat_store');
    	component_subscribe($$self, chat_store, $$value => $$invalidate(13, $chat_store = $$value));
    	validate_store(body_data, 'body_data');
    	component_subscribe($$self, body_data, $$value => $$invalidate(5, $body_data = $$value));
    	validate_store(timerShouldBeHidden, 'timerShouldBeHidden');
    	component_subscribe($$self, timerShouldBeHidden, $$value => $$invalidate(6, $timerShouldBeHidden = $$value));
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(7, $_ = $$value));
    	validate_store(chatScrollDown, 'chatScrollDown');
    	component_subscribe($$self, chatScrollDown, $$value => $$invalidate(8, $chatScrollDown = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SuggestionContainer', slots, []);
    	const dispatch = createEventDispatcher();

    	// We need placeholder so we have a smooth animation when the first real suggestion comes
    	const placeholderSuggestion = {
    		next: "default",
    		text: "default",
    		skip: false,
    		selected: false
    	};

    	let { currentSuggestions = Array(3).fill(placeholderSuggestion) } = $$props;
    	let hiddenByUser = false;
    	let lastHook;
    	let suggestionsExist;

    	// We need to manually set/remove classes so animations can trigger twice
    	let elementToColorRef;

    	// we get this from the timer
    	let isAboutToEnd;

    	// If no user interaction, and the time runs out, this is the index of
    	// the suggestion option that will be selected
    	let suggestionToChoseIdx = 0;

    	const handlelastSuggestionBox = () => {
    		lastHook = $chat_store[$chat_store.length - 1];
    		$$invalidate(1, suggestionsExist = lastHook?.type === "suggestions");
    		suggestionsExist && (set_store_value(suggestionsShouldCollapse, $suggestionsShouldCollapse = false, $suggestionsShouldCollapse), $$invalidate(0, currentSuggestions = lastHook.hook.inputs));
    	};

    	const optionSelected = option => {
    		dispatch("optionSelected", option);
    	};

    	const writable_props = ['currentSuggestions'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SuggestionContainer> was created with unknown prop '${key}'`);
    	});

    	function circulartimer_isAboutToEnd_binding(value) {
    		isAboutToEnd = value;
    		$$invalidate(3, isAboutToEnd);
    	}

    	const timerEnded_handler = () => dispatch("optionSelected", currentSuggestions[0]);

    	function p_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			elementToColorRef = $$value;
    			$$invalidate(2, elementToColorRef);
    		});
    	}

    	const introstart_handler = () => set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	const outrostart_handler = () => set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	const introend_handler = () => set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	const outroend_handler = () => set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	const click_handler = option => optionSelected(option);

    	$$self.$$set = $$props => {
    		if ('currentSuggestions' in $$props) $$invalidate(0, currentSuggestions = $$props.currentSuggestions);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		slide,
    		CircularTimer,
    		chat_store,
    		suggestionsShouldCollapse,
    		chatScrollDown,
    		body_data,
    		timerShouldBeHidden,
    		_: Y,
    		dispatch,
    		placeholderSuggestion,
    		currentSuggestions,
    		hiddenByUser,
    		lastHook,
    		suggestionsExist,
    		elementToColorRef,
    		isAboutToEnd,
    		suggestionToChoseIdx,
    		handlelastSuggestionBox,
    		optionSelected,
    		suggestionsHidden,
    		$suggestionsShouldCollapse,
    		$chat_store,
    		$body_data,
    		$timerShouldBeHidden,
    		$_,
    		$chatScrollDown
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentSuggestions' in $$props) $$invalidate(0, currentSuggestions = $$props.currentSuggestions);
    		if ('hiddenByUser' in $$props) $$invalidate(24, hiddenByUser = $$props.hiddenByUser);
    		if ('lastHook' in $$props) lastHook = $$props.lastHook;
    		if ('suggestionsExist' in $$props) $$invalidate(1, suggestionsExist = $$props.suggestionsExist);
    		if ('elementToColorRef' in $$props) $$invalidate(2, elementToColorRef = $$props.elementToColorRef);
    		if ('isAboutToEnd' in $$props) $$invalidate(3, isAboutToEnd = $$props.isAboutToEnd);
    		if ('suggestionToChoseIdx' in $$props) $$invalidate(10, suggestionToChoseIdx = $$props.suggestionToChoseIdx);
    		if ('suggestionsHidden' in $$props) $$invalidate(4, suggestionsHidden = $$props.suggestionsHidden);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$chat_store*/ 8192) {
    			(handlelastSuggestionBox());
    		}

    		if ($$self.$$.dirty & /*suggestionsExist, $suggestionsShouldCollapse*/ 4098) {
    			$$invalidate(4, suggestionsHidden = !suggestionsExist || hiddenByUser || $suggestionsShouldCollapse);
    		}

    		if ($$self.$$.dirty & /*isAboutToEnd, elementToColorRef*/ 12) {
    			isAboutToEnd
    			? elementToColorRef?.classList.add("blinking")
    			: elementToColorRef?.classList.remove("blinking");
    		}
    	};

    	return [
    		currentSuggestions,
    		suggestionsExist,
    		elementToColorRef,
    		isAboutToEnd,
    		suggestionsHidden,
    		$body_data,
    		$timerShouldBeHidden,
    		$_,
    		$chatScrollDown,
    		dispatch,
    		suggestionToChoseIdx,
    		optionSelected,
    		$suggestionsShouldCollapse,
    		$chat_store,
    		circulartimer_isAboutToEnd_binding,
    		timerEnded_handler,
    		p_binding,
    		introstart_handler,
    		outrostart_handler,
    		introend_handler,
    		outroend_handler,
    		click_handler
    	];
    }

    class SuggestionContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$C, create_fragment$G, safe_not_equal, { currentSuggestions: 0 }, add_css$g);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SuggestionContainer",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get currentSuggestions() {
    		throw new Error("<SuggestionContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentSuggestions(value) {
    		throw new Error("<SuggestionContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const user_input_value = writable("");

    const backendWriting = writable(false);

    const disableChatInput = writable(false);

    var strictUriEncode = function (str) {
    	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
    	});
    };
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };



    function encoderForArrayFormat(opts) {
    	switch (opts.arrayFormat) {
    		case 'index':
    			return function (key, value, index) {
    				return value === null ? [
    					encode(key, opts),
    					'[',
    					index,
    					']'
    				].join('') : [
    					encode(key, opts),
    					'[',
    					encode(index, opts),
    					']=',
    					encode(value, opts)
    				].join('');
    			};

    		case 'bracket':
    			return function (key, value) {
    				return value === null ? encode(key, opts) : [
    					encode(key, opts),
    					'[]=',
    					encode(value, opts)
    				].join('');
    			};

    		default:
    			return function (key, value) {
    				return value === null ? encode(key, opts) : [
    					encode(key, opts),
    					'=',
    					encode(value, opts)
    				].join('');
    			};
    	}
    }

    function parserForArrayFormat(opts) {
    	var result;

    	switch (opts.arrayFormat) {
    		case 'index':
    			return function (key, value, accumulator) {
    				result = /\[(\d*)\]$/.exec(key);

    				key = key.replace(/\[\d*\]$/, '');

    				if (!result) {
    					accumulator[key] = value;
    					return;
    				}

    				if (accumulator[key] === undefined) {
    					accumulator[key] = {};
    				}

    				accumulator[key][result[1]] = value;
    			};

    		case 'bracket':
    			return function (key, value, accumulator) {
    				result = /(\[\])$/.exec(key);

    				key = key.replace(/\[\]$/, '');

    				if (!result || accumulator[key] === undefined) {
    					accumulator[key] = value;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};

    		default:
    			return function (key, value, accumulator) {
    				if (accumulator[key] === undefined) {
    					accumulator[key] = value;
    					return;
    				}

    				accumulator[key] = [].concat(accumulator[key], value);
    			};
    	}
    }

    function encode(value, opts) {
    	if (opts.encode) {
    		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
    	}

    	return value;
    }

    function keysSorter(input) {
    	if (Array.isArray(input)) {
    		return input.sort();
    	} else if (typeof input === 'object') {
    		return keysSorter(Object.keys(input)).sort(function (a, b) {
    			return Number(a) - Number(b);
    		}).map(function (key) {
    			return input[key];
    		});
    	}

    	return input;
    }

    var extract = function (str) {
    	return str.split('?')[1] || '';
    };

    var parse = function (str, opts) {
    	opts = objectAssign({arrayFormat: 'none'}, opts);

    	var formatter = parserForArrayFormat(opts);

    	// Create an object with no prototype
    	// https://github.com/sindresorhus/query-string/issues/47
    	var ret = Object.create(null);

    	if (typeof str !== 'string') {
    		return ret;
    	}

    	str = str.trim().replace(/^(\?|#|&)/, '');

    	if (!str) {
    		return ret;
    	}

    	str.split('&').forEach(function (param) {
    		var parts = param.replace(/\+/g, ' ').split('=');
    		// Firefox (pre 40) decodes `%3D` to `=`
    		// https://github.com/sindresorhus/query-string/pull/37
    		var key = parts.shift();
    		var val = parts.length > 0 ? parts.join('=') : undefined;

    		// missing `=` should be `null`:
    		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    		val = val === undefined ? null : decodeURIComponent(val);

    		formatter(decodeURIComponent(key), val, ret);
    	});

    	return Object.keys(ret).sort().reduce(function (result, key) {
    		var val = ret[key];
    		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
    			// Sort object keys, not values
    			result[key] = keysSorter(val);
    		} else {
    			result[key] = val;
    		}

    		return result;
    	}, Object.create(null));
    };

    var stringify$2 = function (obj, opts) {
    	var defaults = {
    		encode: true,
    		strict: true,
    		arrayFormat: 'none'
    	};

    	opts = objectAssign(defaults, opts);

    	var formatter = encoderForArrayFormat(opts);

    	return obj ? Object.keys(obj).sort().map(function (key) {
    		var val = obj[key];

    		if (val === undefined) {
    			return '';
    		}

    		if (val === null) {
    			return encode(key, opts);
    		}

    		if (Array.isArray(val)) {
    			var result = [];

    			val.slice().forEach(function (val2) {
    				if (val2 === undefined) {
    					return;
    				}

    				result.push(formatter(key, val2, result.length));
    			});

    			return result.join('&');
    		}

    		return encode(key, opts) + '=' + encode(val, opts);
    	}).filter(function (x) {
    		return x.length > 0;
    	}).join('&') : '';
    };

    var queryString = {
    	extract: extract,
    	parse: parse,
    	stringify: stringify$2
    };

    function basicObjectMap() {
    	var obj = Object.create(null);
    	return {
    		get: function(key) {
    			return obj[key]
    		},
    		set: function(key, value) {
    			obj[key] = value;
    		},
    		has: function(key) {
    			return Object.prototype.hasOwnProperty.call(obj, key)
    		},
    		delete: function(key) {
    			delete obj[key];
    		},
    		object: obj
    	}
    }

    var keyMaster = function(factory, inputMap) {
    	var map = inputMap || basicObjectMap();

    	function has(key) {
    		return map.has(key)
    	}

    	function get(key) {
    		if (!map.has(key) && typeof factory === 'function') {
    			map.set(key, factory(key));
    		}

    		return map.get(key)
    	}

    	function remove(key) {
    		map.delete(key);
    	}

    	function set(key, value) {
    		map.set(key, value);
    	}

    	function getUnderlyingDataStructure() {
    		return inputMap || map.object
    	}

    	return {
    		has: has,
    		get: get,
    		remove: remove,
    		delete: remove,
    		unset: remove,
    		set: set,
    		put: set,
    		add: set,
    		getUnderlyingDataStructure: getUnderlyingDataStructure,
    	}
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



    var getPropertyValuesInOrder = function getPropertyValuesInOrder(o) {
    	return Object.getOwnPropertyNames(o).map(function (key) {
    		return o[key];
    	});
    };
    var assertType = function assertType(name, value, expectedType) {
    	var actualType = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    	if (actualType !== expectedType) {
    		throw new Error('Expected ' + name + ' to be ' + expectedType + ' but it was ' + actualType);
    	}
    };

    var build = function createEmitter() {
    	var emitter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.create(null);

    	var eventsToListeners = keyMaster(function () {
    		return Object.create(null);
    	});

    	emitter.on = function (event, listener) {
    		assertType('event', event, 'string');
    		assertType('listener', listener, 'function');

    		var id = Math.random().toString();
    		var listeners = eventsToListeners.get(event);
    		listeners[id] = listener;

    		return function () {
    			delete listeners[id];
    		};
    	};

    	emitter.once = function (event, listener) {
    		assertType('event', event, 'string');
    		assertType('listener', listener, 'function');

    		var unsubscribe = emitter.on(event, function () {
    			listener.apply(undefined, arguments);
    			unsubscribe();
    		});

    		return unsubscribe;
    	};

    	emitter.emit = function (event) {
    		for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    			args[_key - 1] = arguments[_key];
    		}

    		assertType('event', event, 'string');

    		var listeners = eventsToListeners.get(event);
    		getPropertyValuesInOrder(listeners).forEach(function (listener) {
    			return listener.apply(undefined, args);
    		});
    	};

    	return emitter;
    };

    var callHistoryMethod = function callHistoryMethod(method) {
    	for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    		args[_key - 1] = arguments[_key];
    	}

    	return method.apply(window.history, args);
    };

    function setUpListener(cb) {
    	var originalPushState = window.history.pushState;
    	var originalReplaceState = window.history.replaceState;

    	window.history.replaceState = function () {
    		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    			args[_key2] = arguments[_key2];
    		}

    		callHistoryMethod.apply(undefined, [originalReplaceState].concat(args));
    		cb();
    	};

    	window.history.pushState = function () {
    		for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    			args[_key3] = arguments[_key3];
    		}

    		callHistoryMethod.apply(undefined, [originalPushState].concat(args));
    		cb();
    	};
    }

    function noop() {}

    function assign$3(tar, src) {
    	for (var k in src) tar[k] = src[k];
    	return tar;
    }

    function appendNode(node, target) {
    	target.appendChild(node);
    }

    function insertNode(node, target, anchor) {
    	target.insertBefore(node, anchor);
    }

    function detachNode(node) {
    	node.parentNode.removeChild(node);
    }

    function reinsertChildren(parent, target) {
    	while (parent.firstChild) target.appendChild(parent.firstChild);
    }

    function createElement(name) {
    	return document.createElement(name);
    }

    function createComment() {
    	return document.createComment('');
    }

    function addListener(node, event, handler) {
    	node.addEventListener(event, handler, false);
    }

    function removeListener(node, event, handler) {
    	node.removeEventListener(event, handler, false);
    }

    function blankObject() {
    	return Object.create(null);
    }

    function destroy(detach) {
    	this.destroy = noop;
    	this.fire('destroy');
    	this.set = noop;

    	this._fragment.d(detach !== false);
    	this._fragment = null;
    	this._state = {};
    }

    function _differs(a, b) {
    	return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }

    function fire(eventName, data) {
    	var handlers =
    		eventName in this._handlers && this._handlers[eventName].slice();
    	if (!handlers) return;

    	for (var i = 0; i < handlers.length; i += 1) {
    		var handler = handlers[i];

    		if (!handler.__calling) {
    			handler.__calling = true;
    			handler.call(this, data);
    			handler.__calling = false;
    		}
    	}
    }

    function get() {
    	return this._state;
    }

    function init$1(component, options) {
    	component._handlers = blankObject();
    	component._bind = options._bind;

    	component.options = options;
    	component.root = options.root || component;
    	component.store = options.store || component.root.store;
    }

    function on(eventName, handler) {
    	var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
    	handlers.push(handler);

    	return {
    		cancel: function() {
    			var index = handlers.indexOf(handler);
    			if (~index) handlers.splice(index, 1);
    		}
    	};
    }

    function set(newState) {
    	this._set(assign$3({}, newState));
    	if (this.root._lock) return;
    	this.root._lock = true;
    	callAll(this.root._beforecreate);
    	callAll(this.root._oncreate);
    	callAll(this.root._aftercreate);
    	this.root._lock = false;
    }

    function _set(newState) {
    	var oldState = this._state,
    		changed = {},
    		dirty = false;

    	for (var key in newState) {
    		if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
    	}
    	if (!dirty) return;

    	this._state = assign$3(assign$3({}, oldState), newState);
    	this._recompute(changed, this._state);
    	if (this._bind) this._bind(changed, this._state);

    	if (this._fragment) {
    		this.fire("state", { changed: changed, current: this._state, previous: oldState });
    		this._fragment.p(changed, this._state);
    		this.fire("update", { changed: changed, current: this._state, previous: oldState });
    	}
    }

    function callAll(fns) {
    	while (fns && fns.length) fns.shift()();
    }

    function _mount(target, anchor) {
    	this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
    }

    var proto = {
    	destroy,
    	get,
    	fire,
    	on,
    	set,
    	_recompute: noop,
    	_set,
    	_mount,
    	_differs
    };

    function eventIsModifiedByKeyPress(event) {
    	return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
    }
    function isLeftClick(event){
    	return event.button === 0
    }

    var clickShouldBeInterceptedForNavigation = function shouldIntercept(event) {
    	return !event.defaultPrevented
    		&& !eventIsModifiedByKeyPress(event)
    		&& isLeftClick(event)
    };

    /* Link.html generated by Svelte v2.9.1 */
    function querystring(_ref) {
    	var parametersToQuerystring = _ref.parametersToQuerystring,
    	    parameters = _ref.parameters;

    	return parametersToQuerystring(parameters);
    }

    function hash(_ref2) {
    	var anchor = _ref2.anchor;

    	return anchor ? '#' + anchor : '';
    }

    function data() {
    	return {
    		className: '',
    		style: '',
    		meta: null,
    		anchor: ''
    	};
    }

    var methods = {
    	onClick: function onClick(event) {
    		if (clickShouldBeInterceptedForNavigation(event)) {
    			event.preventDefault();

    			var _get = this.get(),
    			    _querystring = _get.querystring,
    			    parameters = _get.parameters,
    			    meta = _get.meta,
    			    _hash = _get.hash;

    			this.fire('navigate', {
    				querystring: _querystring,
    				parameters: parameters,
    				meta: meta,
    				hash: _hash
    			});
    		}
    	}
    };

    function create_main_fragment(component, ctx) {
    	var if_block_anchor;

    	function select_block_type(ctx) {
    		if (ctx.parameters) return create_if_block$e;
    		return create_if_block_1$7;
    	}

    	var current_block_type = select_block_type(ctx);
    	var if_block = current_block_type(component, ctx);

    	return {
    		c: function c() {
    			if_block.c();
    			if_block_anchor = createComment();
    		},
    		m: function m(target, anchor) {
    			if_block.m(target, anchor);
    			insertNode(if_block_anchor, target, anchor);
    		},
    		p: function p(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(component, ctx);
    				if_block.c();
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		d: function d(detach) {
    			if_block.d(detach);
    			if (detach) {
    				detachNode(if_block_anchor);
    			}
    		}
    	};
    }

    // (1:0) {#if parameters}
    function create_if_block$e(component, ctx) {
    	var a,
    	    slot_content_default = component._slotted.default,
    	    a_href_value;

    	function click_handler(event) {
    		component.onClick(event);
    	}

    	return {
    		c: function c() {
    			a = createElement("a");
    			addListener(a, "click", click_handler);
    			a.href = a_href_value = "" + ctx.querystring + ctx.hash;
    			a.className = ctx.className;
    			a.style.cssText = ctx.style;
    		},
    		m: function m(target, anchor) {
    			insertNode(a, target, anchor);

    			if (slot_content_default) {
    				appendNode(slot_content_default, a);
    			}

    			component.refs.link = a;
    		},
    		p: function p(changed, ctx) {
    			if ((changed.querystring || changed.hash) && a_href_value !== (a_href_value = "" + ctx.querystring + ctx.hash)) {
    				a.href = a_href_value;
    			}

    			if (changed.className) {
    				a.className = ctx.className;
    			}

    			if (changed.style) {
    				a.style.cssText = ctx.style;
    			}
    		},
    		d: function d(detach) {
    			if (detach) {
    				detachNode(a);
    			}

    			if (slot_content_default) {
    				reinsertChildren(a, slot_content_default);
    			}

    			removeListener(a, "click", click_handler);
    			if (component.refs.link === a) component.refs.link = null;
    		}
    	};
    }

    // (11:0) {:else}
    function create_if_block_1$7(component, ctx) {
    	var a,
    	    slot_content_default = component._slotted.default;

    	return {
    		c: function c() {
    			a = createElement("a");
    			a.className = ctx.className;
    			a.style.cssText = ctx.style;
    		},
    		m: function m(target, anchor) {
    			insertNode(a, target, anchor);

    			if (slot_content_default) {
    				appendNode(slot_content_default, a);
    			}
    		},
    		p: function p(changed, ctx) {
    			if (changed.className) {
    				a.className = ctx.className;
    			}

    			if (changed.style) {
    				a.style.cssText = ctx.style;
    			}
    		},
    		d: function d(detach) {
    			if (detach) {
    				detachNode(a);
    			}

    			if (slot_content_default) {
    				reinsertChildren(a, slot_content_default);
    			}
    		}
    	};
    }

    function Link(options) {
    	init$1(this, options);
    	this.refs = {};
    	this._state = assign$3(data(), options.data);
    	this._recompute({ parametersToQuerystring: 1, parameters: 1, anchor: 1 }, this._state);
    	this._intro = true;

    	this._slotted = options.slots || {};

    	this.slots = {};

    	this._fragment = create_main_fragment(this, this._state);

    	if (options.target) {
    		this._fragment.c();
    		this._mount(options.target, options.anchor);
    	}
    }

    assign$3(Link.prototype, proto);
    assign$3(Link.prototype, methods);

    Link.prototype._recompute = function _recompute(changed, state) {
    	if (changed.parametersToQuerystring || changed.parameters) {
    		if (this._differs(state.querystring, state.querystring = querystring(state))) changed.querystring = true;
    	}

    	if (changed.anchor) {
    		if (this._differs(state.hash, state.hash = hash(state))) changed.hash = true;
    	}
    };

    function defaultReplaceState(state, title, url) {
    	history.replaceState(state, title, url);
    }

    function defaultPushState(state, title, url) {
    	history.pushState(state, title, url);
    }

    function defaultCurrentQuerystring() {
    	var querystring = location.search;

    	return {
    		querystring: querystring,
    		parameters: queryString.parse(querystring)
    	};
    }

    function defaultOnPopState(listener) {
    	window.addEventListener('popstate', listener);
    }

    function parametersToQuerystring(parameters) {
    	return '?' + queryString.stringify(parameters);
    }

    function optionsWithAugmentedData(options) {
    	return Object.assign({}, options, {
    		data: Object.assign({}, options.data, { parametersToQuerystring: parametersToQuerystring })
    	});
    }

    var stripOctothorpe = function stripOctothorpe(str) {
    	return str.replace(/^#/, '');
    };
    var stripQuestionMark = function stripQuestionMark(str) {
    	return str.replace(/^\?/, '');
    };
    var currentAnchor = function currentAnchor() {
    	return stripOctothorpe(window.location.hash);
    };
    var scrollToElement = function scrollToElement(element) {
    	return element && element.scrollIntoView();
    };
    var getElementById = function getElementById(id) {
    	return id && document.getElementById(id);
    };

    function createRouterInstance() {
    	var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    	var _Object$assign = Object.assign({
    		pushState: defaultPushState,
    		replaceState: defaultReplaceState,
    		currentQuerystring: defaultCurrentQuerystring,
    		onPopState: defaultOnPopState,
    		onPushOrReplaceState: setUpListener
    	}, options),
    	    pushState = _Object$assign.pushState,
    	    replaceState = _Object$assign.replaceState,
    	    currentQuerystring = _Object$assign.currentQuerystring,
    	    onPopState = _Object$assign.onPopState,
    	    onPushOrReplaceState = _Object$assign.onPushOrReplaceState;

    	var emitter = build();

    	var navigating = false;
    	var handleExternalNavigation = function handleExternalNavigation() {
    		if (!navigating) {
    			var _currentQuerystring = currentQuerystring(),
    			    querystring = _currentQuerystring.querystring,
    			    parameters = _currentQuerystring.parameters;

    			emitter.emit('navigate', { querystring: querystring, parameters: parameters });
    		}
    	};

    	onPopState(handleExternalNavigation);
    	onPushOrReplaceState(handleExternalNavigation);

    	function navigate(_ref) {
    		var querystring = _ref.querystring,
    		    parameters = _ref.parameters,
    		    element = _ref.element,
    		    meta = _ref.meta,
    		    replace = _ref.replace,
    		    _ref$hash = _ref.hash,
    		    hash = _ref$hash === undefined ? '' : _ref$hash;

    		if (typeof querystring === 'undefined') {
    			querystring = parametersToQuerystring(parameters);
    		}

    		function emit(event) {
    			emitter.emit(event, {
    				querystring: querystring,
    				parameters: parameters,
    				meta: meta,
    				element: element,
    				hash: hash
    			});
    		}

    		var navigateFunction = replace ? replaceState : pushState;

    		emit('before navigate');

    		emit('navigate');

    		navigating = true;

    		var _currentQuerystring2 = currentQuerystring(),
    		    startQuerystring = _currentQuerystring2.querystring;

    		var startAnchor = currentAnchor();
    		if (stripQuestionMark(startQuerystring) !== stripQuestionMark(querystring)) {
    			navigateFunction(parameters, '', querystring + hash);
    		} else if (stripOctothorpe(hash) !== currentAnchor()) {
    			pushState(parameters, '', hash);
    		}

    		if (currentAnchor() !== startAnchor) {
    			scrollToElement(getElementById(stripOctothorpe(hash)));
    		}
    		navigating = false;

    		emit('after navigate');
    	}

    	return {
    		navigate: navigate,
    		Link: function linkProxy(options) {
    			var linkComponent = new Link(optionsWithAugmentedData(options));

    			linkComponent.on('navigate', function (_ref2) {
    				var querystring = _ref2.querystring,
    				    parameters = _ref2.parameters,
    				    meta = _ref2.meta,
    				    hash = _ref2.hash;

    				navigate({
    					querystring: querystring,
    					parameters: parameters,
    					meta: meta,
    					element: linkComponent.refs.link,
    					hash: hash
    				});
    			});

    			return linkComponent;
    		},
    		attachQuerystringData: function attachQuerystringData(component) {
    			var removeListener = emitter.on('navigate', function (_ref3) {
    				var parameters = _ref3.parameters;

    				component.set({
    					querystringParameters: parameters
    				});
    			});
    			component.on('destroy', removeListener);
    			component.set({
    				querystringParameters: currentQuerystring().parameters
    			});
    		},
    		on: function on(event, listener) {
    			return emitter.on(event, listener);
    		},
    		once: function once(event, listener) {
    			return emitter.once(event, listener);
    		},
    		getCurrentQuerystring: function getCurrentQuerystring() {
    			return currentQuerystring().querystring;
    		},
    		getCurrentParameters: function getCurrentParameters() {
    			return currentQuerystring().parameters;
    		}
    	};
    }

    var createInstanceBundle = createRouterInstance;

    const createInstance = createInstanceBundle;

    var browserEntryPoint = createInstance();

    const currentParams = 
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    browserEntryPoint.getCurrentParameters();
    const query_string_store = writable(currentParams);
    // we update the config store if we have any of this query parameters present
    const priorityParams = ["org_id", "head_id", "embed"];
    priorityParams.forEach((param) => {
        const value = currentParams[param];
        if (value) {
            body_data.set({ ...get_store_value(body_data), [param]: value });
        }
    });
    query_string_store.subscribe(() => {
        const new_url_params = new URLSearchParams();
        Object.entries(currentParams).forEach(([k, v]) => {
            return new_url_params.append(k, v);
        });
        const text_params = new_url_params.toString();
        if (text_params.length > 0)
            history.pushState({}, "", `?${text_params}`);
    });

    const privateIsFullScreen = writable(false);
    const privateIsHorizontalScreen = writable(false);
    const isEmbedded = writable(false);
    const isFullScreen = derived([privateIsFullScreen, isEmbedded], () => get_store_value(privateIsFullScreen) || get_store_value(isEmbedded));
    derived([isFullScreen, privateIsHorizontalScreen], () => get_store_value(privateIsHorizontalScreen) && !get_store_value(isFullScreen));
    const toggleFullScreen = () => {
        privateIsFullScreen.set(!get_store_value(privateIsFullScreen));
    };
    /**
     * Sets isEmbed to true if the parameter is passed via
     * DOMStringMap or query string parameter
     *
     * @param data Data coming from the html tag
     */
    const checkIfIsEmbed = (data) => {
        isEmbedded.set(data?.embed === "1" ||
            data?.embed === "true" ||
            get_store_value(query_string_store).embed);
    };

    const queryParameters = get_store_value(query_string_store);
    const bodyData = get_store_value(body_data);
    const org_id = queryParameters.org_id ?? bodyData.org_id;
    const head_id = queryParameters.head_id ?? bodyData.head_id;

    const storage = window.localStorage;
    const location$1 = window.location.origin + window.location.pathname;
    const prefix = `chat:${location$1}:${org_id}:${head_id}:`;
    const getFromStorage = (key) => {
        if (typeof storage !== "undefined") {
            const retval = storage.getItem(`${prefix}${key}`);
            return retval;
        }
    };
    const setToStorage = (key, val) => {
        if (typeof storage !== "undefined") {
            storage.setItem(`${prefix}${key}`, val);
            return;
        }
    };

    const error$2 = writable("");

    const API_ENDPOINT$1 = get_store_value(body_data).api_base;
    const TOKEN_ENDPOINT = API_ENDPOINT$1 + "/token";
    const getToken = async (username = "anonymous", password = "Password1") => {
        // try to get the token from local storage
        let access_token = getFromStorage("access_token");
        let user_id = getFromStorage("user_id");
        let session_id = parseInt(getFromStorage("session_id")) || 0;
        // decode jwt and multiply to get the elapsed time in miliseconds
        // from 1st of January 1970 at 00:00 (UTC/GMT)
        let will_expire = true;
        if (
        // This means we saved undefined as the token in the past,
        // and we need to check for this case
        access_token !== "undefined" &&
            !!access_token &&
            !!user_id &&
            typeof session_id === "number") {
            const token_data = JSON.parse(window.atob(access_token.split(".")[1]));
            const exp = token_data.exp * 1000;
            // expires in 15 min
            will_expire = moment(new Date()).add(15, "m").isAfter(exp);
        }
        if (will_expire) {
            // Get a token:
            const response = await renew_token$1(username, password);
            if (!response) {
                error$2.set("Error: Could not renew authentication token");
            }
            access_token = response.access_token;
            user_id = response.user_id;
            // admin = response.admin;
            // TODO: only increment on user request
            session_id++;
            setToStorage("access_token", access_token);
            setToStorage("user_id", user_id);
            setToStorage("session_id", session_id.toString());
        }
        const token_data = JSON.parse(window.atob(access_token.split(".")[1]));
        username = token_data.username;
        return { access_token, user_id, session_id };
    };
    async function renew_token$1(username, password) {
        let access_token;
        let user_id;
        let admin;
        const formData = new FormData();
        formData.append("username", username);
        formData.append("password", password);
        try {
            const response = await fetch(TOKEN_ENDPOINT, {
                method: "POST",
                body: formData,
            });
            const res = (await response.json());
            access_token = res.access_token;
            user_id = res.user_id;
            admin = res.admin;
        }
        catch (err) {
            const e = err;
            if (e?.response?.data?.detail) {
                error$2.set(`Error:\n ${e.response.data.detail}`);
            }
            else {
                error$2.set(`${JSON.stringify(e)}`);
            }
        }
        setToStorage("access_token", access_token);
        setToStorage("user_id", user_id);
        return { access_token, user_id, admin };
    }

    const cancelBackendWriting = writable(false);

    let websocket;
    // For websocket reconnect
    const INITIAL_BACKOFF = 1000;
    const MAX_BACKOFF = 64000;
    let current_backoff = INITIAL_BACKOFF;
    let message_counter = 0;
    let access_token;
    let _user_id;
    // Was used to store chat history in localstorage.
    // May not be needed anymore
    let session_id = parseInt(getFromStorage("session_id")) || 0;
    session_id++;
    setToStorage("session_id", session_id.toString());
    let websocket_error = false;
    let local_username = "";
    let lastTalkingVideoReceived = "";
    message_counter = parseInt(getFromStorage("message_counter")) || 0;
    const MAX_CHARS = 15;
    const breakLongWords = (text) => {
        if (!text)
            return "";
        const arr = text.split(" ");
        let result = "";
        arr.forEach((a) => {
            // dont add shy if we are in  a break tag
            if (a.length > MAX_CHARS &&
                !a.includes("<br") &&
                !a.includes("href") &&
                !a.includes("_blank")) {
                for (let i = a.length + 1; i > 0; i--) {
                    if (i % MAX_CHARS == 0) {
                        a = a.substring(0, i) + "&shy;" + a.substring(i);
                    }
                }
            }
            result += " " + a;
        });
        return result.trim();
    };
    const restartWebSocket = (username, new_token, __user_id) => {
        local_username = username;
        if (new_token)
            access_token = new_token;
        if (__user_id)
            _user_id = __user_id;
        if (websocket)
            websocket.close();
    };
    const mountWebSocket = (username, new_token, __user_id, org_id, head_id, newVideoCb = () => null, onReadyCb = () => null, userCountCb = (_) => {
    }, statusChangedCb = (_) => {
    }, newHookCb = (_) => {
    }, conversationEndCb = () => null, cacheCheckCb = () => null, videoSynthErrorCb) => {
        access_token = new_token;
        local_username = username;
        _user_id = __user_id;
        // connect to websocket
        websocket = new WebSocket((window.location.protocol === "https:" ? "wss://" : "ws://") +
            window.location.host +
            `/api/v1/switch/${org_id}/${head_id}`);
        websocket.onmessage = function (e) {
            // check if message is from user or from backend
            // if message is from backend, update chat
            const raw_msg = JSON.parse(e.data);
            const { user_id, id, username, text, timestamp, event, video, op, users, hook, media, cached, error_reason, } = raw_msg;
            const new_chat_store = get_store_value(private_chat_store);
            switch (event) {
                case "text": {
                    // Main message type. Contains a text to be displayed in the chat history
                    if (username === local_username && user_id === _user_id) {
                        // Message from backend is an echo. We do a reverse loop to find it in the message
                        // array to set its isSent status to true
                        for (let i = new_chat_store.length - 1; i >= 0; i--) {
                            const c = new_chat_store[i];
                            if (c.event === event &&
                                c.id === id &&
                                c.user_id === user_id &&
                                c.text === text &&
                                c.username === username) {
                                c.isSent = true;
                                if (video) {
                                    c.url = video;
                                }
                                break;
                            }
                        }
                    }
                    else {
                        // New message from server (not echo)
                        const new_msg = {
                            id: id,
                            user_id: user_id,
                            username: username,
                            timestamp: new Date(Date.parse(timestamp)),
                            speaker: "backend",
                            text: breakLongWords(text),
                            isSent: true,
                            event: event,
                            url: video,
                            visible: false,
                        };
                        // here we are pushing new message to store,
                        // thus showing it on the chat log
                        new_chat_store.push(new_msg);
                    }
                    if (video) {
                        // Signal if the new message contains a video url
                        lastTalkingVideoReceived = video;
                        newVideoCb(video);
                    }
                    break;
                }
                case "hook": {
                    // A message containing a hook, wich gets parsed as a suggestion message
                    cancelBackendWriting.set(true);
                    const hook_msg = {
                        type: "suggestions",
                        hook,
                        disabled: false,
                    };
                    if (hook.inputType === "options") {
                        if (hook.text) {
                            newHookCb(() => {
                                new_chat_store.push(hook_msg);
                                // we need to update the store in order to see the changes
                                private_chat_store.set(new_chat_store);
                            });
                        }
                        else {
                            new_chat_store.push(hook_msg);
                        }
                    }
                    break;
                }
                case "media": {
                    // A message containing an image url
                    const media_msg = {
                        type: "media",
                        media: media,
                        timestamp: new Date(Date.parse(timestamp)),
                    };
                    new_chat_store.push(media_msg);
                    break;
                }
                case "cache": {
                    // Whether a requested video is cached or not (used in vm2)co
                    cacheCheckCb(!!cached);
                    break;
                }
                case "aggregator_error": {
                    const msg = error_reason || "There was an error processing your message";
                    addInfo(msg, true);
                    videoSynthErrorCb();
                    break;
                }
                case "conversation_end": {
                    addInfo("Conversation ended", true);
                    conversationEndCb();
                    cancelBackendWriting.set(true);
                    break;
                }
                case "join" : {
                    // For opsp, we check the status of the admin
                    statusChangedCb(op);
                    break;
                }
                case "count": {
                    // For opsp, we handle the amount of connected users
                    userCountCb(users /* - admins*/);
                    break;
                }
                case "unrecoverable_error": {
                    error$2.set(error_reason);
                    websocket.close();
                    websocket_error = true;
                    break;
                }
                default: {
                    console.info("Got an unexpected event", event);
                    break;
                }
            }
            // After checking the message, we push the changes, if any
            private_chat_store.set(new_chat_store);
        };
        websocket.onopen = () => {
            console.info("Websocket connection open");
            websocket.send(access_token);
            current_backoff = INITIAL_BACKOFF;
            // TODO: notify we are ready
            onReadyCb();
        };
        websocket.onclose = () => {
            console.info("Websocket connection closed");
            if (!websocket_error) {
                setTimeout(() => {
                    current_backoff = Math.max(current_backoff * 2, MAX_BACKOFF);
                    mountWebSocket(local_username, access_token, _user_id, org_id, head_id, newVideoCb, onReadyCb, userCountCb, statusChangedCb, newHookCb, conversationEndCb, cacheCheckCb, videoSynthErrorCb);
                }, current_backoff);
            }
            else {
                // Check if there is already an error or add a default one
                if (!get_store_value(error$2)) {
                    error$2.set("There was an error. Please try again or contact us");
                }
            }
        };
        websocket.onerror = (ws) => {
            console.error("Websocket error", ws);
            error$2.set(`Error connecting to our servers`);
            websocket_error = true;
        };
    };
    const displayMessage = (event) => {
        const talkingVideoSrc = event.detail;
        const new_chat_store = get_store_value(private_chat_store);
        for (let i = new_chat_store.length - 1; i >= 0; i--) {
            if (new_chat_store[i].url === talkingVideoSrc) {
                new_chat_store[i].visible = true;
                break;
            }
        }
        private_chat_store.set(new_chat_store);
    };
    const userInput = (msg) => {
        const text = msg.detail;
        // add the message to the list
        const new_msg = {
            id: ++message_counter,
            timestamp: new Date(),
            speaker: "user",
            text: breakLongWords(text),
            isSent: false,
            user_id: _user_id,
            username: local_username,
            event: "text",
            session_id: `${_user_id}::${org_id}::${head_id}::${session_id
            .toString()
            .padStart(5, "0")}`,
            visible: true,
        };
        setToStorage("message_counter", message_counter.toString());
        const old_chat_store = get_store_value(private_chat_store);
        let i = old_chat_store.length - 1;
        // Find latest enabled option and set to disabled
        while (i > 0) {
            // TODO: add hook definition to msg_type, move msg_type to corresponding file
            const item = old_chat_store[i];
            if (item.type === "suggestions" && !item.disabled) {
                item.disabled = true;
                const inputs = item.hook.inputs;
                // check if the input matches any option and set to selected
                for (let j = 0; j < inputs.length; j++) {
                    if (inputs[j].text === msg.detail) {
                        inputs[j].selected = true;
                    }
                }
                break;
            }
            i--;
        }
        private_chat_store.set([...old_chat_store, new_msg]);
        if (websocket) {
            // We do not want to apply the breakLongWords function to the
            // text we send to the websocket, since there is no need to
            // send `&shy;` to the tts provider
            new_msg.text = text;
            websocket.send(JSON.stringify(new_msg));
        }
    };
    /**
     * Requests a new video for the backend.
     * Should only be called after the last video has played
     */
    const requestNextVideo = () => {
        if (websocket) {
            websocket.send(JSON.stringify({ event: "request_next_video" }));
        }
    };
    const addInfo = (text, timestamp = false) => {
        // add info to the message list
        const new_msg = {
            text,
            type: "info",
        };
        if (timestamp) {
            new_msg.timestamp = new Date();
        }
        const new_chat_store = get_store_value(private_chat_store);
        new_chat_store.push(new_msg);
        private_chat_store.set(new_chat_store);
    };

    const API_ENDPOINT = get_store_value(body_data).api_base;
    const ASR_TOKEN_ENDPOINT = API_ENDPOINT + "/api/v1/asr_token";
    async function getAsrToken() {
        // try to get the token from local storage
        let token = getFromStorage("asr_token");
        let region = getFromStorage("asr_region");
        const { access_token } = await getToken();
        let will_expire = true;
        if (!!token && !!region) {
            const decoded_token = JSON.parse(window.atob(token.split(".")[1]));
            const exp = decoded_token.exp * 1000;
            // expires in 15 min
            will_expire = moment(new Date()).add(5, "m").isAfter(exp);
        }
        if (will_expire) {
            // Get a token:
            const response = await renew_token(access_token);
            if (!response) {
                return { token: null };
            }
            token = response.token;
            region = response.region;
            setToStorage("asr_token", token);
            setToStorage("asr_region", region);
        }
        return { token, region };
    }
    async function renew_token(auth_jwt) {
        try {
            const res = await fetch(ASR_TOKEN_ENDPOINT, {
                headers: { Authorization: `Bearer ${auth_jwt}` },
            });
            const data = (await res.json());
            const token = data.token;
            const region = data.region;
            return { token, region };
        }
        catch (err) {
            return null;
        }
    }
    async function requestMicAccess() {
        // ask for microphone access
        if (navigator.mediaDevices) {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                });
                stream.getTracks().forEach((track) => track.stop());
                const token = await getAsrToken();
                if (token) {
                    return true;
                }
                else {
                    return false;
                }
            }
            catch (err) {
                const e = err;
                if (e.name === "NotAllowedError") {
                    // Explain why you need permission and how to update the permission setting
                    console.warn("microphone access is blocked, no ASR available");
                }
                else {
                    console.warn("some other error in microphone access");
                }
                throw new Error();
            }
        }
        else {
            console.warn("there are no mediadevices");
            throw new Error();
        }
    }
    const sttFromMic = async (language = undefined, cb = (t) => {
    }) => {
        const tokenObj = await getAsrToken();
        const speechConfig = window.SpeechSDK.SpeechConfig.fromAuthorizationToken(tokenObj.token, tokenObj.region);
        speechConfig.speechRecognitionLanguage = language;
        // speechConfig.speechRecognitionLanguage = "es-ES";
        const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
        const recognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);
        let displayText;
        // // speak into your microphone...
        // setASR(ASRState.Recording);
        recognizer.recognizeOnceAsync((result) => {
            if (result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
                displayText = result.text;
                // setText(result.text);
            }
            else {
                addInfo("The microphone is mute. Perhaps your microphone is disabled or not working properly. You can try typing the text in the input box below.");
            }
            // display text
            // setTimeout(() => {
            //   textEntered(result.text);
            // }, 200);
            // setASR(ASRState.Waiting);
            cb(displayText);
        });
    };

    /* node_modules/svelte-material-icons/Send.svelte generated by Svelte v3.47.0 */

    const file$y = "node_modules/svelte-material-icons/Send.svelte";

    function create_fragment$F(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M2,21L23,12L2,3V10L17,12L2,14V21Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$y, 8, 59, 234);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			add_location(svg, file$y, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Send', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 24 24" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Send> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Send extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$B, create_fragment$F, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Send",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get size() {
    		throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Send>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Send>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-material-icons/Microphone.svelte generated by Svelte v3.47.0 */

    const file$x = "node_modules/svelte-material-icons/Microphone.svelte";

    function create_fragment$E(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$x, 8, 59, 234);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			add_location(svg, file$x, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Microphone', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 24 24" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Microphone> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Microphone extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$A, create_fragment$E, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Microphone",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get size() {
    		throw new Error("<Microphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Microphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Microphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Microphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Microphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Microphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Microphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Microphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Microphone>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Microphone>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-material-icons/Stop.svelte generated by Svelte v3.47.0 */

    const file$w = "node_modules/svelte-material-icons/Stop.svelte";

    function create_fragment$D(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M18,18H6V6H18V18Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$w, 8, 59, 234);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			add_location(svg, file$w, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Stop', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 24 24" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Stop> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Stop extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$z, create_fragment$D, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Stop",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get size() {
    		throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Stop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Stop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/InputContainer.svelte generated by Svelte v3.47.0 */
    const file$v = "src/components/InputContainer.svelte";

    function add_css$f(target) {
    	append_styles(target, "svelte-101kugg", ".user-input-container.svelte-101kugg{flex:1 1}.input-container.svelte-101kugg{display:flex;background:rgb(var(--background));box-shadow:0 4px 20px 0 rgba(var(--shadow), 0.2);border-radius:10px;margin:0.5em 1em 0em 1em;z-index:2}.input-button.svelte-101kugg{color:rgb(var(--body));background-color:rgba(var(--primary), 0.2);border:none;border-radius:0.5em;margin:0.5em 0.5em;margin-right:1em;display:flex;padding:0.6em;align-items:center;justify-content:center;transition:all 0.2s ease-in-out}.input-button.svelte-101kugg:hover{cursor:pointer;background-color:rgb(var(--primary))}.input-button.svelte-101kugg:disabled{opacity:0.4;background-color:rgba(var(--primary), 0.7);cursor:unset}.user-input.svelte-101kugg{display:flex;height:fit-content;flex-direction:column}.controls.svelte-101kugg{display:flex;color:rgb(var(--body));flex-direction:row;justify-content:space-around;align-content:center;z-index:1;background-color:rgb(var(--body), 0.7);margin:-1.25em 1em;border-radius:0 0 2em 2em;padding-top:2em;padding-bottom:0.75em;margin-bottom:0.5em}.is-full-screen-controls.svelte-101kugg{display:none}.text-box.svelte-101kugg{align-self:center;flex:1;background:rgb(var(--background));border-radius:0.7em;width:100%;border:none;font-style:normal;padding:1em 1.5em;color:rgb(var(--body))}.text-box.svelte-101kugg:focus{outline:none}.loading-text.svelte-101kugg{margin-left:1.5em;margin-bottom:0.5em;font-size:0.8em}.recording.svelte-101kugg{animation:svelte-101kugg-grow 1s ease-in-out infinite;background-color:rgb(var(--secondary));z-index:10}.recording.svelte-101kugg:hover{background-color:rgb(var(--secondary));cursor:unset}.recording.svelte-101kugg:disabled{background-color:rgb(var(--secondary));opacity:1}.progress-bar.svelte-101kugg{animation:svelte-101kugg-progress 1.5s ease-in forwards;border:none;background-color:rgb(var(--secondary));width:0;margin:0em 1em;height:0.1em;border-radius:1em}@keyframes svelte-101kugg-progress{0%{width:0;opacity:0}10%{opacity:1}95%{width:calc(100% - 2em);opacity:1}100%{width:calc(100% - 2em);opacity:0}}@keyframes svelte-101kugg-grow{0%{transform:scale(1);box-shadow:none}50%{transform:scale(1.05);box-shadow:0px 0px 0px 10px rgba(var(--shadow), 0.4)}100%{transform:scale(1);box-shadow:none}}@media only screen and (max-width: 600px){.controls.svelte-101kugg{display:flex;flex-direction:row;justify-content:space-around;align-content:center;z-index:1;background-color:rgb(var(--body), 0.7);margin:-1.25em 1em;border-radius:0 0 2em 2em;padding-top:2em;padding-bottom:0.75em;margin-bottom:0.5em}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5wdXRDb250YWluZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9LRSxxQkFBcUIsZUFBQyxDQUFBLEFBQ3BCLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxBQUNYLENBQUEsQUFFQSxnQkFBZ0IsZUFBQyxDQUFBLEFBQ2YsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQ2xDLFVBQVUsQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ2pELGFBQWEsQ0FBRSxJQUFJLENBQ25CLE1BQU0sQ0FBRSxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQ3pCLE9BQU8sQ0FBRSxDQUFDLEFBQ1osQ0FBQSxBQUVBLGFBQWEsZUFBQyxDQUFBLEFBQ1osS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDM0MsTUFBTSxDQUFFLElBQUksQ0FDWixhQUFhLENBQUUsS0FBSyxDQUNwQixNQUFNLENBQUUsS0FBSyxDQUFDLEtBQUssQ0FDbkIsWUFBWSxDQUFFLEdBQUcsQ0FDakIsT0FBTyxDQUFFLElBQUksQ0FDYixPQUFPLENBQUUsS0FBSyxDQUNkLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFVBQVUsQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsQUFDbEMsQ0FBQSxBQUVBLDRCQUFhLE1BQU0sQUFBQyxDQUFBLEFBQ2xCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEFBQ3ZDLENBQUEsQUFDQSw0QkFBYSxTQUFTLEFBQUMsQ0FBQSxBQUNyQixPQUFPLENBQUUsR0FBRyxDQUNaLGdCQUFnQixDQUFFLEtBQUssSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUMzQyxNQUFNLENBQUUsS0FBSyxBQUNmLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLFdBQVcsQ0FDbkIsY0FBYyxDQUFFLE1BQU0sQUFDeEIsQ0FBQSxBQUVBLFNBQVMsZUFBQyxDQUFBLEFBQ1IsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQ3ZCLGNBQWMsQ0FBRSxHQUFHLENBQ25CLGVBQWUsQ0FBRSxZQUFZLENBQzdCLGFBQWEsQ0FBRSxNQUFNLENBQ3JCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3ZDLE1BQU0sQ0FBRSxPQUFPLENBQUMsR0FBRyxDQUNuQixhQUFhLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUMxQixXQUFXLENBQUUsR0FBRyxDQUNoQixjQUFjLENBQUUsTUFBTSxDQUN0QixhQUFhLENBQUUsS0FBSyxBQUN0QixDQUFBLEFBRUEsd0JBQXdCLGVBQUMsQ0FBQSxBQUN2QixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFFQSxTQUFTLGVBQUMsQ0FBQSxBQUNSLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsVUFBVSxDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUNsQyxhQUFhLENBQUUsS0FBSyxDQUNwQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLE1BQU0sQ0FDbEIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQ2xCLEtBQUssQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQUFDekIsQ0FBQSxBQUVBLHdCQUFTLE1BQU0sQUFBQyxDQUFBLEFBQ2QsT0FBTyxDQUFFLElBQUksQUFDZixDQUFBLEFBRUEsYUFBYSxlQUFDLENBQUEsQUFDWixXQUFXLENBQUUsS0FBSyxDQUNsQixhQUFhLENBQUUsS0FBSyxDQUNwQixTQUFTLENBQUUsS0FBSyxBQUNsQixDQUFBLEFBRUEsVUFBVSxlQUFDLENBQUEsQUFDVCxTQUFTLENBQUUsbUJBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FDdkMsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQ3ZDLE9BQU8sQ0FBRSxFQUFFLEFBQ2IsQ0FBQSxBQUNBLHlCQUFVLE1BQU0sQUFBQyxDQUFBLEFBQ2YsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQ3ZDLE1BQU0sQ0FBRSxLQUFLLEFBQ2YsQ0FBQSxBQUNBLHlCQUFVLFNBQVMsQUFBQyxDQUFBLEFBQ2xCLGdCQUFnQixDQUFFLElBQUksSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUN2QyxPQUFPLENBQUUsQ0FBQyxBQUNaLENBQUEsQUFFQSxhQUFhLGVBQUMsQ0FBQSxBQUNaLFNBQVMsQ0FBRSx1QkFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUN6QyxNQUFNLENBQUUsSUFBSSxDQUNaLGdCQUFnQixDQUFFLElBQUksSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUN2QyxLQUFLLENBQUUsQ0FBQyxDQUNSLE1BQU0sQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUNmLE1BQU0sQ0FBRSxLQUFLLENBQ2IsYUFBYSxDQUFFLEdBQUcsQUFDcEIsQ0FBQSxBQUVBLFdBQVcsdUJBQVMsQ0FBQSxBQUNsQixFQUFFLEFBQUMsQ0FBQSxBQUNELEtBQUssQ0FBRSxDQUFDLENBQ1IsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFBLEFBQ0EsR0FBRyxBQUFDLENBQUEsQUFDRixPQUFPLENBQUUsQ0FBQyxBQUNaLENBQUEsQUFDQSxHQUFHLEFBQUMsQ0FBQSxBQUNGLEtBQUssQ0FBRSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3ZCLE9BQU8sQ0FBRSxDQUFDLEFBQ1osQ0FBQSxBQUNBLElBQUksQUFBQyxDQUFBLEFBQ0gsS0FBSyxDQUFFLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDdkIsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFBLEFBQ0YsQ0FBQSxBQUVBLFdBQVcsbUJBQUssQ0FBQSxBQUNkLEVBQUUsQUFBQyxDQUFBLEFBQ0QsU0FBUyxDQUFFLE1BQU0sQ0FBQyxDQUFDLENBQ25CLFVBQVUsQ0FBRSxJQUFJLEFBQ2xCLENBQUEsQUFDQSxHQUFHLEFBQUMsQ0FBQSxBQUNGLFNBQVMsQ0FBRSxNQUFNLElBQUksQ0FBQyxDQUN0QixVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUN2RCxDQUFBLEFBQ0EsSUFBSSxBQUFDLENBQUEsQUFDSCxTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQ0FDbkIsVUFBVSxDQUFFLElBQUksQUFDbEIsQ0FBQSxBQUNGLENBQUEsQUFDQSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUN4QyxTQUFTLGVBQUMsQ0FBQSxBQUNSLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsZUFBZSxDQUFFLFlBQVksQ0FDN0IsYUFBYSxDQUFFLE1BQU0sQ0FDckIsT0FBTyxDQUFFLENBQUMsQ0FDVixnQkFBZ0IsQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDdkMsTUFBTSxDQUFFLE9BQU8sQ0FBQyxHQUFHLENBQ25CLGFBQWEsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQzFCLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLGFBQWEsQ0FBRSxLQUFLLEFBQ3RCLENBQUEsQUFDRixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIklucHV0Q29udGFpbmVyLnN2ZWx0ZSJdfQ== */");
    }

    // (81:4) {#if $backendWriting && opmode !== "opsp" && !$isFullScreen}
    function create_if_block_3$3(ctx) {
    	let div;
    	let t_value = /*$_*/ ctx[9]("chat-component.typing-status") + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "loading-text svelte-101kugg");
    			add_location(div, file$v, 81, 6, 3079);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 512 && t_value !== (t_value = /*$_*/ ctx[9]("chat-component.typing-status") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(81:4) {#if $backendWriting && opmode !== \\\"opsp\\\" && !$isFullScreen}",
    		ctx
    	});

    	return block;
    }

    // (110:6) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let send;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;
    	send = new Send({ props: { size: "1.5em" }, $$inline: true });

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(send.$$.fragment);
    			attr_dev(button, "class", "input-button shadow svelte-101kugg");
    			button.disabled = button_disabled_value = (/^\s+$/).test(/*$user_input_value*/ ctx[6]) || !/*$user_input_value*/ ctx[6];
    			add_location(button, file$v, 110, 8, 4007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(send, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler_1*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*$user_input_value*/ 64 && button_disabled_value !== (button_disabled_value = (/^\s+$/).test(/*$user_input_value*/ ctx[6]) || !/*$user_input_value*/ ctx[6])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(send.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(send.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(send);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(110:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (97:6) {#if asr && (/^\s+$/.test($user_input_value) || !$user_input_value)}
    function create_if_block_1$6(ctx) {
    	let button;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_2$4, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		return 1;
    	}

    	current_block_type_index = select_block_type_1();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if_block.c();
    			attr_dev(button, "class", "input-button svelte-101kugg");
    			button.disabled = /*asrRecording*/ ctx[5];
    			toggle_class(button, "recording", /*asrRecording*/ ctx[5]);
    			add_location(button, file$v, 97, 8, 3653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if_blocks[current_block_type_index].m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[19], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1();

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(button, null);
    			}

    			if (!current || dirty & /*asrRecording*/ 32) {
    				prop_dev(button, "disabled", /*asrRecording*/ ctx[5]);
    			}

    			if (dirty & /*asrRecording*/ 32) {
    				toggle_class(button, "recording", /*asrRecording*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(97:6) {#if asr && (/^\\s+$/.test($user_input_value) || !$user_input_value)}",
    		ctx
    	});

    	return block;
    }

    // (106:10) {:else}
    function create_else_block$4(ctx) {
    	let microphone;
    	let current;
    	microphone = new Microphone({ props: { size: "1.5em" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(microphone.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(microphone, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(microphone.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(microphone.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(microphone, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(106:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (104:10) {#if false && asrRecording}
    function create_if_block_2$4(ctx) {
    	let stop;
    	let current;
    	stop = new Stop({ props: { size: "1.5em" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(stop.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(stop, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stop.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stop.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(stop, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(104:10) {#if false && asrRecording}",
    		ctx
    	});

    	return block;
    }

    // (120:4) {#if isAsrCancellable}
    function create_if_block$d(ctx) {
    	let button;
    	let button_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			attr_dev(button, "class", "progress-bar svelte-101kugg");
    			add_location(button, file$v, 120, 6, 4300);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*handleProgressbarCancel*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!button_transition) button_transition = create_bidirectional_transition(button, fade, {}, true);
    				button_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!button_transition) button_transition = create_bidirectional_transition(button, fade, {}, false);
    			button_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching && button_transition) button_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(120:4) {#if isAsrCancellable}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div3;
    	let div2;
    	let t0;
    	let suggestioncontainer;
    	let updating_currentSuggestions;
    	let t1;
    	let div0;
    	let input;
    	let input_placeholder_value;
    	let t2;
    	let show_if;
    	let current_block_type_index;
    	let if_block1;
    	let t3;
    	let t4;
    	let div1;
    	let controls;
    	let updating_size;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$backendWriting*/ ctx[7] && /*opmode*/ ctx[2] !== "opsp" && !/*$isFullScreen*/ ctx[8] && create_if_block_3$3(ctx);

    	function suggestioncontainer_currentSuggestions_binding(value) {
    		/*suggestioncontainer_currentSuggestions_binding*/ ctx[17](value);
    	}

    	let suggestioncontainer_props = {};

    	if (/*currentSuggestions*/ ctx[4] !== void 0) {
    		suggestioncontainer_props.currentSuggestions = /*currentSuggestions*/ ctx[4];
    	}

    	suggestioncontainer = new SuggestionContainer({
    			props: suggestioncontainer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(suggestioncontainer, 'currentSuggestions', suggestioncontainer_currentSuggestions_binding));
    	suggestioncontainer.$on("optionSelected", /*handleOptionSelected*/ ctx[15]);
    	const if_block_creators = [create_if_block_1$6, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty & /*asr, $user_input_value*/ 66) show_if = null;
    		if (show_if == null) show_if = !!(/*asr*/ ctx[1] && ((/^\s+$/).test(/*$user_input_value*/ ctx[6]) || !/*$user_input_value*/ ctx[6]));
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, -1);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block2 = /*isAsrCancellable*/ ctx[0] && create_if_block$d(ctx);

    	function controls_size_binding(value) {
    		/*controls_size_binding*/ ctx[21](value);
    	}

    	let controls_props = {};

    	if (/*controlsSize*/ ctx[3] !== void 0) {
    		controls_props.size = /*controlsSize*/ ctx[3];
    	}

    	controls = new Controls({ props: controls_props, $$inline: true });
    	binding_callbacks.push(() => bind(controls, 'size', controls_size_binding));
    	controls.$on("skip", /*skip_handler*/ ctx[22]);
    	controls.$on("replay", /*replay_handler*/ ctx[23]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			create_component(suggestioncontainer.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			input = element("input");
    			t2 = space();
    			if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div1 = element("div");
    			create_component(controls.$$.fragment);
    			attr_dev(input, "class", "text-box svelte-101kugg");
    			input.disabled = /*$disableChatInput*/ ctx[10];
    			attr_dev(input, "placeholder", input_placeholder_value = /*$_*/ ctx[9]("chat-component.input-placeholder"));
    			add_location(input, file$v, 88, 6, 3307);
    			attr_dev(div0, "class", "input-container svelte-101kugg");
    			add_location(div0, file$v, 87, 4, 3271);
    			attr_dev(div1, "class", "controls svelte-101kugg");
    			toggle_class(div1, "is-full-screen-controls", !/*$isFullScreen*/ ctx[8]);
    			add_location(div1, file$v, 126, 4, 4427);
    			attr_dev(div2, "class", "user-input svelte-101kugg");
    			add_location(div2, file$v, 79, 2, 2983);
    			attr_dev(div3, "class", "user-input-container svelte-101kugg");
    			add_location(div3, file$v, 78, 0, 2946);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t0);
    			mount_component(suggestioncontainer, div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*$user_input_value*/ ctx[6]);
    			append_dev(div0, t2);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div2, t3);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			mount_component(controls, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[18]),
    					listen_dev(input, "focus", /*handleProgressbarCancel*/ ctx[12], false, false, false),
    					listen_dev(input, "keypress", /*handleKeyboardInput*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$backendWriting*/ ctx[7] && /*opmode*/ ctx[2] !== "opsp" && !/*$isFullScreen*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$3(ctx);
    					if_block0.c();
    					if_block0.m(div2, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			const suggestioncontainer_changes = {};

    			if (!updating_currentSuggestions && dirty & /*currentSuggestions*/ 16) {
    				updating_currentSuggestions = true;
    				suggestioncontainer_changes.currentSuggestions = /*currentSuggestions*/ ctx[4];
    				add_flush_callback(() => updating_currentSuggestions = false);
    			}

    			suggestioncontainer.$set(suggestioncontainer_changes);

    			if (!current || dirty & /*$disableChatInput*/ 1024) {
    				prop_dev(input, "disabled", /*$disableChatInput*/ ctx[10]);
    			}

    			if (!current || dirty & /*$_*/ 512 && input_placeholder_value !== (input_placeholder_value = /*$_*/ ctx[9]("chat-component.input-placeholder"))) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty & /*$user_input_value*/ 64 && input.value !== /*$user_input_value*/ ctx[6]) {
    				set_input_value(input, /*$user_input_value*/ ctx[6]);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div0, null);
    			}

    			if (/*isAsrCancellable*/ ctx[0]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*isAsrCancellable*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$d(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, t4);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const controls_changes = {};

    			if (!updating_size && dirty & /*controlsSize*/ 8) {
    				updating_size = true;
    				controls_changes.size = /*controlsSize*/ ctx[3];
    				add_flush_callback(() => updating_size = false);
    			}

    			controls.$set(controls_changes);

    			if (dirty & /*$isFullScreen*/ 256) {
    				toggle_class(div1, "is-full-screen-controls", !/*$isFullScreen*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(suggestioncontainer.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(controls.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(suggestioncontainer.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(controls.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			destroy_component(suggestioncontainer);
    			if_blocks[current_block_type_index].d();
    			if (if_block2) if_block2.d();
    			destroy_component(controls);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $user_input_value;
    	let $backendWriting;
    	let $isFullScreen;
    	let $_;
    	let $disableChatInput;
    	validate_store(user_input_value, 'user_input_value');
    	component_subscribe($$self, user_input_value, $$value => $$invalidate(6, $user_input_value = $$value));
    	validate_store(backendWriting, 'backendWriting');
    	component_subscribe($$self, backendWriting, $$value => $$invalidate(7, $backendWriting = $$value));
    	validate_store(isFullScreen, 'isFullScreen');
    	component_subscribe($$self, isFullScreen, $$value => $$invalidate(8, $isFullScreen = $$value));
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(9, $_ = $$value));
    	validate_store(disableChatInput, 'disableChatInput');
    	component_subscribe($$self, disableChatInput, $$value => $$invalidate(10, $disableChatInput = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InputContainer', slots, []);
    	let { asr = false } = $$props;
    	let { opmode = "" } = $$props;
    	let { language = undefined } = $$props;
    	let { isAsrCancellable = false } = $$props;
    	let controlsSize = "2em";
    	let currentSuggestions;
    	const dispatch = createEventDispatcher();
    	let asrRecording = false;
    	let timer = undefined;

    	const handleProgressbar = () => {
    		$$invalidate(0, isAsrCancellable = true);

    		timer = setTimeout(
    			() => {
    				$$invalidate(0, isAsrCancellable = false);
    				dispatch("processUserInput");
    			},
    			2000
    		);
    	};

    	const handleProgressbarCancel = () => {
    		$$invalidate(0, isAsrCancellable = false);
    		timer && clearTimeout(timer);
    	};

    	const asrCallback = text => {
    		set_store_value(user_input_value, $user_input_value = text, $user_input_value);
    		$$invalidate(5, asrRecording = false);
    		handleProgressbar();
    	};

    	const asrRecognition = async () => {
    		$$invalidate(5, asrRecording = true);
    		await sttFromMic(language, asrCallback);
    	};

    	/**
     * On enter, we send something to the backend. We do a few checks before.
     *
     * First we check if the input given by the user matches a text of a suggestion.
     * In that case, we directly dispatch "processUserInput" and skip the next check.
     *
     * Secondly, we check if the input given by the user matches an index of a suggestion,
     * In that case, we set the user input to be the text of the suggestion and dispatch
     * the "processUserInput" event.
     *
     * Lastly, if there is no matches on values or indexes of the suggestions, we dispatch
     * the unaltered event.
     */
    	const handleKeyboardInput = e => {
    		if (e.code === "Enter") {
    			// Check if the current user_input_value matches exactly the text of a suggestion
    			for (let i = 0; i < currentSuggestions.length; i++) {
    				const suggestion = currentSuggestions[i];

    				if (suggestion.text === $user_input_value) {
    					dispatch("processUserInput");
    					return;
    				}
    			}

    			// check if the current user_input_value matches the index of a suggestion
    			if (currentSuggestions[parseInt($user_input_value) - 1] != null) {
    				set_store_value(user_input_value, $user_input_value = currentSuggestions[parseInt($user_input_value) - 1].text, $user_input_value);
    				dispatch("processUserInput");
    				return;
    			}

    			dispatch("processUserInput");
    		}
    	};

    	const handleOptionSelected = e => dispatch("optionSelected", e.detail);
    	const writable_props = ['asr', 'opmode', 'language', 'isAsrCancellable'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InputContainer> was created with unknown prop '${key}'`);
    	});

    	function suggestioncontainer_currentSuggestions_binding(value) {
    		currentSuggestions = value;
    		$$invalidate(4, currentSuggestions);
    	}

    	function input_input_handler() {
    		$user_input_value = this.value;
    		user_input_value.set($user_input_value);
    	}

    	const click_handler = () => asrRecognition();
    	const click_handler_1 = () => dispatch("processUserInput");

    	function controls_size_binding(value) {
    		controlsSize = value;
    		$$invalidate(3, controlsSize);
    	}

    	const skip_handler = () => dispatch("skip");
    	const replay_handler = () => dispatch("replay");

    	$$self.$$set = $$props => {
    		if ('asr' in $$props) $$invalidate(1, asr = $$props.asr);
    		if ('opmode' in $$props) $$invalidate(2, opmode = $$props.opmode);
    		if ('language' in $$props) $$invalidate(16, language = $$props.language);
    		if ('isAsrCancellable' in $$props) $$invalidate(0, isAsrCancellable = $$props.isAsrCancellable);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		fade,
    		Controls,
    		SuggestionContainer,
    		user_input_value,
    		backendWriting,
    		disableChatInput,
    		isFullScreen,
    		sttFromMic,
    		_: Y,
    		Send,
    		Microphone,
    		Stop,
    		asr,
    		opmode,
    		language,
    		isAsrCancellable,
    		controlsSize,
    		currentSuggestions,
    		dispatch,
    		asrRecording,
    		timer,
    		handleProgressbar,
    		handleProgressbarCancel,
    		asrCallback,
    		asrRecognition,
    		handleKeyboardInput,
    		handleOptionSelected,
    		$user_input_value,
    		$backendWriting,
    		$isFullScreen,
    		$_,
    		$disableChatInput
    	});

    	$$self.$inject_state = $$props => {
    		if ('asr' in $$props) $$invalidate(1, asr = $$props.asr);
    		if ('opmode' in $$props) $$invalidate(2, opmode = $$props.opmode);
    		if ('language' in $$props) $$invalidate(16, language = $$props.language);
    		if ('isAsrCancellable' in $$props) $$invalidate(0, isAsrCancellable = $$props.isAsrCancellable);
    		if ('controlsSize' in $$props) $$invalidate(3, controlsSize = $$props.controlsSize);
    		if ('currentSuggestions' in $$props) $$invalidate(4, currentSuggestions = $$props.currentSuggestions);
    		if ('asrRecording' in $$props) $$invalidate(5, asrRecording = $$props.asrRecording);
    		if ('timer' in $$props) timer = $$props.timer;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isAsrCancellable,
    		asr,
    		opmode,
    		controlsSize,
    		currentSuggestions,
    		asrRecording,
    		$user_input_value,
    		$backendWriting,
    		$isFullScreen,
    		$_,
    		$disableChatInput,
    		dispatch,
    		handleProgressbarCancel,
    		asrRecognition,
    		handleKeyboardInput,
    		handleOptionSelected,
    		language,
    		suggestioncontainer_currentSuggestions_binding,
    		input_input_handler,
    		click_handler,
    		click_handler_1,
    		controls_size_binding,
    		skip_handler,
    		replay_handler
    	];
    }

    class InputContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$y,
    			create_fragment$C,
    			safe_not_equal,
    			{
    				asr: 1,
    				opmode: 2,
    				language: 16,
    				isAsrCancellable: 0
    			},
    			add_css$f
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InputContainer",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get asr() {
    		throw new Error("<InputContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set asr(value) {
    		throw new Error("<InputContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opmode() {
    		throw new Error("<InputContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opmode(value) {
    		throw new Error("<InputContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get language() {
    		throw new Error("<InputContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set language(value) {
    		throw new Error("<InputContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isAsrCancellable() {
    		throw new Error("<InputContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isAsrCancellable(value) {
    		throw new Error("<InputContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-material-icons/AccountCircle.svelte generated by Svelte v3.47.0 */

    const file$u = "node_modules/svelte-material-icons/AccountCircle.svelte";

    function create_fragment$B(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12,19.2C9.5,19.2 7.29,17.92 6,16C6.03,14 10,12.9 12,12.9C14,12.9 17.97,14 18,16C16.71,17.92 14.5,19.2 12,19.2M12,5A3,3 0 0,1 15,8A3,3 0 0,1 12,11A3,3 0 0,1 9,8A3,3 0 0,1 12,5M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z");
    			attr_dev(path, "fill", /*color*/ ctx[2]);
    			add_location(path, file$u, 8, 59, 234);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			add_location(svg, file$u, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccountCircle', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 24 24" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccountCircle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class AccountCircle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$x, create_fragment$B, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccountCircle",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get size() {
    		throw new Error("<AccountCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<AccountCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<AccountCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<AccountCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<AccountCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<AccountCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<AccountCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<AccountCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<AccountCircle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<AccountCircle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Avatar.svelte generated by Svelte v3.47.0 */
    const file$t = "src/components/Avatar.svelte";

    function add_css$e(target) {
    	append_styles(target, "svelte-1ie2ift", "div.svelte-1ie2ift{display:flex}img.svelte-1ie2ift{border-radius:50%;margin:auto}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXZhdGFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFrQkUsR0FBRyxlQUFDLENBQUEsQUFDRixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFDQSxHQUFHLGVBQUMsQ0FBQSxBQUNGLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLEFBQ2QsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJBdmF0YXIuc3ZlbHRlIl19 */");
    }

    // (11:2) {:else}
    function create_else_block$3(ctx) {
    	let accountcircle;
    	let current;

    	accountcircle = new AccountCircle({
    			props: {
    				size: /*size*/ ctx[1],
    				color: /*color*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(accountcircle.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(accountcircle, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const accountcircle_changes = {};
    			if (dirty & /*size*/ 2) accountcircle_changes.size = /*size*/ ctx[1];
    			if (dirty & /*color*/ 8) accountcircle_changes.color = /*color*/ ctx[3];
    			accountcircle.$set(accountcircle_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accountcircle.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accountcircle.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(accountcircle, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(11:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (9:2) {#if src}
    function create_if_block$c(ctx) {
    	let img;
    	let img_src_value;
    	let img_style_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "avatar");
    			attr_dev(img, "style", img_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`);
    			attr_dev(img, "class", "svelte-1ie2ift");
    			add_location(img, file$t, 9, 4, 242);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*src*/ 1 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*size*/ 2 && img_style_value !== (img_style_value = `height: ${/*size*/ ctx[1]}; width: ${/*size*/ ctx[1]};`)) {
    				attr_dev(img, "style", img_style_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(9:2) {#if src}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$c, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*src*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "style", /*style*/ ctx[2]);
    			attr_dev(div, "class", "svelte-1ie2ift");
    			add_location(div, file$t, 7, 0, 212);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			if (!current || dirty & /*style*/ 4) {
    				attr_dev(div, "style", /*style*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Avatar', slots, []);
    	let { src = "" } = $$props;
    	let { size = "2em" } = $$props;
    	let { style = undefined } = $$props;
    	let { color = "currentColor" } = $$props;
    	const writable_props = ['src', 'size', 'style', 'color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Avatar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('src' in $$props) $$invalidate(0, src = $$props.src);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({ AccountCircle, src, size, style, color });

    	$$self.$inject_state = $$props => {
    		if ('src' in $$props) $$invalidate(0, src = $$props.src);
    		if ('size' in $$props) $$invalidate(1, size = $$props.size);
    		if ('style' in $$props) $$invalidate(2, style = $$props.style);
    		if ('color' in $$props) $$invalidate(3, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [src, size, style, color];
    }

    class Avatar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$w, create_fragment$A, safe_not_equal, { src: 0, size: 1, style: 2, color: 3 }, add_css$e);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Avatar",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get src() {
    		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var sanitize = (text) => {
        /^\s+$/.test(text)
            ? (text = "&lrm;")
            : (text = text
                .replaceAll(">", "&gt;")
                .replaceAll("<", "&lt;")
                .replaceAll("&lt;br /&gt;", "<br /><br />")
                .replaceAll("&gt;", ">")
                .replaceAll("&lt;", "<"));
        return text;
    };

    /* src/components/MessageBubble.svelte generated by Svelte v3.47.0 */
    const file$s = "src/components/MessageBubble.svelte";

    function add_css$d(target) {
    	append_styles(target, "svelte-13amlgp", "span.svelte-13amlgp a{text-decoration:underline}.msg-text:hover > span > span{color:rgb(var(--background));transition:color 0.2s ease-in-out}.highlight{background-color:rgb(var(--primary))}.msg.svelte-13amlgp{margin:7px;min-width:150px}.msg.bkd.svelte-13amlgp{align-self:flex-start;color:rgb(var(--body))}.msg.usr.svelte-13amlgp{align-self:flex-end;color:rgb(var(--background))}.msg.sent.svelte-13amlgp{filter:brightness(1.25)}.msg-text.svelte-13amlgp{width:fit-content;min-width:7em;padding:0.3em 1.2em;box-shadow:4px 4px 7px rgba(var(--shadow), 0.05);font-style:normal;word-break:normal;hyphens:auto;max-width:80%}.msg-text.usr.svelte-13amlgp{color:rgb(var(--background));background-color:rgb(var(--primary));border-radius:20px 0px 20px 20px;align-self:flex-end;text-align:right}.msg-text.bkd.svelte-13amlgp{background-color:rgb(var(--background));color:rgb(var(--body));border-radius:0px 20px 20px 20px;align-self:flex-start}.timestamp.svelte-13amlgp{font-style:normal;font-size:0.8em;width:100%;color:rgb(var(--body));margin-top:0.3em;font-size:x-small}.hoverable.svelte-13amlgp{cursor:pointer;transition:color 0.2s ease-in-out}.hoverable.bkd.svelte-13amlgp{transition:color 0.2s ease-in-out}.hoverable.bkd.svelte-13amlgp:hover{color:rgb(var(--primary))}.hoverable.usr.svelte-13amlgp:hover{color:rgb(var(--body))}.text-container.svelte-13amlgp{display:flex;flex-direction:column}.text-container.bkd.svelte-13amlgp{align-items:flex-end}.text-container.usr.svelte-13amlgp{align-items:flex-start}.container.svelte-13amlgp{display:flex;color:rgb(var(--body))}.container.bkd.svelte-13amlgp{flex-direction:row;margin-right:10px}.container.usr.svelte-13amlgp{flex-direction:row-reverse}.timestamp.bkd.svelte-13amlgp{text-align:left}.timestamp.usr.svelte-13amlgp{text-align:right}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZUJ1YmJsZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBaUZFLG1CQUFJLENBQUMsQUFBUSxDQUFDLEFBQUUsQ0FBQSxBQUNkLGVBQWUsQ0FBRSxTQUFTLEFBQzVCLENBQUEsQUFFUSw2QkFBNkIsQUFBRSxDQUFBLEFBQ3JDLEtBQUssQ0FBRSxJQUFJLElBQUksWUFBWSxDQUFDLENBQUMsQ0FDN0IsVUFBVSxDQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxBQUNwQyxDQUFBLEFBRVEsVUFBVSxBQUFFLENBQUEsQUFDbEIsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEFBQ3ZDLENBQUEsQUFFQSxJQUFJLGVBQUMsQ0FBQSxBQUNILE1BQU0sQ0FBRSxHQUFHLENBQ1gsU0FBUyxDQUFFLEtBQUssQUFDbEIsQ0FBQSxBQUVBLElBQUksSUFBSSxlQUFDLENBQUEsQUFDUCxVQUFVLENBQUUsVUFBVSxDQUN0QixLQUFLLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEFBQ3pCLENBQUEsQUFFQSxJQUFJLElBQUksZUFBQyxDQUFBLEFBQ1AsVUFBVSxDQUFFLFFBQVEsQ0FDcEIsS0FBSyxDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxBQUMvQixDQUFBLEFBRUEsSUFBSSxLQUFLLGVBQUMsQ0FBQSxBQUNSLE1BQU0sQ0FBRSxXQUFXLElBQUksQ0FBQyxBQUMxQixDQUFBLEFBRUEsU0FBUyxlQUFDLENBQUEsQUFDUixLQUFLLENBQUUsV0FBVyxDQUNsQixTQUFTLENBQUUsR0FBRyxDQUNkLE9BQU8sQ0FBRSxLQUFLLENBQUMsS0FBSyxDQUNwQixVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQ2pELFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsU0FBUyxDQUFFLEdBQUcsQUFDaEIsQ0FBQSxBQUVBLFNBQVMsSUFBSSxlQUFDLENBQUEsQUFDWixLQUFLLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQzdCLGdCQUFnQixDQUFFLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUNyQyxhQUFhLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUNqQyxVQUFVLENBQUUsUUFBUSxDQUNwQixVQUFVLENBQUUsS0FBSyxBQUNuQixDQUFBLEFBRUEsU0FBUyxJQUFJLGVBQUMsQ0FBQSxBQUNaLGdCQUFnQixDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUN4QyxLQUFLLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQ3ZCLGFBQWEsQ0FBRSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQ2pDLFVBQVUsQ0FBRSxVQUFVLEFBQ3hCLENBQUEsQUFFQSxVQUFVLGVBQUMsQ0FBQSxBQUNULFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFNBQVMsQ0FBRSxLQUFLLENBQ2hCLEtBQUssQ0FBRSxJQUFJLENBQ1gsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixVQUFVLENBQUUsS0FBSyxDQUNqQixTQUFTLENBQUUsT0FBTyxBQUNwQixDQUFBLEFBRUEsVUFBVSxlQUFDLENBQUEsQUFDVCxNQUFNLENBQUUsT0FBTyxDQUNmLFVBQVUsQ0FBRSxLQUFLLENBQUMsSUFBSSxDQUFDLFdBQVcsQUFDcEMsQ0FBQSxBQUVBLFVBQVUsSUFBSSxlQUFDLENBQUEsQUFDYixVQUFVLENBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLEFBQ3BDLENBQUEsQUFFQSxVQUFVLG1CQUFJLE1BQU0sQUFBQyxDQUFBLEFBQ25CLEtBQUssQ0FBRSxJQUFJLElBQUksU0FBUyxDQUFDLENBQUMsQUFDNUIsQ0FBQSxBQUVBLFVBQVUsbUJBQUksTUFBTSxBQUFDLENBQUEsQUFDbkIsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxBQUN6QixDQUFBLEFBRUEsZUFBZSxlQUFDLENBQUEsQUFDZCxPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUFNLEFBQ3hCLENBQUEsQUFFQSxlQUFlLElBQUksZUFBQyxDQUFBLEFBQ2xCLFdBQVcsQ0FBRSxRQUFRLEFBQ3ZCLENBQUEsQUFFQSxlQUFlLElBQUksZUFBQyxDQUFBLEFBQ2xCLFdBQVcsQ0FBRSxVQUFVLEFBQ3pCLENBQUEsQUFFQSxVQUFVLGVBQUMsQ0FBQSxBQUNULE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxBQUN6QixDQUFBLEFBRUEsVUFBVSxJQUFJLGVBQUMsQ0FBQSxBQUNiLGNBQWMsQ0FBRSxHQUFHLENBQ25CLFlBQVksQ0FBRSxJQUFJLEFBQ3BCLENBQUEsQUFFQSxVQUFVLElBQUksZUFBQyxDQUFBLEFBQ2IsY0FBYyxDQUFFLFdBQVcsQUFDN0IsQ0FBQSxBQUVBLFVBQVUsSUFBSSxlQUFDLENBQUEsQUFDYixVQUFVLENBQUUsSUFBSSxBQUNsQixDQUFBLEFBRUEsVUFBVSxJQUFJLGVBQUMsQ0FBQSxBQUNiLFVBQVUsQ0FBRSxLQUFLLEFBQ25CLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVzc2FnZUJ1YmJsZS5zdmVsdGUiXX0= */");
    }

    function create_fragment$z(ctx) {
    	let div5;
    	let div4;
    	let avatar;
    	let t0;
    	let div3;
    	let div0;
    	let span;
    	let raw_value = sanitize(/*highlightedText*/ ctx[6]) + "";
    	let t1;
    	let div1;
    	let t2;
    	let t3;
    	let div2;
    	let current;
    	let mounted;
    	let dispose;

    	avatar = new Avatar({
    			props: {
    				src: /*speaker*/ ctx[0] === "backend"
    				? /*server_avatar*/ ctx[4]
    				: /*user_avatar*/ ctx[5],
    				size: "32px",
    				style: "align-self: flex-start; margin: 0px 10px;"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			create_component(avatar.$$.fragment);
    			t0 = space();
    			div3 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t1 = space();
    			div1 = element("div");
    			t2 = text(/*timestamp*/ ctx[1]);
    			t3 = space();
    			div2 = element("div");
    			attr_dev(span, "class", "svelte-13amlgp");
    			add_location(span, file$s, 56, 8, 1530);
    			attr_dev(div0, "class", "msg-text svelte-13amlgp");
    			toggle_class(div0, "hoverable", /*clickable*/ ctx[3]);
    			toggle_class(div0, "bkd", /*speaker*/ ctx[0] === "backend");
    			toggle_class(div0, "usr", /*speaker*/ ctx[0] === "user");
    			add_location(div0, file$s, 49, 6, 1350);
    			attr_dev(div1, "class", "timestamp svelte-13amlgp");
    			toggle_class(div1, "bkd", /*speaker*/ ctx[0] === "backend");
    			toggle_class(div1, "usr", /*speaker*/ ctx[0] === "user");
    			add_location(div1, file$s, 60, 6, 1616);
    			add_location(div2, file$s, 67, 6, 1775);
    			attr_dev(div3, "class", "text-container svelte-13amlgp");
    			toggle_class(div3, "bkd", /*speaker*/ ctx[0] === "backend");
    			toggle_class(div3, "usr", /*speaker*/ ctx[0] === "user");
    			add_location(div3, file$s, 44, 4, 1227);
    			attr_dev(div4, "class", "container svelte-13amlgp");
    			toggle_class(div4, "bkd", /*speaker*/ ctx[0] === "backend");
    			toggle_class(div4, "usr", /*speaker*/ ctx[0] === "user");
    			add_location(div4, file$s, 33, 2, 961);
    			attr_dev(div5, "class", "msg svelte-13amlgp");
    			toggle_class(div5, "bkd", /*speaker*/ ctx[0] === "backend");
    			toggle_class(div5, "usr", /*speaker*/ ctx[0] === "user");
    			toggle_class(div5, "sent", !/*is_sent*/ ctx[2]);
    			add_location(div5, file$s, 27, 0, 845);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			mount_component(avatar, div4, null);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, span);
    			span.innerHTML = raw_value;
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const avatar_changes = {};

    			if (dirty & /*speaker, server_avatar, user_avatar*/ 49) avatar_changes.src = /*speaker*/ ctx[0] === "backend"
    			? /*server_avatar*/ ctx[4]
    			: /*user_avatar*/ ctx[5];

    			avatar.$set(avatar_changes);
    			if ((!current || dirty & /*highlightedText*/ 64) && raw_value !== (raw_value = sanitize(/*highlightedText*/ ctx[6]) + "")) span.innerHTML = raw_value;
    			if (dirty & /*clickable*/ 8) {
    				toggle_class(div0, "hoverable", /*clickable*/ ctx[3]);
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div0, "bkd", /*speaker*/ ctx[0] === "backend");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div0, "usr", /*speaker*/ ctx[0] === "user");
    			}

    			if (!current || dirty & /*timestamp*/ 2) set_data_dev(t2, /*timestamp*/ ctx[1]);

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div1, "bkd", /*speaker*/ ctx[0] === "backend");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div1, "usr", /*speaker*/ ctx[0] === "user");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div3, "bkd", /*speaker*/ ctx[0] === "backend");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div3, "usr", /*speaker*/ ctx[0] === "user");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div4, "bkd", /*speaker*/ ctx[0] === "backend");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div4, "usr", /*speaker*/ ctx[0] === "user");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div5, "bkd", /*speaker*/ ctx[0] === "backend");
    			}

    			if (dirty & /*speaker*/ 1) {
    				toggle_class(div5, "usr", /*speaker*/ ctx[0] === "user");
    			}

    			if (dirty & /*is_sent*/ 4) {
    				toggle_class(div5, "sent", !/*is_sent*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(avatar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(avatar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(avatar);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MessageBubble', slots, []);
    	let { speaker } = $$props;
    	let { text = "" } = $$props;
    	let { timestamp = "" } = $$props;
    	let { is_sent = true } = $$props;
    	let { clickable = false } = $$props;
    	let { server_avatar = "" } = $$props;
    	let { user_avatar = "" } = $$props;
    	let { searchInput = "" } = $$props;
    	let highlightedText = "";

    	const escapeRegExp = text => {
    		return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    	};

    	const textHighlighting = searchInput => {
    		if (searchInput) {
    			const regex = new RegExp(escapeRegExp(searchInput), "gi");
    			const cleanText = text.replace(/(<mark class="highlight">|<\/mark>)/gim, "");
    			return cleanText.replace(regex, "<span class='highlight' >$&</span>");
    		} else {
    			return text;
    		}
    	};

    	const writable_props = [
    		'speaker',
    		'text',
    		'timestamp',
    		'is_sent',
    		'clickable',
    		'server_avatar',
    		'user_avatar',
    		'searchInput'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageBubble> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('speaker' in $$props) $$invalidate(0, speaker = $$props.speaker);
    		if ('text' in $$props) $$invalidate(7, text = $$props.text);
    		if ('timestamp' in $$props) $$invalidate(1, timestamp = $$props.timestamp);
    		if ('is_sent' in $$props) $$invalidate(2, is_sent = $$props.is_sent);
    		if ('clickable' in $$props) $$invalidate(3, clickable = $$props.clickable);
    		if ('server_avatar' in $$props) $$invalidate(4, server_avatar = $$props.server_avatar);
    		if ('user_avatar' in $$props) $$invalidate(5, user_avatar = $$props.user_avatar);
    		if ('searchInput' in $$props) $$invalidate(8, searchInput = $$props.searchInput);
    	};

    	$$self.$capture_state = () => ({
    		Avatar,
    		sanitize,
    		speaker,
    		text,
    		timestamp,
    		is_sent,
    		clickable,
    		server_avatar,
    		user_avatar,
    		searchInput,
    		highlightedText,
    		escapeRegExp,
    		textHighlighting
    	});

    	$$self.$inject_state = $$props => {
    		if ('speaker' in $$props) $$invalidate(0, speaker = $$props.speaker);
    		if ('text' in $$props) $$invalidate(7, text = $$props.text);
    		if ('timestamp' in $$props) $$invalidate(1, timestamp = $$props.timestamp);
    		if ('is_sent' in $$props) $$invalidate(2, is_sent = $$props.is_sent);
    		if ('clickable' in $$props) $$invalidate(3, clickable = $$props.clickable);
    		if ('server_avatar' in $$props) $$invalidate(4, server_avatar = $$props.server_avatar);
    		if ('user_avatar' in $$props) $$invalidate(5, user_avatar = $$props.user_avatar);
    		if ('searchInput' in $$props) $$invalidate(8, searchInput = $$props.searchInput);
    		if ('highlightedText' in $$props) $$invalidate(6, highlightedText = $$props.highlightedText);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*searchInput*/ 256) {
    			$$invalidate(6, highlightedText = textHighlighting(searchInput));
    		}
    	};

    	return [
    		speaker,
    		timestamp,
    		is_sent,
    		clickable,
    		server_avatar,
    		user_avatar,
    		highlightedText,
    		text,
    		searchInput,
    		click_handler
    	];
    }

    class MessageBubble extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$v,
    			create_fragment$z,
    			safe_not_equal,
    			{
    				speaker: 0,
    				text: 7,
    				timestamp: 1,
    				is_sent: 2,
    				clickable: 3,
    				server_avatar: 4,
    				user_avatar: 5,
    				searchInput: 8
    			},
    			add_css$d
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MessageBubble",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*speaker*/ ctx[0] === undefined && !('speaker' in props)) {
    			console.warn("<MessageBubble> was created without expected prop 'speaker'");
    		}
    	}

    	get speaker() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set speaker(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get timestamp() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set timestamp(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get is_sent() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set is_sent(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clickable() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clickable(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get server_avatar() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set server_avatar(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get user_avatar() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set user_avatar(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get searchInput() {
    		throw new Error("<MessageBubble>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchInput(value) {
    		throw new Error("<MessageBubble>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/MessageInfo.svelte generated by Svelte v3.47.0 */

    const file$r = "src/components/MessageInfo.svelte";

    function add_css$c(target) {
    	append_styles(target, "svelte-1rnqv31", ".msg.svelte-1rnqv31{min-width:150px;border-bottom:1px solid rgb(var(--primary));width:80%;margin:1em auto}.msg-text.svelte-1rnqv31{width:fit-content;min-width:7em;font-style:normal;word-break:normal;hyphens:auto;font-size:small;text-align:center}.container.svelte-1rnqv31{display:flex;flex-direction:column;align-items:center}.timestamp.svelte-1rnqv31{font-style:normal;font-size:0.8em;width:100%;color:rgb(var(--body));font-size:x-small}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWVzc2FnZUluZm8uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFCRSxJQUFJLGVBQUMsQ0FBQSxBQUNILFNBQVMsQ0FBRSxLQUFLLENBQ2hCLGFBQWEsQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUM1QyxLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLENBQUMsSUFBSSxBQUNsQixDQUFBLEFBQ0EsU0FBUyxlQUFDLENBQUEsQUFDUixLQUFLLENBQUUsV0FBVyxDQUNsQixTQUFTLENBQUUsR0FBRyxDQUNkLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsU0FBUyxDQUFFLEtBQUssQ0FDaEIsVUFBVSxDQUFFLE1BQU0sQUFDcEIsQ0FBQSxBQUVBLFVBQVUsZUFBQyxDQUFBLEFBQ1QsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsTUFBTSxBQUNyQixDQUFBLEFBRUEsVUFBVSxlQUFDLENBQUEsQUFDVCxVQUFVLENBQUUsTUFBTSxDQUNsQixTQUFTLENBQUUsS0FBSyxDQUNoQixLQUFLLENBQUUsSUFBSSxDQUNYLEtBQUssQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQ0FDdkIsU0FBUyxDQUFFLE9BQU8sQUFDcEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNZXNzYWdlSW5mby5zdmVsdGUiXX0= */");
    }

    // (10:4) {#if timestamp}
    function create_if_block$b(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*timestamp*/ ctx[0]);
    			attr_dev(div, "class", "timestamp svelte-1rnqv31");
    			set_style(div, "text-align", "center");
    			add_location(div, file$r, 10, 6, 175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*timestamp*/ 1) set_data_dev(t, /*timestamp*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(10:4) {#if timestamp}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
    	let if_block = /*timestamp*/ ctx[0] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "msg-text svelte-1rnqv31");
    			add_location(div0, file$r, 5, 4, 99);
    			add_location(div1, file$r, 15, 4, 274);
    			attr_dev(div2, "class", "container svelte-1rnqv31");
    			add_location(div2, file$r, 4, 2, 71);
    			attr_dev(div3, "class", "msg svelte-1rnqv31");
    			add_location(div3, file$r, 3, 0, 51);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append_dev(div2, t0);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (/*timestamp*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(div2, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MessageInfo', slots, ['default']);
    	let { timestamp } = $$props;
    	const writable_props = ['timestamp'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageInfo> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('timestamp' in $$props) $$invalidate(0, timestamp = $$props.timestamp);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ timestamp });

    	$$self.$inject_state = $$props => {
    		if ('timestamp' in $$props) $$invalidate(0, timestamp = $$props.timestamp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [timestamp, $$scope, slots];
    }

    class MessageInfo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$u, create_fragment$y, safe_not_equal, { timestamp: 0 }, add_css$c);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MessageInfo",
    			options,
    			id: create_fragment$y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*timestamp*/ ctx[0] === undefined && !('timestamp' in props)) {
    			console.warn("<MessageInfo> was created without expected prop 'timestamp'");
    		}
    	}

    	get timestamp() {
    		throw new Error("<MessageInfo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set timestamp(value) {
    		throw new Error("<MessageInfo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Chat.svelte generated by Svelte v3.47.0 */
    const file$q = "src/components/Chat.svelte";

    function add_css$b(target) {
    	append_styles(target, "svelte-1ejliju", ".chat-container.svelte-1ejliju{display:flex;flex-direction:column;height:100%;justify-content:space-between}.header-container.svelte-1ejliju{display:flex;flex-direction:column;border-bottom:1px solid rgba(var(--body), 0.2);margin-bottom:0.5em;padding:0.5em;color:rgba(var(--body))}.msgs-container.svelte-1ejliju{flex:8 8 80%;scroll-behavior:auto;overflow-y:auto;width:100%}.msgs.svelte-1ejliju{height:0px;flex-direction:column;width:inherit}.chat-media.svelte-1ejliju{width:100%;border-radius:1em}.chat-header.svelte-1ejliju{margin:0 0.5em 0.5em 0.5em;display:flex;flex-direction:column;align-items:stretch}.search.svelte-1ejliju{display:flex;margin-left:1em;margin-right:calc(1em - 8px);margin-top:0.5em}.search-field.svelte-1ejliju{flex:1 1;border-radius:10px;box-shadow:rgba(var(--shadow, 0.1), 0.2) 0px 7px 29px 0px;outline:none;border:0;margin-right:0.5em;padding:0.25em 0.5em}.fullscreen-hide.svelte-1ejliju{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ2hhdC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK0xFLGVBQWUsZUFBQyxDQUFBLEFBQ2QsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixNQUFNLENBQUUsSUFBSSxDQUNaLGVBQWUsQ0FBRSxhQUFhLEFBQ2hDLENBQUEsQUFFQSxpQkFBaUIsZUFBQyxDQUFBLEFBQ2hCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsYUFBYSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQy9DLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsS0FBSyxDQUFFLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxBQUMxQixDQUFBLEFBRUEsZUFBZSxlQUFDLENBQUEsQUFDZCxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQ2IsZUFBZSxDQUFFLElBQUksQ0FDckIsVUFBVSxDQUFFLElBQUksQ0FDaEIsS0FBSyxDQUFFLElBQUksQUFDYixDQUFBLEFBRUEsS0FBSyxlQUFDLENBQUEsQUFDSixNQUFNLENBQUUsR0FBRyxDQUNYLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLEtBQUssQ0FBRSxPQUFPLEFBQ2hCLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLEtBQUssQ0FBRSxJQUFJLENBQ1gsYUFBYSxDQUFFLEdBQUcsQUFDcEIsQ0FBQSxBQUVBLFlBQVksZUFBQyxDQUFBLEFBQ1gsTUFBTSxDQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FDM0IsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsT0FBTyxBQUN0QixDQUFBLEFBRUEsT0FBTyxlQUFDLENBQUEsQUFDTixPQUFPLENBQUUsSUFBSSxDQUNiLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFlBQVksQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQzdCLFVBQVUsQ0FBRSxLQUFLLEFBQ25CLENBQUEsQUFFQSxhQUFhLGVBQUMsQ0FBQSxBQUNaLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUNULGFBQWEsQ0FBRSxJQUFJLENBQ25CLFVBQVUsQ0FBRSxLQUFLLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUMxRCxPQUFPLENBQUUsSUFBSSxDQUNiLE1BQU0sQ0FBRSxDQUFDLENBQ1QsWUFBWSxDQUFFLEtBQUssQ0FDbkIsT0FBTyxDQUFFLE1BQU0sQ0FBQyxLQUFLLEFBQ3ZCLENBQUEsQUFFQSxnQkFBZ0IsZUFBQyxDQUFBLEFBQ2YsT0FBTyxDQUFFLElBQUksQUFDZixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkNoYXQuc3ZlbHRlIl19 */");
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[35] = list[i].timestamp;
    	child_ctx[36] = list[i].text;
    	child_ctx[37] = list[i].type;
    	child_ctx[38] = list[i].media;
    	child_ctx[39] = list[i].visible;
    	child_ctx[40] = list[i].speaker;
    	child_ctx[41] = list[i].isSent;
    	child_ctx[42] = list[i].url;
    	return child_ctx;
    }

    // (123:28) 
    function create_if_block_2$3(ctx) {
    	let messagebubble;
    	let updating_server_avatar;
    	let updating_user_avatar;
    	let current;

    	function messagebubble_server_avatar_binding(value) {
    		/*messagebubble_server_avatar_binding*/ ctx[21](value);
    	}

    	function messagebubble_user_avatar_binding(value) {
    		/*messagebubble_user_avatar_binding*/ ctx[22](value);
    	}

    	function click_handler() {
    		return /*click_handler*/ ctx[23](/*url*/ ctx[42]);
    	}

    	let messagebubble_props = {
    		searchInput: /*searchInput*/ ctx[7],
    		text: /*text*/ ctx[36],
    		speaker: /*speaker*/ ctx[40],
    		timestamp: moment(/*timestamp*/ ctx[35]).fromNow(),
    		is_sent: /*isSent*/ ctx[41],
    		clickable: !!/*url*/ ctx[42]
    	};

    	if (/*server_avatar*/ ctx[1] !== void 0) {
    		messagebubble_props.server_avatar = /*server_avatar*/ ctx[1];
    	}

    	if (/*user_avatar*/ ctx[2] !== void 0) {
    		messagebubble_props.user_avatar = /*user_avatar*/ ctx[2];
    	}

    	messagebubble = new MessageBubble({
    			props: messagebubble_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(messagebubble, 'server_avatar', messagebubble_server_avatar_binding));
    	binding_callbacks.push(() => bind(messagebubble, 'user_avatar', messagebubble_user_avatar_binding));

    	messagebubble.$on("click", function () {
    		if (is_function(/*url*/ ctx[42] && click_handler)) (/*url*/ ctx[42] && click_handler).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(messagebubble.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(messagebubble, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const messagebubble_changes = {};
    			if (dirty[0] & /*searchInput*/ 128) messagebubble_changes.searchInput = /*searchInput*/ ctx[7];
    			if (dirty[0] & /*messagesToShow*/ 1024) messagebubble_changes.text = /*text*/ ctx[36];
    			if (dirty[0] & /*messagesToShow*/ 1024) messagebubble_changes.speaker = /*speaker*/ ctx[40];
    			if (dirty[0] & /*messagesToShow*/ 1024) messagebubble_changes.timestamp = moment(/*timestamp*/ ctx[35]).fromNow();
    			if (dirty[0] & /*messagesToShow*/ 1024) messagebubble_changes.is_sent = /*isSent*/ ctx[41];
    			if (dirty[0] & /*messagesToShow*/ 1024) messagebubble_changes.clickable = !!/*url*/ ctx[42];

    			if (!updating_server_avatar && dirty[0] & /*server_avatar*/ 2) {
    				updating_server_avatar = true;
    				messagebubble_changes.server_avatar = /*server_avatar*/ ctx[1];
    				add_flush_callback(() => updating_server_avatar = false);
    			}

    			if (!updating_user_avatar && dirty[0] & /*user_avatar*/ 4) {
    				updating_user_avatar = true;
    				messagebubble_changes.user_avatar = /*user_avatar*/ ctx[2];
    				add_flush_callback(() => updating_user_avatar = false);
    			}

    			messagebubble.$set(messagebubble_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(messagebubble.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(messagebubble.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(messagebubble, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(123:28) ",
    		ctx
    	});

    	return block;
    }

    // (114:35) 
    function create_if_block_1$5(ctx) {
    	let messageinfo;
    	let current;

    	messageinfo = new MessageInfo({
    			props: {
    				timestamp: /*timestamp*/ ctx[35] && moment(/*timestamp*/ ctx[35]).fromNow(),
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(messageinfo.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(messageinfo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const messageinfo_changes = {};
    			if (dirty[0] & /*messagesToShow*/ 1024) messageinfo_changes.timestamp = /*timestamp*/ ctx[35] && moment(/*timestamp*/ ctx[35]).fromNow();

    			if (dirty[0] & /*messagesToShow, $chatScrollDown*/ 1280 | dirty[1] & /*$$scope*/ 16384) {
    				messageinfo_changes.$$scope = { dirty, ctx };
    			}

    			messageinfo.$set(messageinfo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(messageinfo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(messageinfo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(messageinfo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(114:35) ",
    		ctx
    	});

    	return block;
    }

    // (110:8) {#if type === "info"}
    function create_if_block$a(ctx) {
    	let messageinfo;
    	let current;

    	messageinfo = new MessageInfo({
    			props: {
    				timestamp: /*timestamp*/ ctx[35] && moment(/*timestamp*/ ctx[35]).fromNow(),
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(messageinfo.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(messageinfo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const messageinfo_changes = {};
    			if (dirty[0] & /*messagesToShow*/ 1024) messageinfo_changes.timestamp = /*timestamp*/ ctx[35] && moment(/*timestamp*/ ctx[35]).fromNow();

    			if (dirty[0] & /*messagesToShow*/ 1024 | dirty[1] & /*$$scope*/ 16384) {
    				messageinfo_changes.$$scope = { dirty, ctx };
    			}

    			messageinfo.$set(messageinfo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(messageinfo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(messageinfo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(messageinfo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(110:8) {#if type === \\\"info\\\"}",
    		ctx
    	});

    	return block;
    }

    // (115:10) <MessageInfo timestamp={timestamp && moment(timestamp).fromNow()}>
    function create_default_slot_1$1(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*media*/ ctx[38])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "image");
    			attr_dev(img, "class", "chat-media svelte-1ejliju");
    			add_location(img, file$q, 115, 12, 3942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "load", /*load_handler*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*messagesToShow*/ 1024 && !src_url_equal(img.src, img_src_value = /*media*/ ctx[38])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(115:10) <MessageInfo timestamp={timestamp && moment(timestamp).fromNow()}>",
    		ctx
    	});

    	return block;
    }

    // (111:10) <MessageInfo timestamp={timestamp && moment(timestamp).fromNow()}>
    function create_default_slot$6(ctx) {
    	let html_tag;
    	let raw_value = sanitize(/*text*/ ctx[36]) + "";
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_tag = new HtmlTag();
    			html_anchor = empty();
    			html_tag.a = html_anchor;
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(raw_value, target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*messagesToShow*/ 1024 && raw_value !== (raw_value = sanitize(/*text*/ ctx[36]) + "")) html_tag.p(raw_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(111:10) <MessageInfo timestamp={timestamp && moment(timestamp).fromNow()}>",
    		ctx
    	});

    	return block;
    }

    // (109:6) {#each messagesToShow as { timestamp, text, type, media, visible, speaker, isSent, url }}
    function create_each_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_if_block_1$5, create_if_block_2$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*type*/ ctx[37] === "info") return 0;
    		if (/*type*/ ctx[37] === "media") return 1;
    		if (!!/*visible*/ ctx[39]) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(109:6) {#each messagesToShow as { timestamp, text, type, media, visible, speaker, isSent, url }}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div8;
    	let div4;
    	let div3;
    	let div1;
    	let avatar;
    	let t0;
    	let div0;
    	let t1;
    	let t2;
    	let div2;
    	let input;
    	let input_placeholder_value;
    	let t3;
    	let div7;
    	let div6;
    	let t4;
    	let div5;
    	let t5;
    	let inputcontainer;
    	let updating_asr;
    	let updating_opmode;
    	let updating_language;
    	let current;
    	let mounted;
    	let dispose;

    	avatar = new Avatar({
    			props: {
    				src: /*header_avatar*/ ctx[6],
    				size: "1.0em",
    				style: "margin-right: 1em;"
    			},
    			$$inline: true
    		});

    	let each_value = /*messagesToShow*/ ctx[10];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	function inputcontainer_asr_binding(value) {
    		/*inputcontainer_asr_binding*/ ctx[25](value);
    	}

    	function inputcontainer_opmode_binding(value) {
    		/*inputcontainer_opmode_binding*/ ctx[26](value);
    	}

    	function inputcontainer_language_binding(value) {
    		/*inputcontainer_language_binding*/ ctx[27](value);
    	}

    	let inputcontainer_props = {};

    	if (/*asr*/ ctx[0] !== void 0) {
    		inputcontainer_props.asr = /*asr*/ ctx[0];
    	}

    	if (/*opmode*/ ctx[3] !== void 0) {
    		inputcontainer_props.opmode = /*opmode*/ ctx[3];
    	}

    	if (/*language*/ ctx[4] !== void 0) {
    		inputcontainer_props.language = /*language*/ ctx[4];
    	}

    	inputcontainer = new InputContainer({
    			props: inputcontainer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(inputcontainer, 'asr', inputcontainer_asr_binding));
    	binding_callbacks.push(() => bind(inputcontainer, 'opmode', inputcontainer_opmode_binding));
    	binding_callbacks.push(() => bind(inputcontainer, 'language', inputcontainer_language_binding));
    	inputcontainer.$on("userInput", /*handleUserInput*/ ctx[17]);
    	inputcontainer.$on("optionSelected", /*optionSelected*/ ctx[14]);
    	inputcontainer.$on("skip", /*skip_handler*/ ctx[28]);
    	inputcontainer.$on("replay", /*replay_handler*/ ctx[29]);
    	inputcontainer.$on("processUserInput", /*processUserInput*/ ctx[15]);

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div1 = element("div");
    			create_component(avatar.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			t1 = text(/*name*/ ctx[5]);
    			t2 = space();
    			div2 = element("div");
    			input = element("input");
    			t3 = space();
    			div7 = element("div");
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t4 = space();
    			div5 = element("div");
    			t5 = space();
    			create_component(inputcontainer.$$.fragment);
    			set_style(div0, "font-size", "small");
    			add_location(div0, file$q, 90, 8, 3119);
    			set_style(div1, "display", "flex");
    			set_style(div1, "margin-bottom", "0.5em");
    			attr_dev(div1, "class", "hide-phone");
    			add_location(div1, file$q, 88, 6, 2962);
    			attr_dev(input, "class", "search-field svelte-1ejliju");
    			attr_dev(input, "placeholder", input_placeholder_value = /*$_*/ ctx[12]("chat-component.search-bar.placeholder"));
    			attr_dev(input, "type", "search");
    			add_location(input, file$q, 93, 8, 3211);
    			attr_dev(div2, "class", "search svelte-1ejliju");
    			add_location(div2, file$q, 92, 6, 3182);
    			attr_dev(div3, "class", "chat-header svelte-1ejliju");
    			add_location(div3, file$q, 87, 4, 2930);
    			attr_dev(div4, "class", "header-container svelte-1ejliju");
    			toggle_class(div4, "fullscreen-hide", /*$isFullScreen*/ ctx[11]);
    			add_location(div4, file$q, 86, 2, 2857);
    			set_style(div5, "height", "1px");
    			add_location(div5, file$q, 136, 6, 4549);
    			attr_dev(div6, "class", "msgs svelte-1ejliju");
    			add_location(div6, file$q, 107, 4, 3535);
    			attr_dev(div7, "class", "msgs-container svelte-1ejliju");
    			toggle_class(div7, "fullscreen-hide", /*$isFullScreen*/ ctx[11]);
    			add_location(div7, file$q, 102, 2, 3422);
    			attr_dev(div8, "class", "svelte-1ejliju");
    			toggle_class(div8, "chat-container", !/*$isFullScreen*/ ctx[11]);
    			add_location(div8, file$q, 85, 0, 2811);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			mount_component(avatar, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, input);
    			set_input_value(input, /*searchInput*/ ctx[7]);
    			append_dev(div8, t3);
    			append_dev(div8, div7);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div6, t4);
    			append_dev(div6, div5);
    			/*div7_binding*/ ctx[24](div7);
    			append_dev(div8, t5);
    			mount_component(inputcontainer, div8, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[19]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const avatar_changes = {};
    			if (dirty[0] & /*header_avatar*/ 64) avatar_changes.src = /*header_avatar*/ ctx[6];
    			avatar.$set(avatar_changes);
    			if (!current || dirty[0] & /*name*/ 32) set_data_dev(t1, /*name*/ ctx[5]);

    			if (!current || dirty[0] & /*$_*/ 4096 && input_placeholder_value !== (input_placeholder_value = /*$_*/ ctx[12]("chat-component.search-bar.placeholder"))) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty[0] & /*searchInput*/ 128) {
    				set_input_value(input, /*searchInput*/ ctx[7]);
    			}

    			if (dirty[0] & /*$isFullScreen*/ 2048) {
    				toggle_class(div4, "fullscreen-hide", /*$isFullScreen*/ ctx[11]);
    			}

    			if (dirty[0] & /*messagesToShow, $chatScrollDown, searchInput, server_avatar, user_avatar, handleMsgPlay*/ 66950) {
    				each_value = /*messagesToShow*/ ctx[10];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div6, t4);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty[0] & /*$isFullScreen*/ 2048) {
    				toggle_class(div7, "fullscreen-hide", /*$isFullScreen*/ ctx[11]);
    			}

    			const inputcontainer_changes = {};

    			if (!updating_asr && dirty[0] & /*asr*/ 1) {
    				updating_asr = true;
    				inputcontainer_changes.asr = /*asr*/ ctx[0];
    				add_flush_callback(() => updating_asr = false);
    			}

    			if (!updating_opmode && dirty[0] & /*opmode*/ 8) {
    				updating_opmode = true;
    				inputcontainer_changes.opmode = /*opmode*/ ctx[3];
    				add_flush_callback(() => updating_opmode = false);
    			}

    			if (!updating_language && dirty[0] & /*language*/ 16) {
    				updating_language = true;
    				inputcontainer_changes.language = /*language*/ ctx[4];
    				add_flush_callback(() => updating_language = false);
    			}

    			inputcontainer.$set(inputcontainer_changes);

    			if (dirty[0] & /*$isFullScreen*/ 2048) {
    				toggle_class(div8, "chat-container", !/*$isFullScreen*/ ctx[11]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(avatar.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(inputcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(avatar.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(inputcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(avatar);
    			destroy_each(each_blocks, detaching);
    			/*div7_binding*/ ctx[24](null);
    			destroy_component(inputcontainer);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let messagesToShow;
    	let $chat_store;
    	let $user_input_value;
    	let $chatScrollDown;
    	let $isFullScreen;
    	let $_;
    	validate_store(chat_store, 'chat_store');
    	component_subscribe($$self, chat_store, $$value => $$invalidate(18, $chat_store = $$value));
    	validate_store(user_input_value, 'user_input_value');
    	component_subscribe($$self, user_input_value, $$value => $$invalidate(31, $user_input_value = $$value));
    	validate_store(chatScrollDown, 'chatScrollDown');
    	component_subscribe($$self, chatScrollDown, $$value => $$invalidate(8, $chatScrollDown = $$value));
    	validate_store(isFullScreen, 'isFullScreen');
    	component_subscribe($$self, isFullScreen, $$value => $$invalidate(11, $isFullScreen = $$value));
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(12, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Chat', slots, []);
    	let { asr = false } = $$props;
    	let { name } = $$props;
    	let { server_avatar = "" } = $$props;
    	let { user_avatar = "" } = $$props;
    	let { header_avatar = "" } = $$props;
    	let { opmode = "" } = $$props;
    	let { language = undefined } = $$props;
    	const dispatch = createEventDispatcher();
    	let scrollableChat;
    	let isAsrCancellable = false;

    	function scrollBottomChat() {
    		if (scrollableChat && scrollableChat.scrollTop < scrollableChat.scrollHeight) {
    			$$invalidate(9, scrollableChat.scrollTop = scrollableChat.scrollHeight + 1000, scrollableChat);
    		}
    	}

    	onMount(async () => {
    		// update the chat every second
    		// initial scroll when fonts are loaded
    		await document.fonts.ready.then(() => {
    			scrollBottomChat();

    			// change scroll behaviour to smooth
    			scrollableChat.style.scrollBehavior !== "smooth" && $$invalidate(9, scrollableChat.style.scrollBehavior = "smooth", scrollableChat);

    			setTimeout(
    				() => {
    					scrollBottomChat();
    				},
    				100
    			);
    		});

    		// keep track of current chat length
    		let chatcount = $chat_store.length;

    		chat_store.subscribe(new_chat => {
    			// // Scroll if chat is different
    			if (chatcount !== $chat_store.length && $chat_store[$chat_store.length - 1]?.visible) {
    				set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    				chatcount = new_chat.length;
    			}
    		});
    	});

    	const optionSelected = ev => {
    		const text = ev.detail.text;
    		dispatch("userInput", text);
    		set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	};

    	let timer = undefined;

    	const handleProgressbarCancel = () => {
    		isAsrCancellable = false;
    		timer && clearTimeout(timer);
    	};

    	const processUserInput = () => {
    		// No spaces allowed
    		if ($user_input_value && !(/^\s+$/).test($user_input_value)) {
    			dispatch("userInput", $user_input_value);
    		}

    		set_store_value(user_input_value, $user_input_value = "", $user_input_value);
    		handleProgressbarCancel();
    	};

    	const handleMsgPlay = url => {
    		dispatch("play", url);
    	};

    	const handleUserInput = ev => {
    		dispatch("userInput", ev.detail);
    	};

    	let searchInput = "";

    	const writable_props = [
    		'asr',
    		'name',
    		'server_avatar',
    		'user_avatar',
    		'header_avatar',
    		'opmode',
    		'language'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chat> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		searchInput = this.value;
    		$$invalidate(7, searchInput);
    	}

    	const load_handler = () => void tick().then(() => set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown));

    	function messagebubble_server_avatar_binding(value) {
    		server_avatar = value;
    		$$invalidate(1, server_avatar);
    	}

    	function messagebubble_user_avatar_binding(value) {
    		user_avatar = value;
    		$$invalidate(2, user_avatar);
    	}

    	const click_handler = url => handleMsgPlay(url);

    	function div7_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			scrollableChat = $$value;
    			$$invalidate(9, scrollableChat);
    		});
    	}

    	function inputcontainer_asr_binding(value) {
    		asr = value;
    		$$invalidate(0, asr);
    	}

    	function inputcontainer_opmode_binding(value) {
    		opmode = value;
    		$$invalidate(3, opmode);
    	}

    	function inputcontainer_language_binding(value) {
    		language = value;
    		$$invalidate(4, language);
    	}

    	const skip_handler = () => dispatch("skip");
    	const replay_handler = () => dispatch("replay");

    	$$self.$$set = $$props => {
    		if ('asr' in $$props) $$invalidate(0, asr = $$props.asr);
    		if ('name' in $$props) $$invalidate(5, name = $$props.name);
    		if ('server_avatar' in $$props) $$invalidate(1, server_avatar = $$props.server_avatar);
    		if ('user_avatar' in $$props) $$invalidate(2, user_avatar = $$props.user_avatar);
    		if ('header_avatar' in $$props) $$invalidate(6, header_avatar = $$props.header_avatar);
    		if ('opmode' in $$props) $$invalidate(3, opmode = $$props.opmode);
    		if ('language' in $$props) $$invalidate(4, language = $$props.language);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		tick,
    		moment,
    		InputContainer,
    		MessageBubble,
    		Avatar,
    		MessageInfo,
    		chat_store,
    		chatScrollDown,
    		user_input_value,
    		isFullScreen,
    		sanitize,
    		_: Y,
    		asr,
    		name,
    		server_avatar,
    		user_avatar,
    		header_avatar,
    		opmode,
    		language,
    		dispatch,
    		scrollableChat,
    		isAsrCancellable,
    		scrollBottomChat,
    		optionSelected,
    		timer,
    		handleProgressbarCancel,
    		processUserInput,
    		handleMsgPlay,
    		handleUserInput,
    		searchInput,
    		messagesToShow,
    		$chat_store,
    		$user_input_value,
    		$chatScrollDown,
    		$isFullScreen,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('asr' in $$props) $$invalidate(0, asr = $$props.asr);
    		if ('name' in $$props) $$invalidate(5, name = $$props.name);
    		if ('server_avatar' in $$props) $$invalidate(1, server_avatar = $$props.server_avatar);
    		if ('user_avatar' in $$props) $$invalidate(2, user_avatar = $$props.user_avatar);
    		if ('header_avatar' in $$props) $$invalidate(6, header_avatar = $$props.header_avatar);
    		if ('opmode' in $$props) $$invalidate(3, opmode = $$props.opmode);
    		if ('language' in $$props) $$invalidate(4, language = $$props.language);
    		if ('scrollableChat' in $$props) $$invalidate(9, scrollableChat = $$props.scrollableChat);
    		if ('isAsrCancellable' in $$props) isAsrCancellable = $$props.isAsrCancellable;
    		if ('timer' in $$props) timer = $$props.timer;
    		if ('searchInput' in $$props) $$invalidate(7, searchInput = $$props.searchInput);
    		if ('messagesToShow' in $$props) $$invalidate(10, messagesToShow = $$props.messagesToShow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$chatScrollDown*/ 256) {
    			if ($chatScrollDown) {
    				// TODO: fix
    				(setTimeout(scrollBottomChat, 50), set_store_value(chatScrollDown, $chatScrollDown = false, $chatScrollDown));
    			}
    		}

    		if ($$self.$$.dirty[0] & /*$chat_store, searchInput*/ 262272) {
    			$$invalidate(10, messagesToShow = $chat_store.filter(({ text }) => searchInput && text
    			? text.toLowerCase().includes(searchInput.toLowerCase())
    			: true));
    		}
    	};

    	return [
    		asr,
    		server_avatar,
    		user_avatar,
    		opmode,
    		language,
    		name,
    		header_avatar,
    		searchInput,
    		$chatScrollDown,
    		scrollableChat,
    		messagesToShow,
    		$isFullScreen,
    		$_,
    		dispatch,
    		optionSelected,
    		processUserInput,
    		handleMsgPlay,
    		handleUserInput,
    		$chat_store,
    		input_input_handler,
    		load_handler,
    		messagebubble_server_avatar_binding,
    		messagebubble_user_avatar_binding,
    		click_handler,
    		div7_binding,
    		inputcontainer_asr_binding,
    		inputcontainer_opmode_binding,
    		inputcontainer_language_binding,
    		skip_handler,
    		replay_handler
    	];
    }

    class Chat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$t,
    			create_fragment$x,
    			safe_not_equal,
    			{
    				asr: 0,
    				name: 5,
    				server_avatar: 1,
    				user_avatar: 2,
    				header_avatar: 6,
    				opmode: 3,
    				language: 4
    			},
    			add_css$b,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Chat",
    			options,
    			id: create_fragment$x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[5] === undefined && !('name' in props)) {
    			console.warn("<Chat> was created without expected prop 'name'");
    		}
    	}

    	get asr() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set asr(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get server_avatar() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set server_avatar(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get user_avatar() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set user_avatar(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get header_avatar() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set header_avatar(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opmode() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opmode(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get language() {
    		throw new Error("<Chat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set language(value) {
    		throw new Error("<Chat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Loading.svelte generated by Svelte v3.47.0 */

    const file$p = "src/components/Loading.svelte";

    function add_css$a(target) {
    	append_styles(target, "svelte-ht7z6x", ".lds-ellipsis.svelte-ht7z6x.svelte-ht7z6x{display:inline-block;position:relative;width:80px;height:80px}.lds-ellipsis.svelte-ht7z6x div.svelte-ht7z6x{position:absolute;top:33px;width:13px;height:13px;border-radius:50%;background:rgb(var(--body));animation-timing-function:cubic-bezier(0, 1, 1, 0)}.lds-ellipsis.svelte-ht7z6x div.svelte-ht7z6x:nth-child(1){left:8px;animation:svelte-ht7z6x-lds-ellipsis1 0.6s infinite}.lds-ellipsis.svelte-ht7z6x div.svelte-ht7z6x:nth-child(2){left:8px;animation:svelte-ht7z6x-lds-ellipsis2 0.6s infinite}.lds-ellipsis.svelte-ht7z6x div.svelte-ht7z6x:nth-child(3){left:32px;animation:svelte-ht7z6x-lds-ellipsis2 0.6s infinite}.lds-ellipsis.svelte-ht7z6x div.svelte-ht7z6x:nth-child(4){left:56px;animation:svelte-ht7z6x-lds-ellipsis3 0.6s infinite}@keyframes svelte-ht7z6x-lds-ellipsis1{0%{transform:scale(0)}100%{transform:scale(1)}}@keyframes svelte-ht7z6x-lds-ellipsis3{0%{transform:scale(1)}100%{transform:scale(0)}}@keyframes svelte-ht7z6x-lds-ellipsis2{0%{transform:translate(0, 0)}100%{transform:translate(24px, 0)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9hZGluZy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBVUUsYUFBYSw0QkFBQyxDQUFBLEFBQ1osT0FBTyxDQUFFLFlBQVksQ0FDckIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxBQUNkLENBQUEsQUFDQSwyQkFBYSxDQUFDLEdBQUcsY0FBQyxDQUFBLEFBQ2hCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLEdBQUcsQ0FBRSxJQUFJLENBQ1QsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUMsQ0FDNUIseUJBQXlCLENBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDckQsQ0FBQSxBQUNBLDJCQUFhLENBQUMsaUJBQUcsV0FBVyxDQUFDLENBQUMsQUFBQyxDQUFBLEFBQzdCLElBQUksQ0FBRSxHQUFHLENBQ1QsU0FBUyxDQUFFLDJCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQUFDeEMsQ0FBQSxBQUNBLDJCQUFhLENBQUMsaUJBQUcsV0FBVyxDQUFDLENBQUMsQUFBQyxDQUFBLEFBQzdCLElBQUksQ0FBRSxHQUFHLENBQ1QsU0FBUyxDQUFFLDJCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQUFDeEMsQ0FBQSxBQUNBLDJCQUFhLENBQUMsaUJBQUcsV0FBVyxDQUFDLENBQUMsQUFBQyxDQUFBLEFBQzdCLElBQUksQ0FBRSxJQUFJLENBQ1YsU0FBUyxDQUFFLDJCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQUFDeEMsQ0FBQSxBQUNBLDJCQUFhLENBQUMsaUJBQUcsV0FBVyxDQUFDLENBQUMsQUFBQyxDQUFBLEFBQzdCLElBQUksQ0FBRSxJQUFJLENBQ1YsU0FBUyxDQUFFLDJCQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQUFDeEMsQ0FBQSxBQUNBLFdBQVcsMkJBQWMsQ0FBQSxBQUN2QixFQUFFLEFBQUMsQ0FBQSxBQUNELFNBQVMsQ0FBRSxNQUFNLENBQUMsQ0FBQyxBQUNyQixDQUFBLEFBQ0EsSUFBSSxBQUFDLENBQUEsQUFDSCxTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQUFDckIsQ0FBQSxBQUNGLENBQUEsQUFDQSxXQUFXLDJCQUFjLENBQUEsQUFDdkIsRUFBRSxBQUFDLENBQUEsQUFDRCxTQUFTLENBQUUsTUFBTSxDQUFDLENBQUMsQUFDckIsQ0FBQSxBQUNBLElBQUksQUFBQyxDQUFBLEFBQ0gsU0FBUyxDQUFFLE1BQU0sQ0FBQyxDQUFDLEFBQ3JCLENBQUEsQUFDRixDQUFBLEFBQ0EsV0FBVywyQkFBYyxDQUFBLEFBQ3ZCLEVBQUUsQUFBQyxDQUFBLEFBQ0QsU0FBUyxDQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEFBQzVCLENBQUEsQUFDQSxJQUFJLEFBQUMsQ0FBQSxBQUNILFNBQVMsQ0FBRSxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUMvQixDQUFBLEFBQ0YsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJMb2FkaW5nLnN2ZWx0ZSJdfQ== */");
    }

    function create_fragment$w(ctx) {
    	let div4;
    	let div0;
    	let t0;
    	let div1;
    	let t1;
    	let div2;
    	let t2;
    	let div3;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div2 = element("div");
    			t2 = space();
    			div3 = element("div");
    			attr_dev(div0, "class", "svelte-ht7z6x");
    			add_location(div0, file$p, 3, 2, 59);
    			attr_dev(div1, "class", "svelte-ht7z6x");
    			add_location(div1, file$p, 4, 2, 69);
    			attr_dev(div2, "class", "svelte-ht7z6x");
    			add_location(div2, file$p, 5, 2, 79);
    			attr_dev(div3, "class", "svelte-ht7z6x");
    			add_location(div3, file$p, 6, 2, 89);
    			attr_dev(div4, "class", "lds-ellipsis svelte-ht7z6x");
    			add_location(div4, file$p, 2, 0, 30);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div4, t0);
    			append_dev(div4, div1);
    			append_dev(div4, t1);
    			append_dev(div4, div2);
    			append_dev(div4, t2);
    			append_dev(div4, div3);
    		},
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Loading', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Loading> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Loading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$s, create_fragment$w, safe_not_equal, {}, add_css$a);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loading",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src/components/Modal.svelte generated by Svelte v3.47.0 */
    const file$o = "src/components/Modal.svelte";

    function add_css$9(target) {
    	append_styles(target, "svelte-1how3gs", ".modal.svelte-1how3gs{background-color:rgba(var(--body), 0.4)}.container.svelte-1how3gs{background-color:rgb(var(--background));color:rgb(var(--body));padding:1.5em;border-radius:1em;display:flex;flex-direction:column;max-width:min(60vw, 800px);box-shadow:0 0 18px -4px rgb(var(--shadow));align-items:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFCRSxNQUFNLGVBQUMsQ0FBQSxBQUNMLGdCQUFnQixDQUFFLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUMxQyxDQUFBLEFBRUEsVUFBVSxlQUFDLENBQUEsQUFDVCxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksWUFBWSxDQUFDLENBQUMsQ0FDeEMsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixPQUFPLENBQUUsS0FBSyxDQUNkLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsU0FBUyxDQUFFLElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQzNCLFVBQVUsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLFFBQVEsQ0FBQyxDQUFDLENBQzVDLFdBQVcsQ0FBRSxNQUFNLEFBQ3JCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTW9kYWwuc3ZlbHRlIl19 */");
    }

    function create_fragment$v(ctx) {
    	let div1;
    	let div0;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "container svelte-1how3gs");
    			add_location(div0, file$o, 12, 2, 293);
    			attr_dev(div1, "class", "modal center-text full-screen svelte-1how3gs");
    			add_location(div1, file$o, 11, 0, 231);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "keydown", /*onEsc*/ ctx[0], false, false, false),
    					listen_dev(div0, "keydown", /*onEsc*/ ctx[0], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Modal', slots, ['default']);
    	let { onEscCb = () => null } = $$props;

    	const onEsc = event => {
    		if (event.key === "Escape") {
    			onEscCb();
    		}
    	};

    	const writable_props = ['onEscCb'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('onEscCb' in $$props) $$invalidate(1, onEscCb = $$props.onEscCb);
    		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ fade, onEscCb, onEsc });

    	$$self.$inject_state = $$props => {
    		if ('onEscCb' in $$props) $$invalidate(1, onEscCb = $$props.onEscCb);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [onEsc, onEscCb, $$scope, slots];
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$r, create_fragment$v, safe_not_equal, { onEscCb: 1 }, add_css$9);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Modal",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get onEscCb() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onEscCb(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/MicrophoneAccess.svelte generated by Svelte v3.47.0 */
    const file$n = "src/components/MicrophoneAccess.svelte";

    function add_css$8(target) {
    	append_styles(target, "svelte-na186b", "button.svelte-na186b{right:0;align-self:flex-end;border:none;border-radius:0.3em;background-color:rgb(var(--primary));color:rgb(var(--background));padding:0.5em;box-shadow:0 0 18px -4px rgb(var(--primary));margin-top:2em}h2.svelte-na186b,p.svelte-na186b{align-self:flex-start}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWljcm9waG9uZUFjY2Vzcy5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBc0NFLE1BQU0sY0FBQyxDQUFBLEFBQ0wsS0FBSyxDQUFFLENBQUMsQ0FDUixVQUFVLENBQUUsUUFBUSxDQUNwQixNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLGdCQUFnQixDQUFFLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUNyQyxLQUFLLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQzdCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLENBQUMsQ0FDN0MsVUFBVSxDQUFFLEdBQUcsQUFDakIsQ0FBQSxBQUVBLGdCQUFFLENBQ0YsQ0FBQyxjQUFDLENBQUEsQUFDQSxVQUFVLENBQUUsVUFBVSxBQUN4QixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIk1pY3JvcGhvbmVBY2Nlc3Muc3ZlbHRlIl19 */");
    }

    // (11:0) <Modal onEscCb={close}>
    function create_default_slot$5(ctx) {
    	let h2;
    	let t0_value = /*$_*/ ctx[0]("microphone-access.title") + "";
    	let t0;
    	let t1;
    	let p0;
    	let t2_value = /*$_*/ ctx[0]("microphone-access.paragraph-1") + "";
    	let t2;
    	let t3;
    	let p1;
    	let t4_value = /*$_*/ ctx[0]("microphone-access.paragraph-2") + "";
    	let t4;
    	let t5;
    	let a;
    	let t6_value = /*$_*/ ctx[0]("microphone-access.link") + "";
    	let t6;
    	let t7;
    	let t8;
    	let p2;
    	let t9_value = /*$_*/ ctx[0]("microphone-access.paragraph-3") + "";
    	let t9;
    	let t10;
    	let button;
    	let t11_value = /*$_*/ ctx[0]("microphone-access.exit") + "";
    	let t11;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			p1 = element("p");
    			t4 = text(t4_value);
    			t5 = space();
    			a = element("a");
    			t6 = text(t6_value);
    			t7 = text("\n    .");
    			t8 = space();
    			p2 = element("p");
    			t9 = text(t9_value);
    			t10 = space();
    			button = element("button");
    			t11 = text(t11_value);
    			attr_dev(h2, "class", "svelte-na186b");
    			add_location(h2, file$n, 11, 2, 262);
    			attr_dev(p0, "class", "svelte-na186b");
    			add_location(p0, file$n, 12, 2, 305);
    			attr_dev(a, "href", "https://csi-covid19.github.io/Technology/enable-microphone.pdf");
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noreferrer noopener");
    			add_location(a, file$n, 17, 4, 410);
    			attr_dev(p1, "class", "svelte-na186b");
    			add_location(p1, file$n, 15, 2, 360);
    			attr_dev(p2, "class", "svelte-na186b");
    			add_location(p2, file$n, 26, 2, 610);
    			attr_dev(button, "class", "svelte-na186b");
    			add_location(button, file$n, 29, 2, 665);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p0, anchor);
    			append_dev(p0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, p1, anchor);
    			append_dev(p1, t4);
    			append_dev(p1, t5);
    			append_dev(p1, a);
    			append_dev(a, t6);
    			append_dev(p1, t7);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, p2, anchor);
    			append_dev(p2, t9);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, button, anchor);
    			append_dev(button, t11);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*close*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 1 && t0_value !== (t0_value = /*$_*/ ctx[0]("microphone-access.title") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$_*/ 1 && t2_value !== (t2_value = /*$_*/ ctx[0]("microphone-access.paragraph-1") + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$_*/ 1 && t4_value !== (t4_value = /*$_*/ ctx[0]("microphone-access.paragraph-2") + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$_*/ 1 && t6_value !== (t6_value = /*$_*/ ctx[0]("microphone-access.link") + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*$_*/ 1 && t9_value !== (t9_value = /*$_*/ ctx[0]("microphone-access.paragraph-3") + "")) set_data_dev(t9, t9_value);
    			if (dirty & /*$_*/ 1 && t11_value !== (t11_value = /*$_*/ ctx[0]("microphone-access.exit") + "")) set_data_dev(t11, t11_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(p1);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(p2);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(11:0) <Modal onEscCb={close}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let modal;
    	let current;

    	modal = new Modal({
    			props: {
    				onEscCb: /*close*/ ctx[1],
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, $_*/ 17) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $muted;
    	let $_;
    	validate_store(muted, 'muted');
    	component_subscribe($$self, muted, $$value => $$invalidate(3, $muted = $$value));
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(0, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MicrophoneAccess', slots, []);
    	let { asrModal = true } = $$props;

    	const close = () => {
    		$$invalidate(2, asrModal = false);
    		set_store_value(muted, $muted = false, $muted);
    	};

    	const writable_props = ['asrModal'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MicrophoneAccess> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('asrModal' in $$props) $$invalidate(2, asrModal = $$props.asrModal);
    	};

    	$$self.$capture_state = () => ({
    		Modal,
    		muted,
    		_: Y,
    		asrModal,
    		close,
    		$muted,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('asrModal' in $$props) $$invalidate(2, asrModal = $$props.asrModal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$_, close, asrModal];
    }

    class MicrophoneAccess extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$q, create_fragment$u, safe_not_equal, { asrModal: 2 }, add_css$8);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MicrophoneAccess",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get asrModal() {
    		throw new Error("<MicrophoneAccess>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set asrModal(value) {
    		throw new Error("<MicrophoneAccess>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const talkingVideoSrc = writable("");

    const cache = {};
    async function getMedia(src) {
        if (!cache[src]) {
            try {
                const response = await fetch(src);
                const blob = await response.blob();
                cache[src] = await blob.arrayBuffer();
            }
            catch (err) {
                const e = err;
                if (e?.response?.status === 404) {
                    return null;
                }
                else if (e?.response?.data?.detail) {
                    error$2.set(`Error:\n ${e.response.data.detail}`);
                }
                else {
                    error$2.set(`${JSON.stringify(e)}`);
                }
            }
        }
        return cache[src];
    }
    /** Force the browser to download a requested file, even if from a different server
     *
     * We achieve this by downloading the file, converting it to an blob url, and creating
     * a hidden <a/> element on which we click
     *
     *
     * @param url location of the object to download
     * @param filename filename that the user will see on the downloaded object
     */
    const downloadFile = async (url, filename = "video.mp4") => {
        const response = await fetch(url + "?nocache");
        const blob = await response.blob();
        const downloadUrl = URL.createObjectURL(blob);
        // create hidden html element and click on it
        const a = document.createElement("a");
        a.style.display = "none";
        a.href = downloadUrl;
        a.download = filename;
        a.click();
        a.remove();
    };

    /* src/assets/Download.svelte generated by Svelte v3.47.0 */

    const file$m = "src/assets/Download.svelte";

    function create_fragment$t(ctx) {
    	let svg;
    	let rect;
    	let path0;
    	let path1;
    	let path2;
    	let path3;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			attr_dev(rect, "width", "26");
    			attr_dev(rect, "height", "26");
    			attr_dev(rect, "rx", "10");
    			attr_dev(rect, "fill", /*color*/ ctx[2]);
    			add_location(rect, file$m, 9, 2, 258);
    			attr_dev(path0, "d", "M13.3262 21.8462L15.4095 20.1795M13.3262 21.8462V14.3462V21.8462ZM13.3262 21.8462L11.2428 20.1795L13.3262 21.8462Z");
    			attr_dev(path0, "stroke", "white");
    			attr_dev(path0, "stroke-width", "2");
    			attr_dev(path0, "stroke-linecap", "round");
    			attr_dev(path0, "stroke-linejoin", "round");
    			add_location(path0, file$m, 10, 2, 313);
    			attr_dev(path1, "d", "M7.52118 11.1103C6.73302 11.3086 6.04441 11.7879 5.58473 12.4582C5.12504 13.1284 4.92592 13.9434 5.02477 14.7501C5.12362 15.5568 5.51365 16.2996 6.12157 16.839C6.72949 17.3785 7.51346 17.6773 8.32618 17.6795H9.15951");
    			attr_dev(path1, "stroke", "white");
    			attr_dev(path1, "stroke-width", "2");
    			attr_dev(path1, "stroke-linecap", "round");
    			attr_dev(path1, "stroke-linejoin", "round");
    			add_location(path1, file$m, 17, 2, 544);
    			attr_dev(path2, "d", "M16.5179 9.46112C16.233 8.33326 15.53 7.3559 14.5513 6.72717C13.5726 6.09843 12.3914 5.86536 11.2472 6.07521C10.1031 6.28505 9.08147 6.92211 8.38957 7.85723C7.69768 8.79236 7.38724 9.95559 7.52119 11.1111C7.52119 11.1111 7.64869 11.8461 7.90952 12.2628");
    			attr_dev(path2, "stroke", "white");
    			attr_dev(path2, "stroke-width", "2");
    			attr_dev(path2, "stroke-linecap", "round");
    			attr_dev(path2, "stroke-linejoin", "round");
    			add_location(path2, file$m, 24, 2, 876);
    			attr_dev(path3, "d", "M17.4928 17.6795C18.0812 17.6791 18.6628 17.5541 19.1994 17.3127C19.736 17.0713 20.2153 16.719 20.6059 16.279C20.9966 15.8391 21.2896 15.3213 21.4657 14.7599C21.6418 14.1985 21.697 13.6062 21.6277 13.0219C21.5583 12.4377 21.3661 11.8747 21.0635 11.3701C20.7609 10.8655 20.3549 10.4307 19.8722 10.0943C19.3895 9.75792 18.841 9.52758 18.2628 9.41845C17.6847 9.30932 17.09 9.32388 16.5178 9.46115L15.4095 9.76282");
    			attr_dev(path3, "stroke", "white");
    			attr_dev(path3, "stroke-width", "2");
    			attr_dev(path3, "stroke-linecap", "round");
    			attr_dev(path3, "stroke-linejoin", "round");
    			add_location(path3, file$m, 31, 2, 1245);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "fill", /*color*/ ctx[2]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$m, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(rect, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(svg, "fill", /*color*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Download', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 26 26" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Download> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Download extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$p, create_fragment$t, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Download",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get size() {
    		throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Download>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Download>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/DownloadButton.svelte generated by Svelte v3.47.0 */
    const file$l = "src/components/DownloadButton.svelte";

    function add_css$7(target) {
    	append_styles(target, "svelte-145kn4t", ".icon.svelte-145kn4t{display:flex;align-items:center;margin:0.2em;margin-right:1em;color:rgb(var(--body))}.download-area.svelte-145kn4t{display:flex;cursor:pointer;flex-direction:row;align-items:center;background:rgb(var(--download-button-background));border-radius:1em;padding:0.2em 0.7em 0.2em 0.5em;box-shadow:rgba(0, 0, 0, 0.1) 0px 1px 2px 0px}.download-container.svelte-145kn4t{display:flex;flex-direction:row;flex:1;align-items:center;justify-content:right}.download.svelte-145kn4t{display:flex;flex-direction:row;color:rgb(var(--primary))}@media only screen and (max-width: 600px){.download.svelte-145kn4t{padding-right:1em}.hide-phone.svelte-145kn4t{display:none}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG93bmxvYWRCdXR0b24uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFCRSxLQUFLLGVBQUMsQ0FBQSxBQUNKLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsTUFBTSxDQUFFLEtBQUssQ0FDYixZQUFZLENBQUUsR0FBRyxDQUNqQixLQUFLLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEFBQ3pCLENBQUEsQUFFQSxjQUFjLGVBQUMsQ0FBQSxBQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLE9BQU8sQ0FDZixjQUFjLENBQUUsR0FBRyxDQUNuQixXQUFXLENBQUUsTUFBTSxDQUNuQixVQUFVLENBQUUsSUFBSSxJQUFJLDRCQUE0QixDQUFDLENBQUMsQ0FDbEQsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsT0FBTyxDQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FDaEMsVUFBVSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxBQUNoRCxDQUFBLEFBRUEsbUJBQW1CLGVBQUMsQ0FBQSxBQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxHQUFHLENBQ25CLElBQUksQ0FBRSxDQUFDLENBQ1AsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLEtBQUssQUFDeEIsQ0FBQSxBQUVBLFNBQVMsZUFBQyxDQUFBLEFBQ1IsT0FBTyxDQUFFLElBQUksQ0FDYixjQUFjLENBQUUsR0FBRyxDQUNuQixLQUFLLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEFBQzVCLENBQUEsQUFFQSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUN4QyxTQUFTLGVBQUMsQ0FBQSxBQUNSLGFBQWEsQ0FBRSxHQUFHLEFBQ3BCLENBQUEsQUFDQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLE9BQU8sQ0FBRSxJQUFJLEFBQ2YsQ0FBQSxBQUNGLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRG93bmxvYWRCdXR0b24uc3ZlbHRlIl19 */");
    }

    function create_fragment$s(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let download;
    	let t0;
    	let div1;
    	let t1_value = /*$_*/ ctx[1]("video-component.download") + "";
    	let t1;
    	let current;
    	let mounted;
    	let dispose;
    	download = new Download({ props: { size: "1.5em" }, $$inline: true });

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(download.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			attr_dev(div0, "class", "icon download hide-phone svelte-145kn4t");
    			toggle_class(div0, "hidden", !/*$talkingVideoSrc*/ ctx[0]);
    			add_location(div0, file$l, 8, 4, 343);
    			set_style(div1, "color", "rgb(var(--download-button-font))");
    			add_location(div1, file$l, 11, 4, 462);
    			attr_dev(div2, "class", "download-area svelte-145kn4t");
    			add_location(div2, file$l, 7, 2, 263);
    			attr_dev(div3, "class", "download-container svelte-145kn4t");
    			add_location(div3, file$l, 6, 0, 228);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(download, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, t1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$talkingVideoSrc*/ 1) {
    				toggle_class(div0, "hidden", !/*$talkingVideoSrc*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$_*/ 2) && t1_value !== (t1_value = /*$_*/ ctx[1]("video-component.download") + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(download.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(download.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(download);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $talkingVideoSrc;
    	let $_;
    	validate_store(talkingVideoSrc, 'talkingVideoSrc');
    	component_subscribe($$self, talkingVideoSrc, $$value => $$invalidate(0, $talkingVideoSrc = $$value));
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(1, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DownloadButton', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DownloadButton> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => downloadFile($talkingVideoSrc);

    	$$self.$capture_state = () => ({
    		talkingVideoSrc,
    		_: Y,
    		downloadFile,
    		Download,
    		$talkingVideoSrc,
    		$_
    	});

    	return [$talkingVideoSrc, $_, click_handler];
    }

    class DownloadButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$o, create_fragment$s, safe_not_equal, {}, add_css$7);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DownloadButton",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/assets/Session.svelte generated by Svelte v3.47.0 */

    const file$k = "src/assets/Session.svelte";

    function create_fragment$r(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			attr_dev(path0, "d", "M9.93333 9.5333C11.7333 9.5333 13.1333 8.06664 13.1333 6.26664C13.1333 4.46663 11.6667 3.06664 9.86666 3.06664C8.06666 3.06664 6.66666 4.5333 6.66666 6.26664C6.66666 8.06664 8.13333 9.5333 9.93333 9.5333ZM9.86666 4.39997C9.93333 4.39997 9.93333 4.39997 9.86666 4.39997C10.9333 4.39997 11.8 5.26664 11.8 6.3333C11.8 7.39997 10.9333 8.19997 9.86666 8.19997C8.8 8.19997 8 7.3333 8 6.3333C8 5.26664 8.86666 4.39997 9.86666 4.39997V4.39997Z");
    			attr_dev(path0, "fill", /*color*/ ctx[2]);
    			attr_dev(path0, "fill-opacity", "0.5");
    			add_location(path0, file$k, 9, 2, 245);
    			attr_dev(path1, "d", "M19.8 9.13337C18.5333 8.00004 16.8667 7.40004 15.1333 7.4667H14.6C14.4667 8.00004 14.2667 8.4667 14 8.8667C14.4 8.80004 14.7333 8.80004 15.1333 8.80004C16.4 8.73337 17.6667 9.13337 18.6667 9.8667V14.6667H20V9.33337L19.8 9.13337Z");
    			attr_dev(path1, "fill", "black");
    			attr_dev(path1, "fill-opacity", "0.5");
    			add_location(path1, file$k, 14, 2, 742);
    			attr_dev(path2, "d", "M13.6 3.20006C13.9333 2.40006 14.8667 2.00006 15.7333 2.3334C16.5333 2.66673 16.9333 3.60006 16.6 4.46673C16.3333 5.06673 15.7333 5.46673 15.1333 5.46673C15 5.46673 14.8 5.46673 14.6667 5.40006C14.7333 5.7334 14.7333 6.06673 14.7333 6.3334V6.7334C14.8667 6.7334 15 6.80006 15.1333 6.80006C16.8 6.80006 18.1333 5.46673 18.1333 3.86673C18.1333 2.20006 16.8 0.86673 15.2 0.86673C14.1333 0.86673 13.2 1.40006 12.6667 2.3334C13 2.5334 13.3333 2.80006 13.6 3.20006V3.20006Z");
    			attr_dev(path2, "fill", "black");
    			attr_dev(path2, "fill-opacity", "0.5");
    			add_location(path2, file$k, 19, 2, 1032);
    			attr_dev(path3, "d", "M6 8.93333C5.73333 8.53333 5.53333 8.06666 5.4 7.53333H4.86667C3.13333 7.46666 1.46667 8.06666 0.2 9.13333L0 9.33333V14.6667H1.33333V9.86666C2.4 9.13333 3.6 8.73333 4.86667 8.8C5.26667 8.8 5.66667 8.86666 6 8.93333Z");
    			attr_dev(path3, "fill", "black");
    			attr_dev(path3, "fill-opacity", "0.5");
    			add_location(path3, file$k, 24, 2, 1561);
    			attr_dev(path4, "d", "M4.86666 6.73328C5 6.73328 5.13333 6.73328 5.26666 6.66662V6.26662C5.26666 5.93328 5.26666 5.59995 5.33333 5.33328C5.2 5.39995 5 5.39995 4.86666 5.39995C4 5.39995 3.26666 4.66662 3.26666 3.79995C3.26666 2.93328 4 2.19995 4.86666 2.19995C5.53333 2.19995 6.13333 2.59995 6.4 3.19995C6.66666 2.86662 7.06666 2.53328 7.4 2.26662C6.53333 0.866615 4.73333 0.399949 3.33333 1.26662C1.93333 2.13328 1.46666 3.93328 2.33333 5.33328C2.86666 6.19995 3.8 6.73328 4.86666 6.73328V6.73328Z");
    			attr_dev(path4, "fill", "black");
    			attr_dev(path4, "fill-opacity", "0.5");
    			add_location(path4, file$k, 29, 2, 1838);
    			attr_dev(path5, "d", "M15.4 13.1333L15.2667 12.9333C13.9333 11.4667 12.0667 10.6 10.0667 10.6667C8.06667 10.6 6.13333 11.4667 4.8 12.9333L4.66667 13.1333V18.2C4.66667 18.8 5.13333 19.3333 5.8 19.3333H14.3333C14.9333 19.3333 15.4667 18.8 15.4667 18.2V13.1333H15.4ZM14.0667 18H6V13.6C7.06667 12.5333 8.53333 12 10.0667 12C11.5333 11.9333 13 12.5333 14.0667 13.6V18Z");
    			attr_dev(path5, "fill", "black");
    			attr_dev(path5, "fill-opacity", "0.5");
    			add_location(path5, file$k, 34, 2, 2375);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$k, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    			append_dev(svg, path4);
    			append_dev(svg, path5);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path0, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Session', slots, []);
    	let { size = "1em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 20 20" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Session> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Session extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$n, create_fragment$r, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Session",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get size() {
    		throw new Error("<Session>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Session>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Session>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Session>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Session>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Session>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Session>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Session>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Session>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Session>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/Info.svelte generated by Svelte v3.47.0 */

    const file$j = "src/assets/Info.svelte";

    function create_fragment$q(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(path0, "d", "M23 44.5625C34.9086 44.5625 44.5625 34.9086 44.5625 23C44.5625 11.0914 34.9086 1.4375 23 1.4375C11.0914 1.4375 1.4375 11.0914 1.4375 23C1.4375 34.9086 11.0914 44.5625 23 44.5625Z");
    			attr_dev(path0, "fill", /*color*/ ctx[2]);
    			add_location(path0, file$j, 9, 2, 245);
    			attr_dev(path1, "d", "M19.4062 19.9824H26.5938V37.2324H19.4062V19.9824Z");
    			attr_dev(path1, "fill", "white");
    			add_location(path1, file$j, 13, 2, 462);
    			attr_dev(path2, "d", "M23 15.957C24.9848 15.957 26.5938 14.3481 26.5938 12.3633C26.5938 10.3785 24.9848 8.76953 23 8.76953C21.0152 8.76953 19.4062 10.3785 19.4062 12.3633C19.4062 14.3481 21.0152 15.957 23 15.957Z");
    			attr_dev(path2, "fill", "white");
    			add_location(path2, file$j, 14, 2, 540);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$j, 8, 0, 175);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path0, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info', slots, []);
    	let { size = "4em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 46 46" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Info> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Info extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$m, create_fragment$q, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get size() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/Bulletpoint.svelte generated by Svelte v3.47.0 */

    const file$i = "src/assets/Bulletpoint.svelte";

    function create_fragment$p(ctx) {
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "5");
    			attr_dev(circle, "cy", "5");
    			attr_dev(circle, "r", "5");
    			attr_dev(circle, "fill", /*color*/ ctx[2]);
    			add_location(circle, file$i, 8, 2, 246);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$i, 7, 0, 176);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(circle, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Bulletpoint', slots, []);
    	let { size = "0.6em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 10 10" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bulletpoint> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class Bulletpoint extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$l, create_fragment$p, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bulletpoint",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get size() {
    		throw new Error("<Bulletpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Bulletpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Bulletpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Bulletpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Bulletpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Bulletpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Bulletpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Bulletpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Bulletpoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Bulletpoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/Logo.svelte generated by Svelte v3.47.0 */

    const file$h = "src/assets/Logo.svelte";

    // (11:2) {#if rainbow}
    function create_if_block$9(ctx) {
    	let style;
    	let t;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let stop2;
    	let stop3;
    	let stop4;
    	let stop5;
    	let stop6;
    	let stop7;
    	let stop8;
    	let stop9;
    	let stop10;
    	let stop11;

    	const block = {
    		c: function create() {
    			style = svg_element("style");
    			t = text(".logo-letter {\n        fill: url(#MyGradient);\n      }\n    ");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			stop2 = svg_element("stop");
    			stop3 = svg_element("stop");
    			stop4 = svg_element("stop");
    			stop5 = svg_element("stop");
    			stop6 = svg_element("stop");
    			stop7 = svg_element("stop");
    			stop8 = svg_element("stop");
    			stop9 = svg_element("stop");
    			stop10 = svg_element("stop");
    			stop11 = svg_element("stop");
    			attr_dev(style, "type", "text/css");
    			add_location(style, file$h, 11, 4, 322);
    			attr_dev(stop0, "offset", "0.0%");
    			attr_dev(stop0, "stop-color", "#FF0018");
    			add_location(stop0, file$h, 18, 8, 509);
    			attr_dev(stop1, "offset", "16.7%");
    			attr_dev(stop1, "stop-color", "#FF0018");
    			add_location(stop1, file$h, 19, 8, 561);
    			attr_dev(stop2, "offset", "16.7%");
    			attr_dev(stop2, "stop-color", "#FFA52C");
    			add_location(stop2, file$h, 20, 8, 614);
    			attr_dev(stop3, "offset", "33.3%");
    			attr_dev(stop3, "stop-color", "#FFA52C");
    			add_location(stop3, file$h, 21, 8, 667);
    			attr_dev(stop4, "offset", "33.3%");
    			attr_dev(stop4, "stop-color", "#FFFF41");
    			add_location(stop4, file$h, 22, 8, 720);
    			attr_dev(stop5, "offset", "50.0%");
    			attr_dev(stop5, "stop-color", "#FFFF41");
    			add_location(stop5, file$h, 23, 8, 773);
    			attr_dev(stop6, "offset", "50.0%");
    			attr_dev(stop6, "stop-color", "#008018");
    			add_location(stop6, file$h, 24, 8, 826);
    			attr_dev(stop7, "offset", "66.7%");
    			attr_dev(stop7, "stop-color", "#008018");
    			add_location(stop7, file$h, 25, 8, 879);
    			attr_dev(stop8, "offset", "66.7%");
    			attr_dev(stop8, "stop-color", "#0000F9");
    			add_location(stop8, file$h, 26, 8, 932);
    			attr_dev(stop9, "offset", "83.3%");
    			attr_dev(stop9, "stop-color", "#0000F9");
    			add_location(stop9, file$h, 27, 8, 985);
    			attr_dev(stop10, "offset", "83.3%");
    			attr_dev(stop10, "stop-color", "#86007D");
    			add_location(stop10, file$h, 28, 8, 1038);
    			attr_dev(stop11, "offset", "100%");
    			attr_dev(stop11, "stop-color", "#86007D");
    			add_location(stop11, file$h, 29, 8, 1091);
    			attr_dev(linearGradient, "gradientTransform", "rotate(90)");
    			attr_dev(linearGradient, "id", "MyGradient");
    			add_location(linearGradient, file$h, 17, 6, 437);
    			add_location(defs, file$h, 16, 4, 424);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, style, anchor);
    			append_dev(style, t);
    			insert_dev(target, defs, anchor);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(linearGradient, stop2);
    			append_dev(linearGradient, stop3);
    			append_dev(linearGradient, stop4);
    			append_dev(linearGradient, stop5);
    			append_dev(linearGradient, stop6);
    			append_dev(linearGradient, stop7);
    			append_dev(linearGradient, stop8);
    			append_dev(linearGradient, stop9);
    			append_dev(linearGradient, stop10);
    			append_dev(linearGradient, stop11);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(style);
    			if (detaching) detach_dev(defs);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(11:2) {#if rainbow}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let if_block = /*rainbow*/ ctx[4] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			if (if_block) if_block.c();
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			attr_dev(path0, "class", "logo-letter");
    			attr_dev(path0, "d", "M0,59.61C0,21.58,22,0,57.22,0c30.44,0,53.46,19.82,53.54,48.43H78.31C77.51,35.32,69,26.61,57.22,26.61c-13.91,0-22.7,12.31-22.7,32.92,0,20.86,8.71,33.17,22.78,33.17,11.66,0,20.13-8.55,21.17-21.9h32.45c-.16,28.77-22.62,48.51-53.7,48.51C21.9,119.31,0,97.65,0,59.61Z");
    			add_location(path0, file$h, 33, 2, 1181);
    			attr_dev(path1, "class", "logo-letter");
    			attr_dev(path1, "d", "M192.3,117.31H158.42V2h51.22c30.77,0,46.59,14.46,46.59,39.15,0,13.59-6.55,26.69-18.62,32.45l21.9,43.71H221.63L203.41,78.63H192.3Zm0-61h14c9.5,0,15.34-5.84,15.34-14.55,0-8.55-6.16-14.7-15.27-14.7H192.3Z");
    			add_location(path1, file$h, 37, 2, 1488);
    			attr_dev(path2, "class", "logo-letter");
    			attr_dev(path2, "d", "M418,59.69c0,36.84-22.46,59.62-58.1,59.62s-58.09-22.78-58.09-59.62S324.27,0,359.91,0,418,22.85,418,59.69Zm-81.67,0c0,19.9,9.35,32.61,23.57,32.61s23.58-12.71,23.58-32.61S374.06,27,359.91,27,336.34,39.72,336.34,59.69Z");
    			add_location(path2, file$h, 41, 2, 1735);
    			attr_dev(path3, "class", "logo-letter");
    			attr_dev(path3, "d", "M518.81,117.31h-32L457.12,2h35l13.27,72.88H506L523.21,2h26.21L566.6,74.88h.64L580.5,2h35L585.78,117.31h-32l-17.18-66H536Z");
    			add_location(path3, file$h, 45, 2, 1996);
    			attr_dev(path4, "class", "logo-letter");
    			attr_dev(path4, "d", "M710.7,2c35,0,55.54,19.9,55.54,56.81s-20.61,58.5-55.54,58.5H661.4V2ZM695.28,90.38h10.63c16.94,0,25.81-10.31,25.81-31.57,0-19.41-9.59-29.88-25.81-29.88H695.28Z");
    			add_location(path4, file$h, 49, 2, 2163);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "fill", /*color*/ ctx[2]);
    			add_location(svg, file$h, 9, 0, 256);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			if (if_block) if_block.m(svg, null);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    			append_dev(svg, path4);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(svg, "fill", /*color*/ ctx[2]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Logo', slots, []);
    	let { size = "2em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 766.24 119.31" } = $$props;

    	// let rainbow = new Date().getMonth() == 5;
    	let rainbow = false; // fuck

    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Logo> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(5, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({
    		size,
    		width,
    		height,
    		color,
    		viewBox,
    		rainbow
    	});

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(5, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    		if ('rainbow' in $$props) $$invalidate(4, rainbow = $$props.rainbow);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, rainbow, size];
    }

    class Logo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$k, create_fragment$o, safe_not_equal, {
    			size: 5,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Logo",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get size() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/assets/FullScreen.svelte generated by Svelte v3.47.0 */

    const file$g = "src/assets/FullScreen.svelte";

    function create_fragment$n(ctx) {
    	let svg;
    	let path0;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M19.9294 11.5064L19.9294 15.3659L28.7978 15.3659L28.7978 24.2343L32.6573 24.2343L32.6573 11.5084L32.6553 11.5084L32.6553 11.5064L19.9294 11.5064Z");
    			attr_dev(path0, "fill", /*color*/ ctx[2]);
    			add_location(path0, file$g, 9, 2, 247);
    			attr_dev(path1, "d", "M24.2532 32.1537L24.2532 28.2942L15.3848 28.2942L15.3848 19.4258L11.5253 19.4258L11.5253 32.1518L11.5273 32.1517L11.5273 32.1537L24.2532 32.1537Z");
    			attr_dev(path1, "fill", /*color*/ ctx[2]);
    			add_location(path1, file$g, 13, 2, 431);
    			attr_dev(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "height", /*height*/ ctx[1]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$g, 8, 0, 177);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 4) {
    				attr_dev(path0, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*color*/ 4) {
    				attr_dev(path1, "fill", /*color*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				attr_dev(svg, "width", /*width*/ ctx[0]);
    			}

    			if (dirty & /*height*/ 2) {
    				attr_dev(svg, "height", /*height*/ ctx[1]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FullScreen', slots, []);
    	let { size = "2.5em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { color = "currentColor" } = $$props;
    	let { viewBox = "0 0 45 45" } = $$props;
    	const writable_props = ['size', 'width', 'height', 'color', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FullScreen> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ size, width, height, color, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(0, width = $$props.width);
    		if ('height' in $$props) $$invalidate(1, height = $$props.height);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, height, color, viewBox, size];
    }

    class FullScreen extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$j, create_fragment$n, safe_not_equal, {
    			size: 4,
    			width: 0,
    			height: 1,
    			color: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FullScreen",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get size() {
    		throw new Error("<FullScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<FullScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<FullScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<FullScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<FullScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<FullScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<FullScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<FullScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<FullScreen>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<FullScreen>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/VideoMixerPlaceholder.svelte generated by Svelte v3.47.0 */
    const file$f = "src/components/VideoMixerPlaceholder.svelte";

    function add_css$6(target) {
    	append_styles(target, "svelte-1wkc8iv", ".svelte-1wkc8iv{color:rgba(var(--body))}.video-item{position:relative;grid-area:2/1/2/2}.full-screen-video{position:absolute;height:100vh;width:100vw;top:0px;bottom:0px;left:0px;right:0px;border-radius:0px !important;z-index:105}.rectangle.svelte-1wkc8iv{width:40em;height:25em;position:fixed;z-index:-1;background-color:rgba(var(--primary), 0.1);border-radius:10em;right:15vw;top:40vh}.session-counter.svelte-1wkc8iv{margin-left:0.75em;background-color:rgb(var(--background));border-radius:12px;width:2em;height:2em;display:flex;justify-content:center;align-items:center;box-shadow:1px 1px 2px 0.5px rgba(0, 0, 0, 0.2)}.video-container-container.svelte-1wkc8iv{display:flex;justify-content:flex-start;flex:1;flex-direction:column}.video-container.svelte-1wkc8iv{flex-shrink:1;flex:0;display:grid;margin-left:5%;margin-right:calc(5% - 47px)}.controls.svelte-1wkc8iv{flex-grow:0;display:flex;flex-flow:row;width:17em;padding:0.5em;justify-content:space-around;justify-self:center;align-self:flex-end;grid-area:2/1/2/2;border-radius:15px;z-index:1}.full-screen-button.svelte-1wkc8iv{cursor:pointer;display:grid;align-self:start;justify-self:end;border:none;grid-area:2/1/2/2;z-index:103;margin:1.5em 1.5em 0 0;color:rgb(var(--background));background-color:rgba(var(--body), 0.7);border-radius:0.25em}.backdrop-blur.svelte-1wkc8iv{background-color:rgba(var(--body), 0.3)}@supports (\n    (-webkit-backdrop-filter: blur(5px)) or (backdrop-filter: blur(5px))\n  ){.backdrop-blur.svelte-1wkc8iv{background-color:rgba(var(--body), 0.1);-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px)}}.crowd-logo.svelte-1wkc8iv{display:flex;align-items:center;margin:1% 1em 1%;position:relative}.start.svelte-1wkc8iv{background-color:rgb(var(--background));transition:color 0.2s ease-in-out;color:rgb(var(--body));flex-direction:column}.icon.svelte-1wkc8iv{display:flex;align-items:center;margin:0.2em;margin-right:1em;color:rgb(var(--body))}.video-bottom.svelte-1wkc8iv{display:flex;flex:1;flex-direction:column;margin-left:5%;margin-right:calc(5% - 47px);justify-content:space-between;align-items:flex-start}.title.svelte-1wkc8iv{display:flex;flex-direction:row;margin-top:2em;width:100%}.title-text.svelte-1wkc8iv{font-weight:500;font-size:larger;margin-left:2.9em;margin-top:0%}.bulletpoint.svelte-1wkc8iv{padding-left:0.4em;margin-left:1em;color:rgb(var(--primary))}.about.svelte-1wkc8iv{display:flex;flex-grow:3;margin-top:2em;font-size:2em;align-items:flex-start;justify-content:flex-end;font-size:small;max-width:60%}.user-count.svelte-1wkc8iv{flex-grow:1;margin-top:0.25em;margin-left:0.1em;display:flex;flex-direction:row;padding-left:0.75em;color:rgb(var(--body))}.highlight.svelte-1wkc8iv{margin-left:2em;opacity:1;border-radius:0.5em;background-color:rgba(var(--primary), 0.15);font-weight:lighter;padding-left:1em;padding-right:1em}@media only screen and (max-height: 848px){.about.svelte-1wkc8iv{display:none}.user-count.svelte-1wkc8iv{margin-top:1em}}@media only screen and (max-width: 600px){.video-container.svelte-1wkc8iv{margin:0}.rectangle.svelte-1wkc8iv{display:none}.hide-phone.svelte-1wkc8iv{display:none}.crowd-logo.svelte-1wkc8iv{background-color:transparent;display:grid;flex-flow:row;align-self:start;justify-self:start;grid-area:2/1/2/2;z-index:1;margin:1.5em 0 0 1.5em;border:none}.controls.svelte-1wkc8iv{display:none}}@media only screen and (max-height: 540px){.about.svelte-1wkc8iv{display:none}}.touch-icon.svelte-1wkc8iv{width:5em;height:5em}.is-full-screen-video.svelte-1wkc8iv{margin:0}.full-screen-hide.svelte-1wkc8iv{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlkZW9NaXhlclBsYWNlaG9sZGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUErSEUsZUFBRSxDQUFBLEFBQ0EsS0FBSyxDQUFFLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxBQUMxQixDQUFBLEFBRVEsV0FBVyxBQUFFLENBQUEsQUFDbkIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsU0FBUyxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQUFDcEIsQ0FBQSxBQUVRLGtCQUFrQixBQUFFLENBQUEsQUFDMUIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsTUFBTSxDQUFFLEtBQUssQ0FDYixLQUFLLENBQUUsS0FBSyxDQUNaLEdBQUcsQ0FBRSxHQUFHLENBQ1IsTUFBTSxDQUFFLEdBQUcsQ0FDWCxJQUFJLENBQUUsR0FBRyxDQUNULEtBQUssQ0FBRSxHQUFHLENBQ1YsYUFBYSxDQUFFLEdBQUcsQ0FBQyxVQUFVLENBQzdCLE9BQU8sQ0FBRSxHQUFHLEFBQ2QsQ0FBQSxBQUVBLFVBQVUsZUFBQyxDQUFBLEFBQ1QsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFBSSxDQUNaLFFBQVEsQ0FBRSxLQUFLLENBQ2YsT0FBTyxDQUFFLEVBQUUsQ0FDWCxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDM0MsYUFBYSxDQUFFLElBQUksQ0FDbkIsS0FBSyxDQUFFLElBQUksQ0FDWCxHQUFHLENBQUUsSUFBSSxBQUNYLENBQUEsQUFFQSxnQkFBZ0IsZUFBQyxDQUFBLEFBQ2YsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZ0JBQWdCLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQ3hDLGFBQWEsQ0FBRSxJQUFJLENBQ25CLEtBQUssQ0FBRSxHQUFHLENBQ1YsTUFBTSxDQUFFLEdBQUcsQ0FDWCxPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxNQUFNLENBQ3ZCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLFVBQVUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDbEQsQ0FBQSxBQUVBLDBCQUEwQixlQUFDLENBQUEsQUFDekIsT0FBTyxDQUFFLElBQUksQ0FDYixlQUFlLENBQUUsVUFBVSxDQUMzQixJQUFJLENBQUUsQ0FBQyxDQUNQLGNBQWMsQ0FBRSxNQUFNLEFBQ3hCLENBQUEsQUFFQSxnQkFBZ0IsZUFBQyxDQUFBLEFBQ2YsV0FBVyxDQUFFLENBQUMsQ0FDZCxJQUFJLENBQUUsQ0FBQyxDQUNQLE9BQU8sQ0FBRSxJQUFJLENBRWIsV0FBVyxDQUFFLEVBQUUsQ0FDZixZQUFZLENBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxBQUMvQixDQUFBLEFBRUEsU0FBUyxlQUFDLENBQUEsQUFDUixTQUFTLENBQUUsQ0FBQyxDQUNaLE9BQU8sQ0FBRSxJQUFJLENBQ2IsU0FBUyxDQUFFLEdBQUcsQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxLQUFLLENBQ2QsZUFBZSxDQUFFLFlBQVksQ0FDN0IsWUFBWSxDQUFFLE1BQU0sQ0FDcEIsVUFBVSxDQUFFLFFBQVEsQ0FDcEIsU0FBUyxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDbEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFBLEFBRUEsbUJBQW1CLGVBQUMsQ0FBQSxBQUNsQixNQUFNLENBQUUsT0FBTyxDQUNmLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLEtBQUssQ0FDakIsWUFBWSxDQUFFLEdBQUcsQ0FDakIsTUFBTSxDQUFFLElBQUksQ0FDWixTQUFTLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNsQixPQUFPLENBQUUsR0FBRyxDQUNaLE1BQU0sQ0FBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3ZCLEtBQUssQ0FBRSxJQUFJLElBQUksWUFBWSxDQUFDLENBQUMsQ0FDN0IsZ0JBQWdCLENBQUUsS0FBSyxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ3hDLGFBQWEsQ0FBRSxNQUFNLEFBQ3ZCLENBQUEsQUFFQSxjQUFjLGVBQUMsQ0FBQSxBQUNiLGdCQUFnQixDQUFFLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUMxQyxDQUFBLEFBR0EsVUFBVTtJQUNSLENBQUMseUJBQXlCLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxpQkFBaUIsS0FBSyxHQUFHLENBQUMsQ0FBQTtHQUNwRSxBQUFDLENBQUEsQUFDQSxjQUFjLGVBQUMsQ0FBQSxBQUNiLGdCQUFnQixDQUFFLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN4Qyx1QkFBdUIsQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUNsQyxlQUFlLENBQUUsS0FBSyxHQUFHLENBQUMsQUFDNUIsQ0FBQSxBQUNGLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsTUFBTSxDQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUNqQixRQUFRLENBQUUsUUFBUSxBQUNwQixDQUFBLEFBRUEsTUFBTSxlQUFDLENBQUEsQUFDTCxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksWUFBWSxDQUFDLENBQUMsQ0FDeEMsVUFBVSxDQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUNsQyxLQUFLLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQ3ZCLGNBQWMsQ0FBRSxNQUFNLEFBQ3hCLENBQUEsQUFFQSxLQUFLLGVBQUMsQ0FBQSxBQUNKLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsTUFBTSxDQUFFLEtBQUssQ0FDYixZQUFZLENBQUUsR0FBRyxDQUNqQixLQUFLLENBQUUsSUFBSSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEFBQ3pCLENBQUEsQUFFQSxhQUFhLGVBQUMsQ0FBQSxBQUNaLE9BQU8sQ0FBRSxJQUFJLENBQ2IsSUFBSSxDQUFFLENBQUMsQ0FDUCxjQUFjLENBQUUsTUFBTSxDQUN0QixXQUFXLENBQUUsRUFBRSxDQUNmLFlBQVksQ0FBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQzdCLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFdBQVcsQ0FBRSxVQUFVLEFBQ3pCLENBQUEsQUFFQSxNQUFNLGVBQUMsQ0FBQSxBQUNMLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsVUFBVSxDQUFFLEdBQUcsQ0FDZixLQUFLLENBQUUsSUFBSSxBQUNiLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxNQUFNLENBQ2pCLFdBQVcsQ0FBRSxLQUFLLENBQ2xCLFVBQVUsQ0FBRSxFQUFFLEFBQ2hCLENBQUEsQUFFQSxZQUFZLGVBQUMsQ0FBQSxBQUNYLFlBQVksQ0FBRSxLQUFLLENBQ25CLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLEtBQUssQ0FBRSxJQUFJLElBQUksU0FBUyxDQUFDLENBQUMsQUFDNUIsQ0FBQSxBQUVBLE1BQU0sZUFBQyxDQUFBLEFBQ0wsT0FBTyxDQUFFLElBQUksQ0FDYixTQUFTLENBQUUsQ0FBQyxDQUNaLFVBQVUsQ0FBRSxHQUFHLENBQ2YsU0FBUyxDQUFFLEdBQUcsQ0FDZCxXQUFXLENBQUUsVUFBVSxDQUN2QixlQUFlLENBQUUsUUFBUSxDQUN6QixTQUFTLENBQUUsS0FBSyxDQUNoQixTQUFTLENBQUUsR0FBRyxBQUNoQixDQUFBLEFBRUEsV0FBVyxlQUFDLENBQUEsQUFDVixTQUFTLENBQUUsQ0FBQyxDQUNaLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFdBQVcsQ0FBRSxLQUFLLENBQ2xCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsWUFBWSxDQUFFLE1BQU0sQ0FDcEIsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxBQUN6QixDQUFBLEFBRUEsVUFBVSxlQUFDLENBQUEsQUFDVCxXQUFXLENBQUUsR0FBRyxDQUNoQixPQUFPLENBQUUsQ0FBQyxDQUNWLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLGdCQUFnQixDQUFFLEtBQUssSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUM1QyxXQUFXLENBQUUsT0FBTyxDQUNwQixZQUFZLENBQUUsR0FBRyxDQUNqQixhQUFhLENBQUUsR0FBRyxBQUNwQixDQUFBLEFBRUEsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDekMsTUFBTSxlQUFDLENBQUEsQUFDTCxPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLFVBQVUsQ0FBRSxHQUFHLEFBQ2pCLENBQUEsQUFDRixDQUFBLEFBRUEsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDeEMsZ0JBQWdCLGVBQUMsQ0FBQSxBQUNmLE1BQU0sQ0FBRSxDQUFDLEFBQ1gsQ0FBQSxBQUVBLFVBQVUsZUFBQyxDQUFBLEFBQ1QsT0FBTyxDQUFFLElBQUksQUFDZixDQUFBLEFBRUEsV0FBVyxlQUFDLENBQUEsQUFDVixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLGdCQUFnQixDQUFFLFdBQVcsQ0FDN0IsT0FBTyxDQUFFLElBQUksQ0FDYixTQUFTLENBQUUsR0FBRyxDQUNkLFVBQVUsQ0FBRSxLQUFLLENBQ2pCLFlBQVksQ0FBRSxLQUFLLENBQ25CLFNBQVMsQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ2xCLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FDdkIsTUFBTSxDQUFFLElBQUksQUFDZCxDQUFBLEFBRUEsU0FBUyxlQUFDLENBQUEsQUFDUixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFDRixDQUFBLEFBRUEsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDekMsTUFBTSxlQUFDLENBQUEsQUFDTCxPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEsQUFDRixDQUFBLEFBRUEsV0FBVyxlQUFDLENBQUEsQUFDVixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLEFBQ2IsQ0FBQSxBQUVBLHFCQUFxQixlQUFDLENBQUEsQUFDcEIsTUFBTSxDQUFFLENBQUMsQUFDWCxDQUFBLEFBRUEsaUJBQWlCLGVBQUMsQ0FBQSxBQUNoQixPQUFPLENBQUUsSUFBSSxBQUNmLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiVmlkZW9NaXhlclBsYWNlaG9sZGVyLnN2ZWx0ZSJdfQ== */");
    }

    // (22:0) {#if start}
    function create_if_block_4$1(ctx) {
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let t1_value = /*$_*/ ctx[6]("video-component.touch-to-start") + "";
    	let t1;
    	let div1_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			attr_dev(img, "alt", "touch icon");
    			if (!src_url_equal(img.src, img_src_value = /*borisWantsGif*/ ctx[8])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "touch-icon svelte-1wkc8iv");
    			add_location(img, file$f, 23, 4, 900);
    			attr_dev(div0, "class", "svelte-1wkc8iv");
    			add_location(div0, file$f, 24, 4, 968);
    			attr_dev(div1, "class", "video-item start center-text full-screen-video svelte-1wkc8iv");
    			add_location(div1, file$f, 22, 2, 819);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 64) && t1_value !== (t1_value = /*$_*/ ctx[6]("video-component.touch-to-start") + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_transition) div1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(22:0) {#if start}",
    		ctx
    	});

    	return block;
    }

    // (74:4) {#if show_count}
    function create_if_block_3$2(ctx) {
    	let div2;
    	let div0;
    	let session;
    	let t0;
    	let div1;
    	let span0;
    	let t1_value = /*$_*/ ctx[6]("video-component.session-count") + "";
    	let t1;
    	let t2;
    	let span2;
    	let span1;
    	let t3;
    	let current;
    	session = new Session({ props: { size: "1.5em" }, $$inline: true });

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(session.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			span0 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			span2 = element("span");
    			span1 = element("span");
    			t3 = text(/*sessionCount*/ ctx[0]);
    			attr_dev(div0, "class", "icon svelte-1wkc8iv");
    			add_location(div0, file$f, 75, 8, 2375);
    			set_style(span0, "opacity", "0.7");
    			attr_dev(span0, "class", "svelte-1wkc8iv");
    			add_location(span0, file$f, 79, 10, 2527);
    			attr_dev(span1, "style", "");
    			attr_dev(span1, "class", "svelte-1wkc8iv");
    			add_location(span1, file$f, 83, 12, 2677);
    			attr_dev(span2, "class", "session-counter svelte-1wkc8iv");
    			add_location(span2, file$f, 82, 10, 2634);
    			set_style(div1, "margin-left", "2.2em");
    			set_style(div1, "font-weight", "500");
    			attr_dev(div1, "class", "icon svelte-1wkc8iv");
    			add_location(div1, file$f, 78, 8, 2452);
    			attr_dev(div2, "class", "user-count hide-phone svelte-1wkc8iv");
    			add_location(div2, file$f, 74, 6, 2331);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(session, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(span0, t1);
    			append_dev(div1, t2);
    			append_dev(div1, span2);
    			append_dev(span2, span1);
    			append_dev(span1, t3);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 64) && t1_value !== (t1_value = /*$_*/ ctx[6]("video-component.session-count") + "")) set_data_dev(t1, t1_value);
    			if (!current || dirty & /*sessionCount*/ 1) set_data_dev(t3, /*sessionCount*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(session.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(session.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(session);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(74:4) {#if show_count}",
    		ctx
    	});

    	return block;
    }

    // (106:36) 
    function create_if_block_2$2(ctx) {
    	let t_value = /*$_*/ ctx[6]("video-component.about.gc", { values: { name: /*name*/ ctx[2] } }) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, name*/ 68 && t_value !== (t_value = /*$_*/ ctx[6]("video-component.about.gc", { values: { name: /*name*/ ctx[2] } }) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(106:36) ",
    		ctx
    	});

    	return block;
    }

    // (104:57) 
    function create_if_block_1$4(ctx) {
    	let t_value = /*$_*/ ctx[6]("video-component.about.opsp-oc", { values: { name: /*name*/ ctx[2] } }) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, name*/ 68 && t_value !== (t_value = /*$_*/ ctx[6]("video-component.about.opsp-oc", { values: { name: /*name*/ ctx[2] } }) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(104:57) ",
    		ctx
    	});

    	return block;
    }

    // (102:10) {#if opmode === "ttt"}
    function create_if_block$8(ctx) {
    	let t_value = /*$_*/ ctx[6]("video-component.about.ttt", { values: { name: /*name*/ ctx[2] } }) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_, name*/ 68 && t_value !== (t_value = /*$_*/ ctx[6]("video-component.about.ttt", { values: { name: /*name*/ ctx[2] } }) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(102:10) {#if opmode === \\\"ttt\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let t0;
    	let div13;
    	let div3;
    	let div0;
    	let logo;
    	let t1;
    	let span0;
    	let t2;
    	let em;
    	let t4;
    	let t5;
    	let div1;
    	let fullscreen;
    	let t6;
    	let div2;
    	let controls;
    	let updating_size;
    	let t7;
    	let div4;
    	let t8;
    	let div12;
    	let div8;
    	let div5;
    	let bulletpoint;
    	let t9;
    	let div7;
    	let span1;
    	let t10;
    	let t11;
    	let span2;
    	let t13;
    	let div6;
    	let t14_value = /*$_*/ ctx[6]("video-component.title") + "";
    	let t14;
    	let t15;
    	let downloadbutton;
    	let t16;
    	let t17;
    	let div11;
    	let div9;
    	let info;
    	let t18;
    	let div10;
    	let span3;
    	let t19_value = /*$_*/ ctx[6]("video-component.about.header") + "";
    	let t19;
    	let t20;
    	let p;
    	let t21_value = /*$_*/ ctx[6]("video-component.about.start") + "";
    	let t21;
    	let t22;
    	let t23;
    	let t24_value = /*$_*/ ctx[6]("video-component.about.end") + "";
    	let t24;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*start*/ ctx[4] && create_if_block_4$1(ctx);
    	logo = new Logo({ props: { size: "3em" }, $$inline: true });
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
    	fullscreen = new FullScreen({ $$inline: true });

    	function controls_size_binding(value) {
    		/*controls_size_binding*/ ctx[12](value);
    	}

    	let controls_props = {};

    	if (/*controlsSize*/ ctx[5] !== void 0) {
    		controls_props.size = /*controlsSize*/ ctx[5];
    	}

    	controls = new Controls({ props: controls_props, $$inline: true });
    	binding_callbacks.push(() => bind(controls, 'size', controls_size_binding));
    	controls.$on("skip", /*skip_handler*/ ctx[13]);
    	controls.$on("replay", /*replay_handler*/ ctx[14]);
    	bulletpoint = new Bulletpoint({ $$inline: true });
    	downloadbutton = new DownloadButton({ $$inline: true });
    	let if_block1 = /*show_count*/ ctx[1] && create_if_block_3$2(ctx);

    	info = new Info({
    			props: {
    				size: "4em",
    				color: "rgb(var(--body), 0.7)"
    			},
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*opmode*/ ctx[3] === "ttt") return create_if_block$8;
    		if (/*opmode*/ ctx[3] === "opsp" || /*opmode*/ ctx[3] === "oc") return create_if_block_1$4;
    		if (/*opmode*/ ctx[3] === "gc") return create_if_block_2$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div13 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t1 = space();
    			span0 = element("span");
    			t2 = text("CROWD MEDIA - ");
    			em = element("em");
    			em.textContent = "\"We Ship\"";
    			t4 = space();
    			if (default_slot) default_slot.c();
    			t5 = space();
    			div1 = element("div");
    			create_component(fullscreen.$$.fragment);
    			t6 = space();
    			div2 = element("div");
    			create_component(controls.$$.fragment);
    			t7 = space();
    			div4 = element("div");
    			t8 = space();
    			div12 = element("div");
    			div8 = element("div");
    			div5 = element("div");
    			create_component(bulletpoint.$$.fragment);
    			t9 = space();
    			div7 = element("div");
    			span1 = element("span");
    			t10 = text(/*name*/ ctx[2]);
    			t11 = space();
    			span2 = element("span");
    			span2.textContent = "BETA";
    			t13 = space();
    			div6 = element("div");
    			t14 = text(t14_value);
    			t15 = space();
    			create_component(downloadbutton.$$.fragment);
    			t16 = space();
    			if (if_block1) if_block1.c();
    			t17 = space();
    			div11 = element("div");
    			div9 = element("div");
    			create_component(info.$$.fragment);
    			t18 = space();
    			div10 = element("div");
    			span3 = element("span");
    			t19 = text(t19_value);
    			t20 = space();
    			p = element("p");
    			t21 = text(t21_value);
    			t22 = space();
    			if (if_block2) if_block2.c();
    			t23 = space();
    			t24 = text(t24_value);
    			set_style(em, "font-style", "italic");
    			set_style(em, "opacity", "0.75");
    			attr_dev(em, "class", "svelte-1wkc8iv");
    			add_location(em, file$f, 35, 23, 1372);
    			set_style(span0, "margin-left", "3em");
    			set_style(span0, "font-weight", "200");
    			set_style(span0, "opacity", "0.9");
    			attr_dev(span0, "class", "hide-phone svelte-1wkc8iv");
    			add_location(span0, file$f, 32, 6, 1249);
    			attr_dev(div0, "class", "crowd-logo svelte-1wkc8iv");
    			toggle_class(div0, "full-screen-hide", /*$isFullScreen*/ ctx[7]);
    			add_location(div0, file$f, 30, 4, 1153);
    			attr_dev(div1, "class", "full-screen-button svelte-1wkc8iv");
    			add_location(div1, file$f, 43, 4, 1498);
    			attr_dev(div2, "class", "controls backdrop-blur svelte-1wkc8iv");
    			toggle_class(div2, "full-screen-hide", /*$isFullScreen*/ ctx[7]);
    			add_location(div2, file$f, 47, 4, 1596);
    			attr_dev(div3, "class", "video-container svelte-1wkc8iv");
    			toggle_class(div3, "is-full-screen-video", /*$isFullScreen*/ ctx[7]);
    			add_location(div3, file$f, 29, 2, 1076);
    			attr_dev(div4, "class", "rectangle svelte-1wkc8iv");
    			add_location(div4, file$f, 56, 2, 1839);
    			attr_dev(div5, "class", "bulletpoint svelte-1wkc8iv");
    			add_location(div5, file$f, 60, 6, 1975);
    			set_style(span1, "opacity", "0.9");
    			attr_dev(span1, "class", "svelte-1wkc8iv");
    			add_location(span1, file$f, 64, 8, 2077);
    			attr_dev(span2, "class", "highlight svelte-1wkc8iv");
    			add_location(span2, file$f, 65, 8, 2127);
    			set_style(div6, "opacity", "0.9");
    			attr_dev(div6, "class", "svelte-1wkc8iv");
    			add_location(div6, file$f, 66, 8, 2171);
    			attr_dev(div7, "class", "title-text svelte-1wkc8iv");
    			add_location(div7, file$f, 63, 6, 2044);
    			attr_dev(div8, "class", "hide-phone title svelte-1wkc8iv");
    			add_location(div8, file$f, 59, 4, 1938);
    			set_style(div9, "padding-right", "1em");
    			attr_dev(div9, "class", "svelte-1wkc8iv");
    			add_location(div9, file$f, 92, 6, 2840);
    			set_style(span3, "font-size", "medium");
    			set_style(span3, "font-weight", "200");
    			attr_dev(span3, "class", "svelte-1wkc8iv");
    			add_location(span3, file$f, 96, 8, 3008);
    			set_style(p, "font-size", "small");
    			set_style(p, "font-weight", "500");
    			set_style(p, "opacity", "0.9");
    			attr_dev(p, "class", "svelte-1wkc8iv");
    			add_location(p, file$f, 99, 8, 3131);
    			set_style(div10, "padding-left", "1.8em");
    			set_style(div10, "opacity", "0.7");
    			attr_dev(div10, "class", "svelte-1wkc8iv");
    			add_location(div10, file$f, 95, 6, 2951);
    			attr_dev(div11, "class", "hide-phone about svelte-1wkc8iv");
    			add_location(div11, file$f, 91, 4, 2803);
    			attr_dev(div12, "class", "video-bottom svelte-1wkc8iv");
    			toggle_class(div12, "full-screen-hide", /*$isFullScreen*/ ctx[7]);
    			add_location(div12, file$f, 58, 2, 1868);
    			attr_dev(div13, "class", "video-container-container svelte-1wkc8iv");
    			add_location(div13, file$f, 28, 0, 1034);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div3);
    			append_dev(div3, div0);
    			mount_component(logo, div0, null);
    			append_dev(div0, t1);
    			append_dev(div0, span0);
    			append_dev(span0, t2);
    			append_dev(span0, em);
    			append_dev(div3, t4);

    			if (default_slot) {
    				default_slot.m(div3, null);
    			}

    			append_dev(div3, t5);
    			append_dev(div3, div1);
    			mount_component(fullscreen, div1, null);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			mount_component(controls, div2, null);
    			append_dev(div13, t7);
    			append_dev(div13, div4);
    			append_dev(div13, t8);
    			append_dev(div13, div12);
    			append_dev(div12, div8);
    			append_dev(div8, div5);
    			mount_component(bulletpoint, div5, null);
    			append_dev(div8, t9);
    			append_dev(div8, div7);
    			append_dev(div7, span1);
    			append_dev(span1, t10);
    			append_dev(div7, t11);
    			append_dev(div7, span2);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			append_dev(div6, t14);
    			append_dev(div8, t15);
    			mount_component(downloadbutton, div8, null);
    			append_dev(div12, t16);
    			if (if_block1) if_block1.m(div12, null);
    			append_dev(div12, t17);
    			append_dev(div12, div11);
    			append_dev(div11, div9);
    			mount_component(info, div9, null);
    			append_dev(div11, t18);
    			append_dev(div11, div10);
    			append_dev(div10, span3);
    			append_dev(span3, t19);
    			append_dev(div10, t20);
    			append_dev(div10, p);
    			append_dev(p, t21);
    			append_dev(p, t22);
    			if (if_block2) if_block2.m(p, null);
    			append_dev(p, t23);
    			append_dev(p, t24);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", toggleFullScreen, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*start*/ ctx[4]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*start*/ 16) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*$isFullScreen*/ 128) {
    				toggle_class(div0, "full-screen-hide", /*$isFullScreen*/ ctx[7]);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			const controls_changes = {};

    			if (!updating_size && dirty & /*controlsSize*/ 32) {
    				updating_size = true;
    				controls_changes.size = /*controlsSize*/ ctx[5];
    				add_flush_callback(() => updating_size = false);
    			}

    			controls.$set(controls_changes);

    			if (dirty & /*$isFullScreen*/ 128) {
    				toggle_class(div2, "full-screen-hide", /*$isFullScreen*/ ctx[7]);
    			}

    			if (dirty & /*$isFullScreen*/ 128) {
    				toggle_class(div3, "is-full-screen-video", /*$isFullScreen*/ ctx[7]);
    			}

    			if (!current || dirty & /*name*/ 4) set_data_dev(t10, /*name*/ ctx[2]);
    			if ((!current || dirty & /*$_*/ 64) && t14_value !== (t14_value = /*$_*/ ctx[6]("video-component.title") + "")) set_data_dev(t14, t14_value);

    			if (/*show_count*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*show_count*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div12, t17);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*$_*/ 64) && t19_value !== (t19_value = /*$_*/ ctx[6]("video-component.about.header") + "")) set_data_dev(t19, t19_value);
    			if ((!current || dirty & /*$_*/ 64) && t21_value !== (t21_value = /*$_*/ ctx[6]("video-component.about.start") + "")) set_data_dev(t21, t21_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if (if_block2) if_block2.d(1);
    				if_block2 = current_block_type && current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(p, t23);
    				}
    			}

    			if ((!current || dirty & /*$_*/ 64) && t24_value !== (t24_value = /*$_*/ ctx[6]("video-component.about.end") + "")) set_data_dev(t24, t24_value);

    			if (dirty & /*$isFullScreen*/ 128) {
    				toggle_class(div12, "full-screen-hide", /*$isFullScreen*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(logo.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(fullscreen.$$.fragment, local);
    			transition_in(controls.$$.fragment, local);
    			transition_in(bulletpoint.$$.fragment, local);
    			transition_in(downloadbutton.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(info.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(logo.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(fullscreen.$$.fragment, local);
    			transition_out(controls.$$.fragment, local);
    			transition_out(bulletpoint.$$.fragment, local);
    			transition_out(downloadbutton.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(info.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div13);
    			destroy_component(logo);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(fullscreen);
    			destroy_component(controls);
    			destroy_component(bulletpoint);
    			destroy_component(downloadbutton);
    			if (if_block1) if_block1.d();
    			destroy_component(info);

    			if (if_block2) {
    				if_block2.d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $_;
    	let $isFullScreen;
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(6, $_ = $$value));
    	validate_store(isFullScreen, 'isFullScreen');
    	component_subscribe($$self, isFullScreen, $$value => $$invalidate(7, $isFullScreen = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoMixerPlaceholder', slots, ['default']);
    	let { sessionCount = 0 } = $$props;
    	let { show_count = false } = $$props;
    	let { name } = $$props;
    	let { opmode = "ttt" } = $$props;
    	let { start = true } = $$props;
    	let controlsSize = "3em";
    	let borisWantsGif = "assets/touch.gif";
    	const dispatch = createEventDispatcher();
    	const writable_props = ['sessionCount', 'show_count', 'name', 'opmode', 'start'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoMixerPlaceholder> was created with unknown prop '${key}'`);
    	});

    	function controls_size_binding(value) {
    		controlsSize = value;
    		$$invalidate(5, controlsSize);
    	}

    	const skip_handler = () => dispatch("skip");
    	const replay_handler = () => dispatch("replay");

    	$$self.$$set = $$props => {
    		if ('sessionCount' in $$props) $$invalidate(0, sessionCount = $$props.sessionCount);
    		if ('show_count' in $$props) $$invalidate(1, show_count = $$props.show_count);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('opmode' in $$props) $$invalidate(3, opmode = $$props.opmode);
    		if ('start' in $$props) $$invalidate(4, start = $$props.start);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		createEventDispatcher,
    		Controls,
    		DownloadButton,
    		isFullScreen,
    		toggleFullScreen,
    		_: Y,
    		Session,
    		Info,
    		Bulletpoint,
    		Logo,
    		FullScreen,
    		sessionCount,
    		show_count,
    		name,
    		opmode,
    		start,
    		controlsSize,
    		borisWantsGif,
    		dispatch,
    		$_,
    		$isFullScreen
    	});

    	$$self.$inject_state = $$props => {
    		if ('sessionCount' in $$props) $$invalidate(0, sessionCount = $$props.sessionCount);
    		if ('show_count' in $$props) $$invalidate(1, show_count = $$props.show_count);
    		if ('name' in $$props) $$invalidate(2, name = $$props.name);
    		if ('opmode' in $$props) $$invalidate(3, opmode = $$props.opmode);
    		if ('start' in $$props) $$invalidate(4, start = $$props.start);
    		if ('controlsSize' in $$props) $$invalidate(5, controlsSize = $$props.controlsSize);
    		if ('borisWantsGif' in $$props) $$invalidate(8, borisWantsGif = $$props.borisWantsGif);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		sessionCount,
    		show_count,
    		name,
    		opmode,
    		start,
    		controlsSize,
    		$_,
    		$isFullScreen,
    		borisWantsGif,
    		dispatch,
    		$$scope,
    		slots,
    		controls_size_binding,
    		skip_handler,
    		replay_handler
    	];
    }

    class VideoMixerPlaceholder extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$i,
    			create_fragment$m,
    			safe_not_equal,
    			{
    				sessionCount: 0,
    				show_count: 1,
    				name: 2,
    				opmode: 3,
    				start: 4
    			},
    			add_css$6
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoMixerPlaceholder",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[2] === undefined && !('name' in props)) {
    			console.warn("<VideoMixerPlaceholder> was created without expected prop 'name'");
    		}
    	}

    	get sessionCount() {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionCount(value) {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show_count() {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show_count(value) {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opmode() {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opmode(value) {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VideoMixerPlaceholder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const default_dimensions = { x: 0, y: 0 };
    const video_dimensions = writable(default_dimensions);

    /* src/components/VideoMixer1/VideoPlayer.svelte generated by Svelte v3.47.0 */
    const file$e = "src/components/VideoMixer1/VideoPlayer.svelte";

    function add_css$5(target) {
    	append_styles(target, "svelte-huwp3f", "video.svelte-huwp3f{width:100%;min-width:40vw;border-radius:1em;transition:opacity var(--fade-time) ease;box-shadow:0px 0px 0px 3px rgb(var(--primary))}input.svelte-huwp3f{width:4em}.lg.svelte-huwp3f{width:30em}@media only screen and (max-width: 600px){video.svelte-huwp3f{border-radius:0 0 1em 1em}}.fade-out.svelte-huwp3f{opacity:0}.full-screen.svelte-huwp3f{object-fit:cover}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlkZW9QbGF5ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQThLRSxLQUFLLGNBQUMsQ0FBQSxBQUNKLEtBQUssQ0FBRSxJQUFJLENBQ1gsU0FBUyxDQUFFLElBQUksQ0FDZixhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsT0FBTyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsSUFBSSxDQUN6QyxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxBQUNqRCxDQUFBLEFBRUEsS0FBSyxjQUFDLENBQUEsQUFDSixLQUFLLENBQUUsR0FBRyxBQUNaLENBQUEsQUFFQSxHQUFHLGNBQUMsQ0FBQSxBQUNGLEtBQUssQ0FBRSxJQUFJLEFBQ2IsQ0FBQSxBQUVBLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsWUFBWSxLQUFLLENBQUMsQUFBQyxDQUFBLEFBQ3hDLEtBQUssY0FBQyxDQUFBLEFBQ0osYUFBYSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQUFDNUIsQ0FBQSxBQUNGLENBQUEsQUFFQSxTQUFTLGNBQUMsQ0FBQSxBQUVSLE9BQU8sQ0FBRSxDQUFDLEFBQ1osQ0FBQSxBQUVBLFlBQVksY0FBQyxDQUFBLEFBQ1gsVUFBVSxDQUFFLEtBQUssQUFDbkIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWaWRlb1BsYXllci5zdmVsdGUiXX0= */");
    }

    // (125:0) {#if debug}
    function create_if_block$7(ctx) {
    	let br0;
    	let t0;
    	let input0;
    	let t1;
    	let input1;
    	let t2;
    	let input2;
    	let t3;
    	let br1;
    	let t4;
    	let input3;
    	let t5;
    	let br2;
    	let t6;
    	let input4;
    	let t7;
    	let br3;
    	let t8;
    	let input5;
    	let t9;
    	let input6;
    	let t10;
    	let input7;
    	let t11;
    	let input8;
    	let t12;
    	let input9;
    	let t13;
    	let br4;
    	let t14;
    	let input10;
    	let input10_value_value;
    	let t15;
    	let input11;
    	let t16;
    	let input12;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			br0 = element("br");
    			t0 = text("\n  currentTime");
    			input0 = element("input");
    			t1 = text("\n  duration");
    			input1 = element("input");
    			t2 = text("\n  playDrift");
    			input2 = element("input");
    			t3 = space();
    			br1 = element("br");
    			t4 = text("\n  src");
    			input3 = element("input");
    			t5 = space();
    			br2 = element("br");
    			t6 = text("\n  src");
    			input4 = element("input");
    			t7 = space();
    			br3 = element("br");
    			t8 = text("\n\n  paused");
    			input5 = element("input");
    			t9 = text("\n  pausing");
    			input6 = element("input");
    			t10 = text("\n\n  start");
    			input7 = element("input");
    			t11 = text("\n  muted");
    			input8 = element("input");
    			t12 = text("\n  loop");
    			input9 = element("input");
    			t13 = space();
    			br4 = element("br");
    			t14 = space();
    			input10 = element("input");
    			t15 = space();
    			input11 = element("input");
    			t16 = space();
    			input12 = element("input");
    			add_location(br0, file$e, 125, 2, 3252);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "svelte-huwp3f");
    			add_location(input0, file$e, 126, 13, 3272);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "svelte-huwp3f");
    			add_location(input1, file$e, 127, 10, 3329);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "svelte-huwp3f");
    			add_location(input2, file$e, 128, 11, 3384);
    			add_location(br1, file$e, 129, 2, 3431);
    			attr_dev(input3, "class", "lg svelte-huwp3f");
    			attr_dev(input3, "type", "text");
    			add_location(input3, file$e, 130, 5, 3443);
    			add_location(br2, file$e, 131, 2, 3508);
    			attr_dev(input4, "class", "lg svelte-huwp3f");
    			attr_dev(input4, "type", "text");
    			add_location(input4, file$e, 132, 5, 3520);
    			add_location(br3, file$e, 133, 2, 3585);
    			attr_dev(input5, "type", "checkbox");
    			attr_dev(input5, "class", "svelte-huwp3f");
    			add_location(input5, file$e, 135, 8, 3601);
    			attr_dev(input6, "type", "checkbox");
    			attr_dev(input6, "class", "svelte-huwp3f");
    			add_location(input6, file$e, 136, 9, 3658);
    			attr_dev(input7, "type", "checkbox");
    			attr_dev(input7, "class", "svelte-huwp3f");
    			add_location(input7, file$e, 138, 7, 3715);
    			attr_dev(input8, "type", "checkbox");
    			attr_dev(input8, "class", "svelte-huwp3f");
    			add_location(input8, file$e, 139, 7, 3769);
    			attr_dev(input9, "type", "checkbox");
    			attr_dev(input9, "class", "svelte-huwp3f");
    			add_location(input9, file$e, 140, 6, 3823);
    			add_location(br4, file$e, 142, 2, 3872);
    			attr_dev(input10, "type", "button");
    			input10.value = input10_value_value = /*paused*/ ctx[1] ? "PLAY" : "PAUSE";
    			attr_dev(input10, "class", "svelte-huwp3f");
    			add_location(input10, file$e, 143, 2, 3881);
    			attr_dev(input11, "type", "button");
    			input11.value = "set to 0";
    			attr_dev(input11, "class", "svelte-huwp3f");
    			add_location(input11, file$e, 148, 2, 3991);
    			attr_dev(input12, "type", "button");
    			input12.value = "set to 2";
    			attr_dev(input12, "class", "svelte-huwp3f");
    			add_location(input12, file$e, 149, 2, 4062);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, br0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, input0, anchor);
    			set_input_value(input0, /*currentTime*/ ctx[2]);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, input1, anchor);
    			set_input_value(input1, /*duration*/ ctx[3]);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, input2, anchor);
    			set_input_value(input2, /*playDrift*/ ctx[13]);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, br1, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, input3, anchor);
    			set_input_value(input3, /*$talkingVideoSrc*/ ctx[11]);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, br2, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, input4, anchor);
    			set_input_value(input4, /*$talkingVideoSrc*/ ctx[11]);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, br3, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, input5, anchor);
    			input5.checked = /*paused*/ ctx[1];
    			insert_dev(target, t9, anchor);
    			insert_dev(target, input6, anchor);
    			input6.checked = /*pausing*/ ctx[9];
    			insert_dev(target, t10, anchor);
    			insert_dev(target, input7, anchor);
    			input7.checked = /*start*/ ctx[0];
    			insert_dev(target, t11, anchor);
    			insert_dev(target, input8, anchor);
    			input8.checked = /*$muted*/ ctx[16];
    			insert_dev(target, t12, anchor);
    			insert_dev(target, input9, anchor);
    			input9.checked = /*loop*/ ctx[4];
    			insert_dev(target, t13, anchor);
    			insert_dev(target, br4, anchor);
    			insert_dev(target, t14, anchor);
    			insert_dev(target, input10, anchor);
    			insert_dev(target, t15, anchor);
    			insert_dev(target, input11, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, input12, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[32]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[33]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[34]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[35]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[36]),
    					listen_dev(input5, "change", /*input5_change_handler*/ ctx[37]),
    					listen_dev(input6, "change", /*input6_change_handler*/ ctx[38]),
    					listen_dev(input7, "change", /*input7_change_handler*/ ctx[39]),
    					listen_dev(input8, "change", /*input8_change_handler*/ ctx[40]),
    					listen_dev(input9, "change", /*input9_change_handler*/ ctx[41]),
    					listen_dev(input10, "click", /*click_handler_1*/ ctx[42], false, false, false),
    					listen_dev(input11, "click", /*click_handler_2*/ ctx[43], false, false, false),
    					listen_dev(input12, "click", /*click_handler_3*/ ctx[44], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*currentTime*/ 4 && input0.value !== /*currentTime*/ ctx[2]) {
    				set_input_value(input0, /*currentTime*/ ctx[2]);
    			}

    			if (dirty[0] & /*duration*/ 8 && input1.value !== /*duration*/ ctx[3]) {
    				set_input_value(input1, /*duration*/ ctx[3]);
    			}

    			if (dirty[0] & /*playDrift*/ 8192 && input2.value !== /*playDrift*/ ctx[13]) {
    				set_input_value(input2, /*playDrift*/ ctx[13]);
    			}

    			if (dirty[0] & /*$talkingVideoSrc*/ 2048 && input3.value !== /*$talkingVideoSrc*/ ctx[11]) {
    				set_input_value(input3, /*$talkingVideoSrc*/ ctx[11]);
    			}

    			if (dirty[0] & /*$talkingVideoSrc*/ 2048 && input4.value !== /*$talkingVideoSrc*/ ctx[11]) {
    				set_input_value(input4, /*$talkingVideoSrc*/ ctx[11]);
    			}

    			if (dirty[0] & /*paused*/ 2) {
    				input5.checked = /*paused*/ ctx[1];
    			}

    			if (dirty[0] & /*pausing*/ 512) {
    				input6.checked = /*pausing*/ ctx[9];
    			}

    			if (dirty[0] & /*start*/ 1) {
    				input7.checked = /*start*/ ctx[0];
    			}

    			if (dirty[0] & /*$muted*/ 65536) {
    				input8.checked = /*$muted*/ ctx[16];
    			}

    			if (dirty[0] & /*loop*/ 16) {
    				input9.checked = /*loop*/ ctx[4];
    			}

    			if (dirty[0] & /*paused*/ 2 && input10_value_value !== (input10_value_value = /*paused*/ ctx[1] ? "PLAY" : "PAUSE")) {
    				prop_dev(input10, "value", input10_value_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(br0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(input0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(input1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(input2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(br1);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(input3);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(br2);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(input4);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(br3);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(input5);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(input6);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(input7);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(input8);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(input9);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(br4);
    			if (detaching) detach_dev(t14);
    			if (detaching) detach_dev(input10);
    			if (detaching) detach_dev(t15);
    			if (detaching) detach_dev(input11);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(input12);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(125:0) {#if debug}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let video;
    	let track;
    	let video_width_value;
    	let video_height_value;
    	let video_class_value;
    	let video_style_value;
    	let video_src_value;
    	let video_autoplay_value;
    	let video_updating = false;
    	let video_animationframe;
    	let video_is_paused = true;
    	let t;
    	let if_block_anchor;
    	let mounted;
    	let dispose;

    	function video_timeupdate_handler() {
    		cancelAnimationFrame(video_animationframe);

    		if (!video.paused) {
    			video_animationframe = raf(video_timeupdate_handler);
    			video_updating = true;
    		}

    		/*video_timeupdate_handler*/ ctx[24].call(video);
    	}

    	let if_block = /*debug*/ ctx[8] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			video = element("video");
    			track = element("track");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$e, 121, 2, 3202);
    			attr_dev(video, "width", video_width_value = /*$video_dimensions*/ ctx[14].x);
    			attr_dev(video, "height", video_height_value = /*$video_dimensions*/ ctx[14].y);
    			video.playsInline = true;
    			attr_dev(video, "class", video_class_value = "" + (null_to_empty(/*$$props*/ ctx[21].class) + " svelte-huwp3f"));

    			attr_dev(video, "style", video_style_value = "" + (`--fade-time: ${/*fadeTime*/ ctx[7]}s; ${!/*interacted*/ ctx[10] && /*start*/ ctx[0]
			? 'cursor: pointer'
			: ''}; ${/*transparent*/ ctx[12] ? 'opacity: 0' : ''}; ${/*style*/ ctx[5]}` + ";"));

    			if (!src_url_equal(video.src, video_src_value = /*$talkingVideoSrc*/ ctx[11])) attr_dev(video, "src", video_src_value);
    			video.muted = /*$muted*/ ctx[16];
    			video.autoplay = video_autoplay_value = !/*paused*/ ctx[1] || /*start*/ ctx[0] && /*$muted*/ ctx[16];
    			video.loop = /*loop*/ ctx[4];
    			video.controls = false;
    			if (/*duration*/ ctx[3] === void 0) add_render_callback(() => /*video_durationchange_handler*/ ctx[25].call(video));
    			toggle_class(video, "fade-out", /*fadeOutPaused*/ ctx[6] && (/*paused*/ ctx[1] || /*pausing*/ ctx[9]));
    			toggle_class(video, "full-screen", /*$isFullScreen*/ ctx[15]);
    			add_location(video, file$e, 68, 0, 1953);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    			append_dev(video, track);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(video, "canplay", /*canplay_handler*/ ctx[23], { once: true }, false, false),
    					listen_dev(video, "timeupdate", video_timeupdate_handler),
    					listen_dev(video, "durationchange", /*video_durationchange_handler*/ ctx[25]),
    					listen_dev(video, "play", /*video_play_pause_handler*/ ctx[26]),
    					listen_dev(video, "pause", /*video_play_pause_handler*/ ctx[26]),
    					listen_dev(
    						video,
    						"click",
    						function () {
    							if (is_function(/*start*/ ctx[0] && /*click_handler*/ ctx[27])) (/*start*/ ctx[0] && /*click_handler*/ ctx[27]).apply(this, arguments);
    						},
    						{ once: true },
    						false,
    						false
    					),
    					listen_dev(video, "pause", /*pause_handler*/ ctx[28], false, false, false),
    					listen_dev(video, "play", /*play_handler*/ ctx[29], false, false, false),
    					listen_dev(video, "seeked", /*seeked_handler*/ ctx[30], false, false, false),
    					listen_dev(video, "ended", /*ended_handler*/ ctx[31], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$video_dimensions*/ 16384 && video_width_value !== (video_width_value = /*$video_dimensions*/ ctx[14].x)) {
    				attr_dev(video, "width", video_width_value);
    			}

    			if (dirty[0] & /*$video_dimensions*/ 16384 && video_height_value !== (video_height_value = /*$video_dimensions*/ ctx[14].y)) {
    				attr_dev(video, "height", video_height_value);
    			}

    			if (dirty[0] & /*$$props*/ 2097152 && video_class_value !== (video_class_value = "" + (null_to_empty(/*$$props*/ ctx[21].class) + " svelte-huwp3f"))) {
    				attr_dev(video, "class", video_class_value);
    			}

    			if (dirty[0] & /*fadeTime, interacted, start, transparent, style*/ 5281 && video_style_value !== (video_style_value = "" + (`--fade-time: ${/*fadeTime*/ ctx[7]}s; ${!/*interacted*/ ctx[10] && /*start*/ ctx[0]
			? 'cursor: pointer'
			: ''}; ${/*transparent*/ ctx[12] ? 'opacity: 0' : ''}; ${/*style*/ ctx[5]}` + ";"))) {
    				attr_dev(video, "style", video_style_value);
    			}

    			if (dirty[0] & /*$talkingVideoSrc*/ 2048 && !src_url_equal(video.src, video_src_value = /*$talkingVideoSrc*/ ctx[11])) {
    				attr_dev(video, "src", video_src_value);
    			}

    			if (dirty[0] & /*$muted*/ 65536) {
    				prop_dev(video, "muted", /*$muted*/ ctx[16]);
    			}

    			if (dirty[0] & /*paused, start, $muted*/ 65539 && video_autoplay_value !== (video_autoplay_value = !/*paused*/ ctx[1] || /*start*/ ctx[0] && /*$muted*/ ctx[16])) {
    				prop_dev(video, "autoplay", video_autoplay_value);
    			}

    			if (dirty[0] & /*loop*/ 16) {
    				prop_dev(video, "loop", /*loop*/ ctx[4]);
    			}

    			if (!video_updating && dirty[0] & /*currentTime*/ 4 && !isNaN(/*currentTime*/ ctx[2])) {
    				video.currentTime = /*currentTime*/ ctx[2];
    			}

    			video_updating = false;

    			if (dirty[0] & /*paused*/ 2 && video_is_paused !== (video_is_paused = /*paused*/ ctx[1])) {
    				video[video_is_paused ? "pause" : "play"]();
    			}

    			if (dirty[0] & /*$$props, fadeOutPaused, paused, pausing*/ 2097730) {
    				toggle_class(video, "fade-out", /*fadeOutPaused*/ ctx[6] && (/*paused*/ ctx[1] || /*pausing*/ ctx[9]));
    			}

    			if (dirty[0] & /*$$props, $isFullScreen*/ 2129920) {
    				toggle_class(video, "full-screen", /*$isFullScreen*/ ctx[15]);
    			}

    			if (/*debug*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BLANK = "blank.mp4";

    function instance$h($$self, $$props, $$invalidate) {
    	let $talkingVideoSrc;
    	let $video_dimensions;
    	let $isFullScreen;
    	let $muted;
    	validate_store(talkingVideoSrc, 'talkingVideoSrc');
    	component_subscribe($$self, talkingVideoSrc, $$value => $$invalidate(11, $talkingVideoSrc = $$value));
    	validate_store(video_dimensions, 'video_dimensions');
    	component_subscribe($$self, video_dimensions, $$value => $$invalidate(14, $video_dimensions = $$value));
    	validate_store(isFullScreen, 'isFullScreen');
    	component_subscribe($$self, isFullScreen, $$value => $$invalidate(15, $isFullScreen = $$value));
    	validate_store(muted, 'muted');
    	component_subscribe($$self, muted, $$value => $$invalidate(16, $muted = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoPlayer', slots, []);
    	let { start = true } = $$props;
    	let { loop = false } = $$props;
    	let { style = "" } = $$props;
    	let { fadeOutPaused = true } = $$props;
    	let { fadeTime = 0.3 } = $$props;
    	let { paused = true } = $$props;
    	let { currentTime = 0 } = $$props;
    	let { duration = 0 } = $$props;
    	let pausing = false;
    	let transparent = true;
    	let { debug = false } = $$props;

    	// if the user interacted with the video
    	let interacted = false;

    	const dispatch = createEventDispatcher();

    	const setTime = t => {
    		$$invalidate(2, currentTime = t);
    		!paused && setVideoStartTime(currentTime * 1000);
    	};

    	const play = () => {
    		if (paused) {
    			setVideoStartTime(currentTime * 1000);
    			$$invalidate(1, paused = false);
    		}
    	};

    	// for debug
    	const now = () => window.performance.now();

    	let videoStartTime;
    	const setVideoStartTime = (elapsed = 0) => $$invalidate(22, videoStartTime = now() - elapsed);
    	let playDrift;
    	const canplay_handler = () => dispatch("ready");

    	function video_timeupdate_handler() {
    		currentTime = this.currentTime;
    		$$invalidate(2, currentTime);
    	}

    	function video_durationchange_handler() {
    		duration = this.duration;
    		$$invalidate(3, duration);
    	}

    	function video_play_pause_handler() {
    		paused = this.paused;
    		((($$invalidate(1, paused), $$invalidate(11, $talkingVideoSrc)), $$invalidate(10, interacted)), $$invalidate(0, start));
    	}

    	const click_handler = () => {
    		set_store_value(muted, $muted = false, $muted);
    		$$invalidate(10, interacted = true);
    		play();
    		dispatch("firstClick");
    	};

    	const pause_handler = () => {
    		// pauseRequested = false;
    		// console.log("pausou");
    		dispatch("pause");

    		$$invalidate(2, currentTime = 0);
    		$$invalidate(9, pausing = false);
    	}; //dispatch("paused")

    	const play_handler = () => {
    		setVideoStartTime(currentTime * 1000);
    		$$invalidate(9, pausing = false);
    	}; //        dispatch("play")

    	const seeked_handler = () => {
    		// console.log("SEEKED");
    		setVideoStartTime(currentTime * 1000);

    		$$invalidate(9, pausing = false);
    	}; // dispatch("ready");

    	const ended_handler = () => {
    		// console.log("FIM");
    		dispatch("ended");

    		$$invalidate(2, currentTime = 0);
    		$$invalidate(9, pausing = false);
    	};

    	function input0_input_handler() {
    		currentTime = this.value;
    		$$invalidate(2, currentTime);
    	}

    	function input1_input_handler() {
    		duration = this.value;
    		$$invalidate(3, duration);
    	}

    	function input2_input_handler() {
    		playDrift = this.value;
    		(((((($$invalidate(13, playDrift), $$invalidate(1, paused)), $$invalidate(22, videoStartTime)), $$invalidate(2, currentTime)), $$invalidate(11, $talkingVideoSrc)), $$invalidate(10, interacted)), $$invalidate(0, start));
    	}

    	function input3_input_handler() {
    		$talkingVideoSrc = this.value;
    		talkingVideoSrc.set($talkingVideoSrc);
    	}

    	function input4_input_handler() {
    		$talkingVideoSrc = this.value;
    		talkingVideoSrc.set($talkingVideoSrc);
    	}

    	function input5_change_handler() {
    		paused = this.checked;
    		((($$invalidate(1, paused), $$invalidate(11, $talkingVideoSrc)), $$invalidate(10, interacted)), $$invalidate(0, start));
    	}

    	function input6_change_handler() {
    		pausing = this.checked;
    		((((((($$invalidate(9, pausing), $$invalidate(11, $talkingVideoSrc)), $$invalidate(10, interacted)), $$invalidate(0, start)), $$invalidate(3, duration)), $$invalidate(1, paused)), $$invalidate(2, currentTime)), $$invalidate(7, fadeTime));
    	}

    	function input7_change_handler() {
    		start = this.checked;
    		$$invalidate(0, start);
    	}

    	function input8_change_handler() {
    		$muted = this.checked;
    		muted.set($muted);
    	}

    	function input9_change_handler() {
    		loop = this.checked;
    		$$invalidate(4, loop);
    	}

    	const click_handler_1 = () => $$invalidate(1, paused = !paused);
    	const click_handler_2 = () => setTime(0);
    	const click_handler_3 = () => setTime(2);

    	$$self.$$set = $$new_props => {
    		$$invalidate(21, $$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props)));
    		if ('start' in $$new_props) $$invalidate(0, start = $$new_props.start);
    		if ('loop' in $$new_props) $$invalidate(4, loop = $$new_props.loop);
    		if ('style' in $$new_props) $$invalidate(5, style = $$new_props.style);
    		if ('fadeOutPaused' in $$new_props) $$invalidate(6, fadeOutPaused = $$new_props.fadeOutPaused);
    		if ('fadeTime' in $$new_props) $$invalidate(7, fadeTime = $$new_props.fadeTime);
    		if ('paused' in $$new_props) $$invalidate(1, paused = $$new_props.paused);
    		if ('currentTime' in $$new_props) $$invalidate(2, currentTime = $$new_props.currentTime);
    		if ('duration' in $$new_props) $$invalidate(3, duration = $$new_props.duration);
    		if ('debug' in $$new_props) $$invalidate(8, debug = $$new_props.debug);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		muted,
    		talkingVideoSrc,
    		video_dimensions,
    		isFullScreen,
    		start,
    		loop,
    		style,
    		fadeOutPaused,
    		fadeTime,
    		paused,
    		currentTime,
    		duration,
    		pausing,
    		transparent,
    		debug,
    		interacted,
    		dispatch,
    		setTime,
    		play,
    		BLANK,
    		now,
    		videoStartTime,
    		setVideoStartTime,
    		playDrift,
    		$talkingVideoSrc,
    		$video_dimensions,
    		$isFullScreen,
    		$muted
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(21, $$props = assign$4(assign$4({}, $$props), $$new_props));
    		if ('start' in $$props) $$invalidate(0, start = $$new_props.start);
    		if ('loop' in $$props) $$invalidate(4, loop = $$new_props.loop);
    		if ('style' in $$props) $$invalidate(5, style = $$new_props.style);
    		if ('fadeOutPaused' in $$props) $$invalidate(6, fadeOutPaused = $$new_props.fadeOutPaused);
    		if ('fadeTime' in $$props) $$invalidate(7, fadeTime = $$new_props.fadeTime);
    		if ('paused' in $$props) $$invalidate(1, paused = $$new_props.paused);
    		if ('currentTime' in $$props) $$invalidate(2, currentTime = $$new_props.currentTime);
    		if ('duration' in $$props) $$invalidate(3, duration = $$new_props.duration);
    		if ('pausing' in $$props) $$invalidate(9, pausing = $$new_props.pausing);
    		if ('transparent' in $$props) $$invalidate(12, transparent = $$new_props.transparent);
    		if ('debug' in $$props) $$invalidate(8, debug = $$new_props.debug);
    		if ('interacted' in $$props) $$invalidate(10, interacted = $$new_props.interacted);
    		if ('videoStartTime' in $$props) $$invalidate(22, videoStartTime = $$new_props.videoStartTime);
    		if ('playDrift' in $$props) $$invalidate(13, playDrift = $$new_props.playDrift);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$talkingVideoSrc, interacted, start*/ 3073) {
    			{
    				if ($talkingVideoSrc) {
    					$$invalidate(1, paused = true);
    					$$invalidate(9, pausing = false);
    					$$invalidate(12, transparent = $talkingVideoSrc === BLANK);
    					dispatch("displayChatMessage");

    					if (interacted && start) {
    						$$invalidate(1, paused = false);
    					}
    				} else {
    					if (start) {
    						$$invalidate(12, transparent = true);
    						set_store_value(talkingVideoSrc, $talkingVideoSrc = BLANK, $talkingVideoSrc);
    					}
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*duration, paused, pausing, currentTime, fadeTime*/ 654) {
    			if (duration > 0 && !paused && !pausing && currentTime + fadeTime >= duration) {
    				// console.log("GETTING TO THE END O FVIDEO");
    				$$invalidate(9, pausing = true);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*paused, videoStartTime, currentTime*/ 4194310) {
    			!paused && $$invalidate(13, playDrift = now() - videoStartTime - currentTime * 1000);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		start,
    		paused,
    		currentTime,
    		duration,
    		loop,
    		style,
    		fadeOutPaused,
    		fadeTime,
    		debug,
    		pausing,
    		interacted,
    		$talkingVideoSrc,
    		transparent,
    		playDrift,
    		$video_dimensions,
    		$isFullScreen,
    		$muted,
    		dispatch,
    		setTime,
    		play,
    		setVideoStartTime,
    		$$props,
    		videoStartTime,
    		canplay_handler,
    		video_timeupdate_handler,
    		video_durationchange_handler,
    		video_play_pause_handler,
    		click_handler,
    		pause_handler,
    		play_handler,
    		seeked_handler,
    		ended_handler,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_change_handler,
    		input6_change_handler,
    		input7_change_handler,
    		input8_change_handler,
    		input9_change_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	];
    }

    class VideoPlayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$h,
    			create_fragment$l,
    			safe_not_equal,
    			{
    				start: 0,
    				loop: 4,
    				style: 5,
    				fadeOutPaused: 6,
    				fadeTime: 7,
    				paused: 1,
    				currentTime: 2,
    				duration: 3,
    				debug: 8
    			},
    			add_css$5,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoPlayer",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get start() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loop() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loop(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fadeOutPaused() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fadeOutPaused(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fadeTime() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fadeTime(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get paused() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paused(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentTime() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentTime(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get duration() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get debug() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set debug(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/VideoMixer1/VideoPlayerIdle.svelte generated by Svelte v3.47.0 */
    const file$d = "src/components/VideoMixer1/VideoPlayerIdle.svelte";

    function add_css$4(target) {
    	append_styles(target, "svelte-1taf8bz", "video.svelte-1taf8bz{width:100%;min-width:40vw;border-radius:1em;transition:opacity var(--fade-time) ease;box-shadow:0px 0px 18px -10px rgba(var(--shadow), 0.4)}.lg.svelte-1taf8bz{width:30em}@media only screen and (max-width: 600px){video.svelte-1taf8bz{border-radius:1em 1em 0 0}}.fade-out.svelte-1taf8bz{opacity:0}.full-screen.svelte-1taf8bz{width:100vw;height:100vh;object-fit:cover;z-index:0}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlkZW9QbGF5ZXJJZGxlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFtREUsS0FBSyxlQUFDLENBQUEsQUFDSixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxJQUFJLENBQ2YsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsVUFBVSxDQUFFLE9BQU8sQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FDekMsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDekQsQ0FBQSxBQUVBLEdBQUcsZUFBQyxDQUFBLEFBQ0YsS0FBSyxDQUFFLElBQUksQUFDYixDQUFBLEFBRUEsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDeEMsS0FBSyxlQUFDLENBQUEsQUFDSixhQUFhLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUM1QixDQUFBLEFBQ0YsQ0FBQSxBQUVBLFNBQVMsZUFBQyxDQUFBLEFBRVIsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFBLEFBRUEsWUFBWSxlQUFDLENBQUEsQUFDWCxLQUFLLENBQUUsS0FBSyxDQUNaLE1BQU0sQ0FBRSxLQUFLLENBQ2IsVUFBVSxDQUFFLEtBQUssQ0FDakIsT0FBTyxDQUFFLENBQUMsQUFDWixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlZpZGVvUGxheWVySWRsZS5zdmVsdGUiXX0= */");
    }

    function create_fragment$k(ctx) {
    	let video;
    	let track;
    	let video_class_value;
    	let video_style_value;
    	let video_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			video = element("video");
    			track = element("track");
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$d, 37, 2, 1068);
    			video.playsInline = true;
    			attr_dev(video, "class", video_class_value = "" + (null_to_empty(/*$$props*/ ctx[7].class) + " svelte-1taf8bz"));
    			attr_dev(video, "style", video_style_value = "" + (`${!/*interacted*/ ctx[4] ? 'cursor: pointer' : ''}; ${/*style*/ ctx[0]}` + ";"));
    			if (!src_url_equal(video.src, video_src_value = /*src*/ ctx[1])) attr_dev(video, "src", video_src_value);
    			video.muted = true;
    			video.autoplay = true;
    			video.loop = true;
    			video.controls = false;
    			toggle_class(video, "full-screen", /*$isFullScreen*/ ctx[3]);
    			add_location(video, file$d, 24, 0, 792);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    			append_dev(video, track);
    			/*video_binding*/ ctx[8](video);

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "resize", /*update_video_dimensions*/ ctx[6], false, false, false),
    					listen_dev(video, "canplay", /*on_ready*/ ctx[5], { once: true }, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$$props*/ 128 && video_class_value !== (video_class_value = "" + (null_to_empty(/*$$props*/ ctx[7].class) + " svelte-1taf8bz"))) {
    				attr_dev(video, "class", video_class_value);
    			}

    			if (dirty & /*style*/ 1 && video_style_value !== (video_style_value = "" + (`${!/*interacted*/ ctx[4] ? 'cursor: pointer' : ''}; ${/*style*/ ctx[0]}` + ";"))) {
    				attr_dev(video, "style", video_style_value);
    			}

    			if (dirty & /*src*/ 2 && !src_url_equal(video.src, video_src_value = /*src*/ ctx[1])) {
    				attr_dev(video, "src", video_src_value);
    			}

    			if (dirty & /*$$props, $isFullScreen*/ 136) {
    				toggle_class(video, "full-screen", /*$isFullScreen*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    			/*video_binding*/ ctx[8](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $isFullScreen;
    	let $video_dimensions;
    	validate_store(isFullScreen, 'isFullScreen');
    	component_subscribe($$self, isFullScreen, $$value => $$invalidate(3, $isFullScreen = $$value));
    	validate_store(video_dimensions, 'video_dimensions');
    	component_subscribe($$self, video_dimensions, $$value => $$invalidate(9, $video_dimensions = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoPlayerIdle', slots, []);
    	const dispatch = createEventDispatcher();
    	let { style = "" } = $$props;
    	let { src = undefined } = $$props;

    	// if the user interacted with the video
    	let interacted = false;

    	let videoRef;

    	const on_ready = () => {
    		update_video_dimensions();
    		dispatch("ready");
    	};

    	const update_video_dimensions = () => {
    		set_store_value(
    			video_dimensions,
    			$video_dimensions = {
    				x: videoRef.clientWidth,
    				y: videoRef.clientHeight
    			},
    			$video_dimensions
    		);
    	};

    	function video_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			videoRef = $$value;
    			$$invalidate(2, videoRef);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(7, $$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props)));
    		if ('style' in $$new_props) $$invalidate(0, style = $$new_props.style);
    		if ('src' in $$new_props) $$invalidate(1, src = $$new_props.src);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		tick,
    		video_dimensions,
    		isFullScreen,
    		dispatch,
    		style,
    		src,
    		interacted,
    		videoRef,
    		on_ready,
    		update_video_dimensions,
    		$isFullScreen,
    		$video_dimensions
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(7, $$props = assign$4(assign$4({}, $$props), $$new_props));
    		if ('style' in $$props) $$invalidate(0, style = $$new_props.style);
    		if ('src' in $$props) $$invalidate(1, src = $$new_props.src);
    		if ('interacted' in $$props) $$invalidate(4, interacted = $$new_props.interacted);
    		if ('videoRef' in $$props) $$invalidate(2, videoRef = $$new_props.videoRef);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$isFullScreen, videoRef*/ 12) {
    			(videoRef && void tick().then(() => update_video_dimensions()));
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		style,
    		src,
    		videoRef,
    		$isFullScreen,
    		interacted,
    		on_ready,
    		update_video_dimensions,
    		$$props,
    		video_binding
    	];
    }

    class VideoPlayerIdle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$g, create_fragment$k, safe_not_equal, { style: 0, src: 1 }, add_css$4);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoPlayerIdle",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get style() {
    		throw new Error("<VideoPlayerIdle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<VideoPlayerIdle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get src() {
    		throw new Error("<VideoPlayerIdle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<VideoPlayerIdle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/VideoMixer1/VideoMixer1.svelte generated by Svelte v3.47.0 */

    // (63:0) <VideoMixerPlaceholder   bind:sessionCount   bind:show_count   bind:name   bind:opmode   bind:start   on:skip={() => dispatch("skip")}   on:replay={() => dispatch("replay")} >
    function create_default_slot$4(ctx) {
    	let videoplayeridle;
    	let updating_src;
    	let updating_currentTime;
    	let t;
    	let videoplayer;
    	let updating_src_1;
    	let updating_paused;
    	let updating_currentTime_1;
    	let current;

    	function videoplayeridle_src_binding(value) {
    		/*videoplayeridle_src_binding*/ ctx[21](value);
    	}

    	function videoplayeridle_currentTime_binding(value) {
    		/*videoplayeridle_currentTime_binding*/ ctx[22](value);
    	}

    	let videoplayeridle_props = {
    		class: "video-item",
    		fadeOutPaused: false,
    		start: true,
    		muted: true,
    		loop: true
    	};

    	if (/*idleVideoSrc*/ ctx[6] !== void 0) {
    		videoplayeridle_props.src = /*idleVideoSrc*/ ctx[6];
    	}

    	if (/*idleCurrentTime*/ ctx[11] !== void 0) {
    		videoplayeridle_props.currentTime = /*idleCurrentTime*/ ctx[11];
    	}

    	videoplayeridle = new VideoPlayerIdle({
    			props: videoplayeridle_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(videoplayeridle, 'src', videoplayeridle_src_binding));
    	binding_callbacks.push(() => bind(videoplayeridle, 'currentTime', videoplayeridle_currentTime_binding));
    	videoplayeridle.$on("ready", once(/*ready_handler*/ ctx[23]));

    	function videoplayer_src_binding(value) {
    		/*videoplayer_src_binding*/ ctx[24](value);
    	}

    	function videoplayer_paused_binding(value) {
    		/*videoplayer_paused_binding*/ ctx[25](value);
    	}

    	function videoplayer_currentTime_binding(value) {
    		/*videoplayer_currentTime_binding*/ ctx[26](value);
    	}

    	let videoplayer_props = {
    		class: `video-item ${/*start*/ ctx[10] ? "full-screen-video" : ""}`,
    		fadeOutPaused: true,
    		start: true,
    		loop: false,
    		debug: false
    	};

    	if (/*currentVideoSrc*/ ctx[9] !== void 0) {
    		videoplayer_props.src = /*currentVideoSrc*/ ctx[9];
    	}

    	if (/*paused*/ ctx[0] !== void 0) {
    		videoplayer_props.paused = /*paused*/ ctx[0];
    	}

    	if (/*currentTime*/ ctx[1] !== void 0) {
    		videoplayer_props.currentTime = /*currentTime*/ ctx[1];
    	}

    	videoplayer = new VideoPlayer({ props: videoplayer_props, $$inline: true });
    	binding_callbacks.push(() => bind(videoplayer, 'src', videoplayer_src_binding));
    	binding_callbacks.push(() => bind(videoplayer, 'paused', videoplayer_paused_binding));
    	binding_callbacks.push(() => bind(videoplayer, 'currentTime', videoplayer_currentTime_binding));
    	videoplayer.$on("play", /*play_handler*/ ctx[27]);
    	videoplayer.$on("ready", once(/*ready_handler_1*/ ctx[28]));
    	videoplayer.$on("ended", /*ended_handler*/ ctx[29]);
    	videoplayer.$on("pause", /*pause_handler*/ ctx[30]);
    	videoplayer.$on("firstClick", /*firstClick_handler*/ ctx[31]);
    	videoplayer.$on("displayChatMessage", /*displayChatMessage*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(videoplayeridle.$$.fragment);
    			t = space();
    			create_component(videoplayer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videoplayeridle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(videoplayer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoplayeridle_changes = {};

    			if (!updating_src && dirty[0] & /*idleVideoSrc*/ 64) {
    				updating_src = true;
    				videoplayeridle_changes.src = /*idleVideoSrc*/ ctx[6];
    				add_flush_callback(() => updating_src = false);
    			}

    			if (!updating_currentTime && dirty[0] & /*idleCurrentTime*/ 2048) {
    				updating_currentTime = true;
    				videoplayeridle_changes.currentTime = /*idleCurrentTime*/ ctx[11];
    				add_flush_callback(() => updating_currentTime = false);
    			}

    			videoplayeridle.$set(videoplayeridle_changes);
    			const videoplayer_changes = {};
    			if (dirty[0] & /*start*/ 1024) videoplayer_changes.class = `video-item ${/*start*/ ctx[10] ? "full-screen-video" : ""}`;

    			if (!updating_src_1 && dirty[0] & /*currentVideoSrc*/ 512) {
    				updating_src_1 = true;
    				videoplayer_changes.src = /*currentVideoSrc*/ ctx[9];
    				add_flush_callback(() => updating_src_1 = false);
    			}

    			if (!updating_paused && dirty[0] & /*paused*/ 1) {
    				updating_paused = true;
    				videoplayer_changes.paused = /*paused*/ ctx[0];
    				add_flush_callback(() => updating_paused = false);
    			}

    			if (!updating_currentTime_1 && dirty[0] & /*currentTime*/ 2) {
    				updating_currentTime_1 = true;
    				videoplayer_changes.currentTime = /*currentTime*/ ctx[1];
    				add_flush_callback(() => updating_currentTime_1 = false);
    			}

    			videoplayer.$set(videoplayer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoplayeridle.$$.fragment, local);
    			transition_in(videoplayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoplayeridle.$$.fragment, local);
    			transition_out(videoplayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videoplayeridle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(videoplayer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(63:0) <VideoMixerPlaceholder   bind:sessionCount   bind:show_count   bind:name   bind:opmode   bind:start   on:skip={() => dispatch(\\\"skip\\\")}   on:replay={() => dispatch(\\\"replay\\\")} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let videomixerplaceholder;
    	let updating_sessionCount;
    	let updating_show_count;
    	let updating_name;
    	let updating_opmode;
    	let updating_start;
    	let current;

    	function videomixerplaceholder_sessionCount_binding(value) {
    		/*videomixerplaceholder_sessionCount_binding*/ ctx[32](value);
    	}

    	function videomixerplaceholder_show_count_binding(value) {
    		/*videomixerplaceholder_show_count_binding*/ ctx[33](value);
    	}

    	function videomixerplaceholder_name_binding(value) {
    		/*videomixerplaceholder_name_binding*/ ctx[34](value);
    	}

    	function videomixerplaceholder_opmode_binding(value) {
    		/*videomixerplaceholder_opmode_binding*/ ctx[35](value);
    	}

    	function videomixerplaceholder_start_binding(value) {
    		/*videomixerplaceholder_start_binding*/ ctx[36](value);
    	}

    	let videomixerplaceholder_props = {
    		$$slots: { default: [create_default_slot$4] },
    		$$scope: { ctx }
    	};

    	if (/*sessionCount*/ ctx[2] !== void 0) {
    		videomixerplaceholder_props.sessionCount = /*sessionCount*/ ctx[2];
    	}

    	if (/*show_count*/ ctx[3] !== void 0) {
    		videomixerplaceholder_props.show_count = /*show_count*/ ctx[3];
    	}

    	if (/*name*/ ctx[4] !== void 0) {
    		videomixerplaceholder_props.name = /*name*/ ctx[4];
    	}

    	if (/*opmode*/ ctx[5] !== void 0) {
    		videomixerplaceholder_props.opmode = /*opmode*/ ctx[5];
    	}

    	if (/*start*/ ctx[10] !== void 0) {
    		videomixerplaceholder_props.start = /*start*/ ctx[10];
    	}

    	videomixerplaceholder = new VideoMixerPlaceholder({
    			props: videomixerplaceholder_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(videomixerplaceholder, 'sessionCount', videomixerplaceholder_sessionCount_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'show_count', videomixerplaceholder_show_count_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'name', videomixerplaceholder_name_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'opmode', videomixerplaceholder_opmode_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'start', videomixerplaceholder_start_binding));
    	videomixerplaceholder.$on("skip", /*skip_handler*/ ctx[37]);
    	videomixerplaceholder.$on("replay", /*replay_handler*/ ctx[38]);

    	const block = {
    		c: function create() {
    			create_component(videomixerplaceholder.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(videomixerplaceholder, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videomixerplaceholder_changes = {};

    			if (dirty[0] & /*start, currentVideoSrc, paused, currentTime, idleCurrentTime, talkingVideoReady, idleVideoSrc, idleVIdeoReady*/ 4035 | dirty[1] & /*$$scope*/ 1024) {
    				videomixerplaceholder_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_sessionCount && dirty[0] & /*sessionCount*/ 4) {
    				updating_sessionCount = true;
    				videomixerplaceholder_changes.sessionCount = /*sessionCount*/ ctx[2];
    				add_flush_callback(() => updating_sessionCount = false);
    			}

    			if (!updating_show_count && dirty[0] & /*show_count*/ 8) {
    				updating_show_count = true;
    				videomixerplaceholder_changes.show_count = /*show_count*/ ctx[3];
    				add_flush_callback(() => updating_show_count = false);
    			}

    			if (!updating_name && dirty[0] & /*name*/ 16) {
    				updating_name = true;
    				videomixerplaceholder_changes.name = /*name*/ ctx[4];
    				add_flush_callback(() => updating_name = false);
    			}

    			if (!updating_opmode && dirty[0] & /*opmode*/ 32) {
    				updating_opmode = true;
    				videomixerplaceholder_changes.opmode = /*opmode*/ ctx[5];
    				add_flush_callback(() => updating_opmode = false);
    			}

    			if (!updating_start && dirty[0] & /*start*/ 1024) {
    				updating_start = true;
    				videomixerplaceholder_changes.start = /*start*/ ctx[10];
    				add_flush_callback(() => updating_start = false);
    			}

    			videomixerplaceholder.$set(videomixerplaceholder_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videomixerplaceholder.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videomixerplaceholder.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videomixerplaceholder, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $backendWriting;
    	let $talkingVideoSrc;
    	let $cancelBackendWriting;
    	validate_store(backendWriting, 'backendWriting');
    	component_subscribe($$self, backendWriting, $$value => $$invalidate(39, $backendWriting = $$value));
    	validate_store(talkingVideoSrc, 'talkingVideoSrc');
    	component_subscribe($$self, talkingVideoSrc, $$value => $$invalidate(40, $talkingVideoSrc = $$value));
    	validate_store(cancelBackendWriting, 'cancelBackendWriting');
    	component_subscribe($$self, cancelBackendWriting, $$value => $$invalidate(20, $cancelBackendWriting = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoMixer1', slots, []);
    	const dispatch = createEventDispatcher();
    	let { paused = true } = $$props;
    	let { currentTime = 0 } = $$props;
    	let { sessionCount = 0 } = $$props;
    	let { show_count = false } = $$props;
    	let { name } = $$props;
    	let { opmode = "ttt" } = $$props;
    	let { idleVideoSrc = undefined } = $$props;
    	let currentVideoSrc;

    	const on_video_received = replay => {
    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);

    		if (writingTimeout) {
    			clearTimeout(writingTimeout);
    			$$invalidate(19, writingTimeout = null);
    		}

    		if (replay) {
    			skipTalkingVideo();
    			const old = $talkingVideoSrc;
    			set_store_value(talkingVideoSrc, $talkingVideoSrc = undefined, $talkingVideoSrc);
    			set_store_value(talkingVideoSrc, $talkingVideoSrc = old, $talkingVideoSrc);
    		}
    	};

    	const on_cache_check = undefined;

    	const skipTalkingVideo = () => {
    		$$invalidate(0, paused = true);
    		$$invalidate(1, currentTime = 0);
    	};

    	let writingTimeout = null;

    	const on_video_synth_error = () => {
    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);

    		if (writingTimeout) {
    			clearTimeout(writingTimeout);
    			$$invalidate(19, writingTimeout = null);
    		}

    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);
    	};

    	const on_enter = () => {
    		$$invalidate(19, writingTimeout = setTimeout(
    			() => {
    				set_store_value(backendWriting, $backendWriting = true, $backendWriting);
    			},
    			1000
    		));
    	};

    	let start = true;
    	let idleCurrentTime = 0;
    	let idleVIdeoReady = false;
    	let talkingVideoReady = false;

    	const displayChatMessage = () => {
    		dispatch("displayChatMessage", $talkingVideoSrc);
    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);
    	};

    	const writable_props = [
    		'paused',
    		'currentTime',
    		'sessionCount',
    		'show_count',
    		'name',
    		'opmode',
    		'idleVideoSrc'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoMixer1> was created with unknown prop '${key}'`);
    	});

    	function videoplayeridle_src_binding(value) {
    		idleVideoSrc = value;
    		$$invalidate(6, idleVideoSrc);
    	}

    	function videoplayeridle_currentTime_binding(value) {
    		idleCurrentTime = value;
    		$$invalidate(11, idleCurrentTime);
    	}

    	const ready_handler = () => {
    		$$invalidate(7, idleVIdeoReady = true);
    	};

    	function videoplayer_src_binding(value) {
    		currentVideoSrc = value;
    		$$invalidate(9, currentVideoSrc);
    	}

    	function videoplayer_paused_binding(value) {
    		paused = value;
    		$$invalidate(0, paused);
    	}

    	function videoplayer_currentTime_binding(value) {
    		currentTime = value;
    		$$invalidate(1, currentTime);
    	}

    	const play_handler = () => {
    		setTimeout(
    			() => {
    				$$invalidate(11, idleCurrentTime = currentTime);
    			},
    			400
    		);
    	};

    	const ready_handler_1 = () => {
    		$$invalidate(8, talkingVideoReady = true);
    	};

    	const ended_handler = () => dispatch("talking_end");

    	function pause_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const firstClick_handler = () => {
    		$$invalidate(10, start = false);
    	};

    	function videomixerplaceholder_sessionCount_binding(value) {
    		sessionCount = value;
    		$$invalidate(2, sessionCount);
    	}

    	function videomixerplaceholder_show_count_binding(value) {
    		show_count = value;
    		$$invalidate(3, show_count);
    	}

    	function videomixerplaceholder_name_binding(value) {
    		name = value;
    		$$invalidate(4, name);
    	}

    	function videomixerplaceholder_opmode_binding(value) {
    		opmode = value;
    		$$invalidate(5, opmode);
    	}

    	function videomixerplaceholder_start_binding(value) {
    		start = value;
    		$$invalidate(10, start);
    	}

    	const skip_handler = () => dispatch("skip");
    	const replay_handler = () => dispatch("replay");

    	$$self.$$set = $$props => {
    		if ('paused' in $$props) $$invalidate(0, paused = $$props.paused);
    		if ('currentTime' in $$props) $$invalidate(1, currentTime = $$props.currentTime);
    		if ('sessionCount' in $$props) $$invalidate(2, sessionCount = $$props.sessionCount);
    		if ('show_count' in $$props) $$invalidate(3, show_count = $$props.show_count);
    		if ('name' in $$props) $$invalidate(4, name = $$props.name);
    		if ('opmode' in $$props) $$invalidate(5, opmode = $$props.opmode);
    		if ('idleVideoSrc' in $$props) $$invalidate(6, idleVideoSrc = $$props.idleVideoSrc);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		VideoMixerPlaceholder,
    		VideoPlayer,
    		VideoPlayerIdle,
    		backendWriting,
    		talkingVideoSrc,
    		cancelBackendWriting,
    		dispatch,
    		paused,
    		currentTime,
    		sessionCount,
    		show_count,
    		name,
    		opmode,
    		idleVideoSrc,
    		currentVideoSrc,
    		on_video_received,
    		on_cache_check,
    		skipTalkingVideo,
    		writingTimeout,
    		on_video_synth_error,
    		on_enter,
    		start,
    		idleCurrentTime,
    		idleVIdeoReady,
    		talkingVideoReady,
    		displayChatMessage,
    		$backendWriting,
    		$talkingVideoSrc,
    		$cancelBackendWriting
    	});

    	$$self.$inject_state = $$props => {
    		if ('paused' in $$props) $$invalidate(0, paused = $$props.paused);
    		if ('currentTime' in $$props) $$invalidate(1, currentTime = $$props.currentTime);
    		if ('sessionCount' in $$props) $$invalidate(2, sessionCount = $$props.sessionCount);
    		if ('show_count' in $$props) $$invalidate(3, show_count = $$props.show_count);
    		if ('name' in $$props) $$invalidate(4, name = $$props.name);
    		if ('opmode' in $$props) $$invalidate(5, opmode = $$props.opmode);
    		if ('idleVideoSrc' in $$props) $$invalidate(6, idleVideoSrc = $$props.idleVideoSrc);
    		if ('currentVideoSrc' in $$props) $$invalidate(9, currentVideoSrc = $$props.currentVideoSrc);
    		if ('writingTimeout' in $$props) $$invalidate(19, writingTimeout = $$props.writingTimeout);
    		if ('start' in $$props) $$invalidate(10, start = $$props.start);
    		if ('idleCurrentTime' in $$props) $$invalidate(11, idleCurrentTime = $$props.idleCurrentTime);
    		if ('idleVIdeoReady' in $$props) $$invalidate(7, idleVIdeoReady = $$props.idleVIdeoReady);
    		if ('talkingVideoReady' in $$props) $$invalidate(8, talkingVideoReady = $$props.talkingVideoReady);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$cancelBackendWriting, writingTimeout*/ 1572864) {
    			if ($cancelBackendWriting) (clearTimeout(writingTimeout), set_store_value(cancelBackendWriting, $cancelBackendWriting = false, $cancelBackendWriting));
    		}

    		if ($$self.$$.dirty[0] & /*talkingVideoReady, idleVIdeoReady*/ 384) {
    			if (talkingVideoReady && idleVIdeoReady) dispatch("ready");
    		}
    	};

    	return [
    		paused,
    		currentTime,
    		sessionCount,
    		show_count,
    		name,
    		opmode,
    		idleVideoSrc,
    		idleVIdeoReady,
    		talkingVideoReady,
    		currentVideoSrc,
    		start,
    		idleCurrentTime,
    		dispatch,
    		displayChatMessage,
    		on_video_received,
    		on_cache_check,
    		skipTalkingVideo,
    		on_video_synth_error,
    		on_enter,
    		writingTimeout,
    		$cancelBackendWriting,
    		videoplayeridle_src_binding,
    		videoplayeridle_currentTime_binding,
    		ready_handler,
    		videoplayer_src_binding,
    		videoplayer_paused_binding,
    		videoplayer_currentTime_binding,
    		play_handler,
    		ready_handler_1,
    		ended_handler,
    		pause_handler,
    		firstClick_handler,
    		videomixerplaceholder_sessionCount_binding,
    		videomixerplaceholder_show_count_binding,
    		videomixerplaceholder_name_binding,
    		videomixerplaceholder_opmode_binding,
    		videomixerplaceholder_start_binding,
    		skip_handler,
    		replay_handler
    	];
    }

    class VideoMixer1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$f,
    			create_fragment$j,
    			safe_not_equal,
    			{
    				paused: 0,
    				currentTime: 1,
    				sessionCount: 2,
    				show_count: 3,
    				name: 4,
    				opmode: 5,
    				idleVideoSrc: 6,
    				on_video_received: 14,
    				on_cache_check: 15,
    				skipTalkingVideo: 16,
    				on_video_synth_error: 17,
    				on_enter: 18
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoMixer1",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[4] === undefined && !('name' in props)) {
    			console.warn("<VideoMixer1> was created without expected prop 'name'");
    		}
    	}

    	get paused() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set paused(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentTime() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentTime(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sessionCount() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionCount(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show_count() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show_count(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opmode() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opmode(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get idleVideoSrc() {
    		throw new Error("<VideoMixer1>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set idleVideoSrc(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_video_received() {
    		return this.$$.ctx[14];
    	}

    	set on_video_received(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_cache_check() {
    		return this.$$.ctx[15];
    	}

    	set on_cache_check(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skipTalkingVideo() {
    		return this.$$.ctx[16];
    	}

    	set skipTalkingVideo(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_video_synth_error() {
    		return this.$$.ctx[17];
    	}

    	set on_video_synth_error(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_enter() {
    		return this.$$.ctx[18];
    	}

    	set on_enter(value) {
    		throw new Error("<VideoMixer1>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign$1 = function() {
        __assign$1 = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };

    function __rest$1(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __values$1(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var ActionTypes;

    (function (ActionTypes) {
      ActionTypes["Start"] = "xstate.start";
      ActionTypes["Stop"] = "xstate.stop";
      ActionTypes["Raise"] = "xstate.raise";
      ActionTypes["Send"] = "xstate.send";
      ActionTypes["Cancel"] = "xstate.cancel";
      ActionTypes["NullEvent"] = "";
      ActionTypes["Assign"] = "xstate.assign";
      ActionTypes["After"] = "xstate.after";
      ActionTypes["DoneState"] = "done.state";
      ActionTypes["DoneInvoke"] = "done.invoke";
      ActionTypes["Log"] = "xstate.log";
      ActionTypes["Init"] = "xstate.init";
      ActionTypes["Invoke"] = "xstate.invoke";
      ActionTypes["ErrorExecution"] = "error.execution";
      ActionTypes["ErrorCommunication"] = "error.communication";
      ActionTypes["ErrorPlatform"] = "error.platform";
      ActionTypes["ErrorCustom"] = "xstate.error";
      ActionTypes["Update"] = "xstate.update";
      ActionTypes["Pure"] = "xstate.pure";
      ActionTypes["Choose"] = "xstate.choose";
    })(ActionTypes || (ActionTypes = {}));

    var SpecialTargets;

    (function (SpecialTargets) {
      SpecialTargets["Parent"] = "#_parent";
      SpecialTargets["Internal"] = "#_internal";
    })(SpecialTargets || (SpecialTargets = {}));

    var start$1 = ActionTypes.Start;
    var stop$1 = ActionTypes.Stop;
    var raise$1 = ActionTypes.Raise;
    var send$1 = ActionTypes.Send;
    var cancel$1 = ActionTypes.Cancel;
    var nullEvent = ActionTypes.NullEvent;
    var assign$2 = ActionTypes.Assign;
    ActionTypes.After;
    ActionTypes.DoneState;
    var log = ActionTypes.Log;
    var init = ActionTypes.Init;
    var invoke = ActionTypes.Invoke;
    ActionTypes.ErrorExecution;
    var errorPlatform = ActionTypes.ErrorPlatform;
    var error$1 = ActionTypes.ErrorCustom;
    var update = ActionTypes.Update;
    var choose = ActionTypes.Choose;
    var pure = ActionTypes.Pure;

    var STATE_DELIMITER = '.';
    var EMPTY_ACTIVITY_MAP = {};
    var DEFAULT_GUARD_TYPE = 'xstate.guard';
    var TARGETLESS_KEY = '';

    var IS_PRODUCTION = "production" === 'production';

    var _a;
    function matchesState(parentStateId, childStateId, delimiter) {
      if (delimiter === void 0) {
        delimiter = STATE_DELIMITER;
      }

      var parentStateValue = toStateValue(parentStateId, delimiter);
      var childStateValue = toStateValue(childStateId, delimiter);

      if (isString(childStateValue)) {
        if (isString(parentStateValue)) {
          return childStateValue === parentStateValue;
        } // Parent more specific than child


        return false;
      }

      if (isString(parentStateValue)) {
        return parentStateValue in childStateValue;
      }

      return Object.keys(parentStateValue).every(function (key) {
        if (!(key in childStateValue)) {
          return false;
        }

        return matchesState(parentStateValue[key], childStateValue[key]);
      });
    }
    function getEventType(event) {
      try {
        return isString(event) || typeof event === 'number' ? "".concat(event) : event.type;
      } catch (e) {
        throw new Error('Events must be strings or objects with a string event.type property.');
      }
    }
    function toStatePath(stateId, delimiter) {
      try {
        if (isArray(stateId)) {
          return stateId;
        }

        return stateId.toString().split(delimiter);
      } catch (e) {
        throw new Error("'".concat(stateId, "' is not a valid state path."));
      }
    }
    function isStateLike(state) {
      return typeof state === 'object' && 'value' in state && 'context' in state && 'event' in state && '_event' in state;
    }
    function toStateValue(stateValue, delimiter) {
      if (isStateLike(stateValue)) {
        return stateValue.value;
      }

      if (isArray(stateValue)) {
        return pathToStateValue(stateValue);
      }

      if (typeof stateValue !== 'string') {
        return stateValue;
      }

      var statePath = toStatePath(stateValue, delimiter);
      return pathToStateValue(statePath);
    }
    function pathToStateValue(statePath) {
      if (statePath.length === 1) {
        return statePath[0];
      }

      var value = {};
      var marker = value;

      for (var i = 0; i < statePath.length - 1; i++) {
        if (i === statePath.length - 2) {
          marker[statePath[i]] = statePath[i + 1];
        } else {
          marker[statePath[i]] = {};
          marker = marker[statePath[i]];
        }
      }

      return value;
    }
    function mapValues(collection, iteratee) {
      var result = {};
      var collectionKeys = Object.keys(collection);

      for (var i = 0; i < collectionKeys.length; i++) {
        var key = collectionKeys[i];
        result[key] = iteratee(collection[key], key, collection, i);
      }

      return result;
    }
    function mapFilterValues(collection, iteratee, predicate) {
      var e_1, _a;

      var result = {};

      try {
        for (var _b = __values$1(Object.keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var item = collection[key];

          if (!predicate(item)) {
            continue;
          }

          result[key] = iteratee(item, key, collection);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      return result;
    }
    /**
     * Retrieves a value at the given path.
     * @param props The deep path to the prop of the desired value
     */

    var path = function (props) {
      return function (object) {
        var e_2, _a;

        var result = object;

        try {
          for (var props_1 = __values$1(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
            var prop = props_1_1.value;
            result = result[prop];
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }

        return result;
      };
    };
    /**
     * Retrieves a value at the given path via the nested accessor prop.
     * @param props The deep path to the prop of the desired value
     */

    function nestedPath(props, accessorProp) {
      return function (object) {
        var e_3, _a;

        var result = object;

        try {
          for (var props_2 = __values$1(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
            var prop = props_2_1.value;
            result = result[accessorProp][prop];
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);
          } finally {
            if (e_3) throw e_3.error;
          }
        }

        return result;
      };
    }
    function toStatePaths(stateValue) {
      if (!stateValue) {
        return [[]];
      }

      if (isString(stateValue)) {
        return [[stateValue]];
      }

      var result = flatten(Object.keys(stateValue).map(function (key) {
        var subStateValue = stateValue[key];

        if (typeof subStateValue !== 'string' && (!subStateValue || !Object.keys(subStateValue).length)) {
          return [[key]];
        }

        return toStatePaths(stateValue[key]).map(function (subPath) {
          return [key].concat(subPath);
        });
      }));
      return result;
    }
    function flatten(array) {
      var _a;

      return (_a = []).concat.apply(_a, __spreadArray([], __read(array), false));
    }
    function toArrayStrict(value) {
      if (isArray(value)) {
        return value;
      }

      return [value];
    }
    function toArray(value) {
      if (value === undefined) {
        return [];
      }

      return toArrayStrict(value);
    }
    function mapContext(mapper, context, _event) {
      var e_5, _a;

      if (isFunction(mapper)) {
        return mapper(context, _event.data);
      }

      var result = {};

      try {
        for (var _b = __values$1(Object.keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var subMapper = mapper[key];

          if (isFunction(subMapper)) {
            result[key] = subMapper(context, _event.data);
          } else {
            result[key] = subMapper;
          }
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      return result;
    }
    function isBuiltInEvent(eventType) {
      return /^(done|error)\./.test(eventType);
    }
    function isPromiseLike(value) {
      if (value instanceof Promise) {
        return true;
      } // Check if shape matches the Promise/A+ specification for a "thenable".


      if (value !== null && (isFunction(value) || typeof value === 'object') && isFunction(value.then)) {
        return true;
      }

      return false;
    }
    function isBehavior(value) {
      return value !== null && typeof value === 'object' && 'transition' in value && typeof value.transition === 'function';
    }
    function partition(items, predicate) {
      var e_6, _a;

      var _b = __read([[], []], 2),
          truthy = _b[0],
          falsy = _b[1];

      try {
        for (var items_1 = __values$1(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
          var item = items_1_1.value;

          if (predicate(item)) {
            truthy.push(item);
          } else {
            falsy.push(item);
          }
        }
      } catch (e_6_1) {
        e_6 = {
          error: e_6_1
        };
      } finally {
        try {
          if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
        } finally {
          if (e_6) throw e_6.error;
        }
      }

      return [truthy, falsy];
    }
    function updateHistoryStates(hist, stateValue) {
      return mapValues(hist.states, function (subHist, key) {
        if (!subHist) {
          return undefined;
        }

        var subStateValue = (isString(stateValue) ? undefined : stateValue[key]) || (subHist ? subHist.current : undefined);

        if (!subStateValue) {
          return undefined;
        }

        return {
          current: subStateValue,
          states: updateHistoryStates(subHist, subStateValue)
        };
      });
    }
    function updateHistoryValue(hist, stateValue) {
      return {
        current: stateValue,
        states: updateHistoryStates(hist, stateValue)
      };
    }
    function updateContext(context, _event, assignActions, state) {

      var updatedContext = context ? assignActions.reduce(function (acc, assignAction) {
        var e_7, _a;

        var assignment = assignAction.assignment;
        var meta = {
          state: state,
          action: assignAction,
          _event: _event
        };
        var partialUpdate = {};

        if (isFunction(assignment)) {
          partialUpdate = assignment(acc, _event.data, meta);
        } else {
          try {
            for (var _b = __values$1(Object.keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var key = _c.value;
              var propAssignment = assignment[key];
              partialUpdate[key] = isFunction(propAssignment) ? propAssignment(acc, _event.data, meta) : propAssignment;
            }
          } catch (e_7_1) {
            e_7 = {
              error: e_7_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_7) throw e_7.error;
            }
          }
        }

        return Object.assign({}, acc, partialUpdate);
      }, context) : context;
      return updatedContext;
    } // tslint:disable-next-line:no-empty

    var warn = function () {};
    function isArray(value) {
      return Array.isArray(value);
    } // tslint:disable-next-line:ban-types

    function isFunction(value) {
      return typeof value === 'function';
    }
    function isString(value) {
      return typeof value === 'string';
    }
    function toGuard(condition, guardMap) {
      if (!condition) {
        return undefined;
      }

      if (isString(condition)) {
        return {
          type: DEFAULT_GUARD_TYPE,
          name: condition,
          predicate: guardMap ? guardMap[condition] : undefined
        };
      }

      if (isFunction(condition)) {
        return {
          type: DEFAULT_GUARD_TYPE,
          name: condition.name,
          predicate: condition
        };
      }

      return condition;
    }
    function isObservable(value) {
      try {
        return 'subscribe' in value && isFunction(value.subscribe);
      } catch (e) {
        return false;
      }
    }
    var symbolObservable = /*#__PURE__*/function () {
      return typeof Symbol === 'function' && Symbol.observable || '@@observable';
    }(); // TODO: to be removed in v5, left it out just to minimize the scope of the change and maintain compatibility with older versions of integration paackages

    (_a = {}, _a[symbolObservable] = function () {
      return this;
    }, _a[Symbol.observable] = function () {
      return this;
    }, _a);
    function isMachine(value) {
      return !!value && '__xstatenode' in value;
    }
    function isActor$1(value) {
      return !!value && typeof value.send === 'function';
    }
    function toEventObject(event, payload // id?: TEvent['type']
    ) {
      if (isString(event) || typeof event === 'number') {
        return __assign$1({
          type: event
        }, payload);
      }

      return event;
    }
    function toSCXMLEvent(event, scxmlEvent) {
      if (!isString(event) && '$$type' in event && event.$$type === 'scxml') {
        return event;
      }

      var eventObject = toEventObject(event);
      return __assign$1({
        name: eventObject.type,
        data: eventObject,
        $$type: 'scxml',
        type: 'external'
      }, scxmlEvent);
    }
    function toTransitionConfigArray(event, configLike) {
      var transitions = toArrayStrict(configLike).map(function (transitionLike) {
        if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string' || isMachine(transitionLike)) {
          return {
            target: transitionLike,
            event: event
          };
        }

        return __assign$1(__assign$1({}, transitionLike), {
          event: event
        });
      });
      return transitions;
    }
    function normalizeTarget(target) {
      if (target === undefined || target === TARGETLESS_KEY) {
        return undefined;
      }

      return toArray(target);
    }
    function evaluateGuard(machine, guard, context, _event, state) {
      var guards = machine.options.guards;
      var guardMeta = {
        state: state,
        cond: guard,
        _event: _event
      }; // TODO: do not hardcode!

      if (guard.type === DEFAULT_GUARD_TYPE) {
        return ((guards === null || guards === void 0 ? void 0 : guards[guard.name]) || guard.predicate)(context, _event.data, guardMeta);
      }

      var condFn = guards === null || guards === void 0 ? void 0 : guards[guard.type];

      if (!condFn) {
        throw new Error("Guard '".concat(guard.type, "' is not implemented on machine '").concat(machine.id, "'."));
      }

      return condFn(context, _event.data, guardMeta);
    }
    function toInvokeSource$1(src) {
      if (typeof src === 'string') {
        return {
          type: src
        };
      }

      return src;
    }
    function toObserver(nextHandler, errorHandler, completionHandler) {
      if (typeof nextHandler === 'object') {
        return nextHandler;
      }

      var noop = function () {
        return void 0;
      };

      return {
        next: nextHandler,
        error: errorHandler || noop,
        complete: completionHandler || noop
      };
    }
    function createInvokeId(stateNodeId, index) {
      return "".concat(stateNodeId, ":invocation[").concat(index, "]");
    }

    var initEvent = /*#__PURE__*/toSCXMLEvent({
      type: init
    });
    function getActionFunction(actionType, actionFunctionMap) {
      return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;
    }
    function toActionObject(action, actionFunctionMap) {
      var actionObject;

      if (isString(action) || typeof action === 'number') {
        var exec = getActionFunction(action, actionFunctionMap);

        if (isFunction(exec)) {
          actionObject = {
            type: action,
            exec: exec
          };
        } else if (exec) {
          actionObject = exec;
        } else {
          actionObject = {
            type: action,
            exec: undefined
          };
        }
      } else if (isFunction(action)) {
        actionObject = {
          // Convert action to string if unnamed
          type: action.name || action.toString(),
          exec: action
        };
      } else {
        var exec = getActionFunction(action.type, actionFunctionMap);

        if (isFunction(exec)) {
          actionObject = __assign$1(__assign$1({}, action), {
            exec: exec
          });
        } else if (exec) {
          var actionType = exec.type || action.type;
          actionObject = __assign$1(__assign$1(__assign$1({}, exec), action), {
            type: actionType
          });
        } else {
          actionObject = action;
        }
      }

      return actionObject;
    }
    var toActionObjects = function (action, actionFunctionMap) {
      if (!action) {
        return [];
      }

      var actions = isArray(action) ? action : [action];
      return actions.map(function (subAction) {
        return toActionObject(subAction, actionFunctionMap);
      });
    };
    function toActivityDefinition(action) {
      var actionObject = toActionObject(action);
      return __assign$1(__assign$1({
        id: isString(action) ? action : actionObject.id
      }, actionObject), {
        type: actionObject.type
      });
    }
    /**
     * Raises an event. This places the event in the internal event queue, so that
     * the event is immediately consumed by the machine in the current step.
     *
     * @param eventType The event to raise.
     */

    function raise(event) {
      if (!isString(event)) {
        return send(event, {
          to: SpecialTargets.Internal
        });
      }

      return {
        type: raise$1,
        event: event
      };
    }
    function resolveRaise(action) {
      return {
        type: raise$1,
        _event: toSCXMLEvent(action.event)
      };
    }
    /**
     * Sends an event. This returns an action that will be read by an interpreter to
     * send the event in the next step, after the current step is finished executing.
     *
     * @param event The event to send.
     * @param options Options to pass into the send event:
     *  - `id` - The unique send event identifier (used with `cancel()`).
     *  - `delay` - The number of milliseconds to delay the sending of the event.
     *  - `to` - The target of this event (by default, the machine the event was sent from).
     */

    function send(event, options) {
      return {
        to: options ? options.to : undefined,
        type: send$1,
        event: isFunction(event) ? event : toEventObject(event),
        delay: options ? options.delay : undefined,
        id: options && options.id !== undefined ? options.id : isFunction(event) ? event.name : getEventType(event)
      };
    }
    function resolveSend(action, ctx, _event, delaysMap) {
      var meta = {
        _event: _event
      }; // TODO: helper function for resolving Expr

      var resolvedEvent = toSCXMLEvent(isFunction(action.event) ? action.event(ctx, _event.data, meta) : action.event);
      var resolvedDelay;

      if (isString(action.delay)) {
        var configDelay = delaysMap && delaysMap[action.delay];
        resolvedDelay = isFunction(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
      } else {
        resolvedDelay = isFunction(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
      }

      var resolvedTarget = isFunction(action.to) ? action.to(ctx, _event.data, meta) : action.to;
      return __assign$1(__assign$1({}, action), {
        to: resolvedTarget,
        _event: resolvedEvent,
        event: resolvedEvent.data,
        delay: resolvedDelay
      });
    }
    var resolveLog = function (action, ctx, _event) {
      return __assign$1(__assign$1({}, action), {
        value: isString(action.expr) ? action.expr : action.expr(ctx, _event.data, {
          _event: _event
        })
      });
    };
    /**
     * Cancels an in-flight `send(...)` action. A canceled sent action will not
     * be executed, nor will its event be sent, unless it has already been sent
     * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
     *
     * @param sendId The `id` of the `send(...)` action to cancel.
     */

    var cancel = function (sendId) {
      return {
        type: cancel$1,
        sendId: sendId
      };
    };
    /**
     * Starts an activity.
     *
     * @param activity The activity to start.
     */

    function start(activity) {
      var activityDef = toActivityDefinition(activity);
      return {
        type: ActionTypes.Start,
        activity: activityDef,
        exec: undefined
      };
    }
    /**
     * Stops an activity.
     *
     * @param actorRef The activity to stop.
     */

    function stop(actorRef) {
      var activity = isFunction(actorRef) ? actorRef : toActivityDefinition(actorRef);
      return {
        type: ActionTypes.Stop,
        activity: activity,
        exec: undefined
      };
    }
    function resolveStop(action, context, _event) {
      var actorRefOrString = isFunction(action.activity) ? action.activity(context, _event.data) : action.activity;
      var resolvedActorRef = typeof actorRefOrString === 'string' ? {
        id: actorRefOrString
      } : actorRefOrString;
      var actionObject = {
        type: ActionTypes.Stop,
        activity: resolvedActorRef
      };
      return actionObject;
    }
    /**
     * Updates the current context of the machine.
     *
     * @param assignment An object that represents the partial context to update.
     */

    var assign$1 = function (assignment) {
      return {
        type: assign$2,
        assignment: assignment
      };
    };
    /**
     * Returns an event type that represents an implicit event that
     * is sent after the specified `delay`.
     *
     * @param delayRef The delay in milliseconds
     * @param id The state node ID where this event is handled
     */

    function after(delayRef, id) {
      var idSuffix = id ? "#".concat(id) : '';
      return "".concat(ActionTypes.After, "(").concat(delayRef, ")").concat(idSuffix);
    }
    /**
     * Returns an event that represents that a final state node
     * has been reached in the parent state node.
     *
     * @param id The final state node's parent state node `id`
     * @param data The data to pass into the event
     */

    function done(id, data) {
      var type = "".concat(ActionTypes.DoneState, ".").concat(id);
      var eventObject = {
        type: type,
        data: data
      };

      eventObject.toString = function () {
        return type;
      };

      return eventObject;
    }
    /**
     * Returns an event that represents that an invoked service has terminated.
     *
     * An invoked service is terminated when it has reached a top-level final state node,
     * but not when it is canceled.
     *
     * @param id The final state node ID
     * @param data The data to pass into the event
     */

    function doneInvoke(id, data) {
      var type = "".concat(ActionTypes.DoneInvoke, ".").concat(id);
      var eventObject = {
        type: type,
        data: data
      };

      eventObject.toString = function () {
        return type;
      };

      return eventObject;
    }
    function error(id, data) {
      var type = "".concat(ActionTypes.ErrorPlatform, ".").concat(id);
      var eventObject = {
        type: type,
        data: data
      };

      eventObject.toString = function () {
        return type;
      };

      return eventObject;
    }
    function resolveActions(machine, currentState, currentContext, _event, actions, preserveActionOrder) {
      if (preserveActionOrder === void 0) {
        preserveActionOrder = false;
      }

      var _a = __read(preserveActionOrder ? [[], actions] : partition(actions, function (action) {
        return action.type === assign$2;
      }), 2),
          assignActions = _a[0],
          otherActions = _a[1];

      var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;
      var preservedContexts = preserveActionOrder ? [currentContext] : undefined;
      var resolvedActions = flatten(otherActions.map(function (actionObject) {
        var _a;

        switch (actionObject.type) {
          case raise$1:
            return resolveRaise(actionObject);

          case send$1:
            var sendAction = resolveSend(actionObject, updatedContext, _event, machine.options.delays); // TODO: fix ActionTypes.Init

            return sendAction;

          case log:
            return resolveLog(actionObject, updatedContext, _event);

          case choose:
            {
              var chooseAction = actionObject;
              var matchedActions = (_a = chooseAction.conds.find(function (condition) {
                var guard = toGuard(condition.cond, machine.options.guards);
                return !guard || evaluateGuard(machine, guard, updatedContext, _event, currentState);
              })) === null || _a === void 0 ? void 0 : _a.actions;

              if (!matchedActions) {
                return [];
              }

              var _b = __read(resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions), preserveActionOrder), 2),
                  resolvedActionsFromChoose = _b[0],
                  resolvedContextFromChoose = _b[1];

              updatedContext = resolvedContextFromChoose;
              preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
              return resolvedActionsFromChoose;
            }

          case pure:
            {
              var matchedActions = actionObject.get(updatedContext, _event.data);

              if (!matchedActions) {
                return [];
              }

              var _c = __read(resolveActions(machine, currentState, updatedContext, _event, toActionObjects(toArray(matchedActions), machine.options.actions), preserveActionOrder), 2),
                  resolvedActionsFromPure = _c[0],
                  resolvedContext = _c[1];

              updatedContext = resolvedContext;
              preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
              return resolvedActionsFromPure;
            }

          case stop$1:
            {
              return resolveStop(actionObject, updatedContext, _event);
            }

          case assign$2:
            {
              updatedContext = updateContext(updatedContext, _event, [actionObject], currentState);
              preservedContexts === null || preservedContexts === void 0 ? void 0 : preservedContexts.push(updatedContext);
              break;
            }

          default:
            var resolvedActionObject = toActionObject(actionObject, machine.options.actions);
            var exec_1 = resolvedActionObject.exec;

            if (exec_1 && preservedContexts) {
              var contextIndex_1 = preservedContexts.length - 1;
              resolvedActionObject = __assign$1(__assign$1({}, resolvedActionObject), {
                exec: function (_ctx) {
                  var args = [];

                  for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                  }

                  exec_1.apply(void 0, __spreadArray([preservedContexts[contextIndex_1]], __read(args), false));
                }
              });
            }

            return resolvedActionObject;
        }
      }).filter(function (a) {
        return !!a;
      }));
      return [resolvedActions, updatedContext];
    }

    /**
     * Maintains a stack of the current service in scope.
     * This is used to provide the correct service to spawn().
     */
    var provide = function (service, fn) {
      var result = fn(service);
      return result;
    };

    function createNullActor(id) {
      var _a;

      return _a = {
        id: id,
        send: function () {
          return void 0;
        },
        subscribe: function () {
          return {
            unsubscribe: function () {
              return void 0;
            }
          };
        },
        getSnapshot: function () {
          return undefined;
        },
        toJSON: function () {
          return {
            id: id
          };
        }
      }, _a[symbolObservable] = function () {
        return this;
      }, _a;
    }
    /**
     * Creates a deferred actor that is able to be invoked given the provided
     * invocation information in its `.meta` value.
     *
     * @param invokeDefinition The meta information needed to invoke the actor.
     */

    function createInvocableActor(invokeDefinition, machine, context, _event) {
      var _a;

      var invokeSrc = toInvokeSource$1(invokeDefinition.src);
      var serviceCreator = (_a = machine === null || machine === void 0 ? void 0 : machine.options.services) === null || _a === void 0 ? void 0 : _a[invokeSrc.type];
      var resolvedData = invokeDefinition.data ? mapContext(invokeDefinition.data, context, _event) : undefined;
      var tempActor = serviceCreator ? createDeferredActor(serviceCreator, invokeDefinition.id, resolvedData) : createNullActor(invokeDefinition.id); // @ts-ignore

      tempActor.meta = invokeDefinition;
      return tempActor;
    }
    function createDeferredActor(entity, id, data) {
      var tempActor = createNullActor(id); // @ts-ignore

      tempActor.deferred = true;

      if (isMachine(entity)) {
        // "mute" the existing service scope so potential spawned actors within the `.initialState` stay deferred here
        var initialState_1 = tempActor.state = provide(undefined, function () {
          return (data ? entity.withContext(data) : entity).initialState;
        });

        tempActor.getSnapshot = function () {
          return initialState_1;
        };
      }

      return tempActor;
    }
    function isActor(item) {
      try {
        return typeof item.send === 'function';
      } catch (e) {
        return false;
      }
    }
    function isSpawnedActor(item) {
      return isActor(item) && 'id' in item;
    } // TODO: refactor the return type, this could be written in a better way but it's best to avoid unneccessary breaking changes now

    function toActorRef(actorRefLike) {
      var _a;

      return __assign$1((_a = {
        subscribe: function () {
          return {
            unsubscribe: function () {
              return void 0;
            }
          };
        },
        id: 'anonymous',
        getSnapshot: function () {
          return undefined;
        }
      }, _a[symbolObservable] = function () {
        return this;
      }, _a), actorRefLike);
    }

    var isLeafNode = function (stateNode) {
      return stateNode.type === 'atomic' || stateNode.type === 'final';
    };
    function getChildren(stateNode) {
      return Object.keys(stateNode.states).map(function (key) {
        return stateNode.states[key];
      }).filter(function (sn) {
        return sn.type !== 'history';
      });
    }
    function getAllStateNodes(stateNode) {
      var stateNodes = [stateNode];

      if (isLeafNode(stateNode)) {
        return stateNodes;
      }

      return stateNodes.concat(flatten(getChildren(stateNode).map(getAllStateNodes)));
    }
    function getConfiguration(prevStateNodes, stateNodes) {
      var e_1, _a, e_2, _b, e_3, _c, e_4, _d;

      var prevConfiguration = new Set(prevStateNodes);
      var prevAdjList = getAdjList(prevConfiguration);
      var configuration = new Set(stateNodes);

      try {
        // add all ancestors
        for (var configuration_1 = __values$1(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
          var s = configuration_1_1.value;
          var m = s.parent;

          while (m && !configuration.has(m)) {
            configuration.add(m);
            m = m.parent;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      var adjList = getAdjList(configuration);

      try {
        // add descendants
        for (var configuration_2 = __values$1(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
          var s = configuration_2_1.value; // if previously active, add existing child nodes

          if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
            if (prevAdjList.get(s)) {
              prevAdjList.get(s).forEach(function (sn) {
                return configuration.add(sn);
              });
            } else {
              s.initialStateNodes.forEach(function (sn) {
                return configuration.add(sn);
              });
            }
          } else {
            if (s.type === 'parallel') {
              try {
                for (var _e = (e_3 = void 0, __values$1(getChildren(s))), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var child = _f.value;

                  if (!configuration.has(child)) {
                    configuration.add(child);

                    if (prevAdjList.get(child)) {
                      prevAdjList.get(child).forEach(function (sn) {
                        return configuration.add(sn);
                      });
                    } else {
                      child.initialStateNodes.forEach(function (sn) {
                        return configuration.add(sn);
                      });
                    }
                  }
                }
              } catch (e_3_1) {
                e_3 = {
                  error: e_3_1
                };
              } finally {
                try {
                  if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
                } finally {
                  if (e_3) throw e_3.error;
                }
              }
            }
          }
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);
        } finally {
          if (e_2) throw e_2.error;
        }
      }

      try {
        // add all ancestors
        for (var configuration_3 = __values$1(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
          var s = configuration_3_1.value;
          var m = s.parent;

          while (m && !configuration.has(m)) {
            configuration.add(m);
            m = m.parent;
          }
        }
      } catch (e_4_1) {
        e_4 = {
          error: e_4_1
        };
      } finally {
        try {
          if (configuration_3_1 && !configuration_3_1.done && (_d = configuration_3.return)) _d.call(configuration_3);
        } finally {
          if (e_4) throw e_4.error;
        }
      }

      return configuration;
    }

    function getValueFromAdj(baseNode, adjList) {
      var childStateNodes = adjList.get(baseNode);

      if (!childStateNodes) {
        return {}; // todo: fix?
      }

      if (baseNode.type === 'compound') {
        var childStateNode = childStateNodes[0];

        if (childStateNode) {
          if (isLeafNode(childStateNode)) {
            return childStateNode.key;
          }
        } else {
          return {};
        }
      }

      var stateValue = {};
      childStateNodes.forEach(function (csn) {
        stateValue[csn.key] = getValueFromAdj(csn, adjList);
      });
      return stateValue;
    }

    function getAdjList(configuration) {
      var e_5, _a;

      var adjList = new Map();

      try {
        for (var configuration_4 = __values$1(configuration), configuration_4_1 = configuration_4.next(); !configuration_4_1.done; configuration_4_1 = configuration_4.next()) {
          var s = configuration_4_1.value;

          if (!adjList.has(s)) {
            adjList.set(s, []);
          }

          if (s.parent) {
            if (!adjList.has(s.parent)) {
              adjList.set(s.parent, []);
            }

            adjList.get(s.parent).push(s);
          }
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (configuration_4_1 && !configuration_4_1.done && (_a = configuration_4.return)) _a.call(configuration_4);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      return adjList;
    }
    function getValue(rootNode, configuration) {
      var config = getConfiguration([rootNode], configuration);
      return getValueFromAdj(rootNode, getAdjList(config));
    }
    function has(iterable, item) {
      if (Array.isArray(iterable)) {
        return iterable.some(function (member) {
          return member === item;
        });
      }

      if (iterable instanceof Set) {
        return iterable.has(item);
      }

      return false; // TODO: fix
    }
    function nextEvents(configuration) {
      return __spreadArray([], __read(new Set(flatten(__spreadArray([], __read(configuration.map(function (sn) {
        return sn.ownEvents;
      })), false)))), false);
    }
    function isInFinalState(configuration, stateNode) {
      if (stateNode.type === 'compound') {
        return getChildren(stateNode).some(function (s) {
          return s.type === 'final' && has(configuration, s);
        });
      }

      if (stateNode.type === 'parallel') {
        return getChildren(stateNode).every(function (sn) {
          return isInFinalState(configuration, sn);
        });
      }

      return false;
    }
    function getMeta(configuration) {
      if (configuration === void 0) {
        configuration = [];
      }

      return configuration.reduce(function (acc, stateNode) {
        if (stateNode.meta !== undefined) {
          acc[stateNode.id] = stateNode.meta;
        }

        return acc;
      }, {});
    }
    function getTagsFromConfiguration(configuration) {
      return new Set(flatten(configuration.map(function (sn) {
        return sn.tags;
      })));
    }

    function stateValuesEqual(a, b) {
      if (a === b) {
        return true;
      }

      if (a === undefined || b === undefined) {
        return false;
      }

      if (isString(a) || isString(b)) {
        return a === b;
      }

      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);
      return aKeys.length === bKeys.length && aKeys.every(function (key) {
        return stateValuesEqual(a[key], b[key]);
      });
    }
    function isStateConfig(state) {
      if (typeof state !== 'object' || state === null) {
        return false;
      }

      return 'value' in state && '_event' in state;
    }
    function bindActionToState(action, state) {
      var exec = action.exec;

      var boundAction = __assign$1(__assign$1({}, action), {
        exec: exec !== undefined ? function () {
          return exec(state.context, state.event, {
            action: action,
            state: state,
            _event: state._event
          });
        } : undefined
      });

      return boundAction;
    }

    var State =
    /*#__PURE__*/

    /** @class */
    function () {
      /**
       * Creates a new State instance.
       * @param value The state value
       * @param context The extended state
       * @param historyValue The tree representing historical values of the state nodes
       * @param history The previous state
       * @param actions An array of action objects to execute as side-effects
       * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
       * @param meta
       * @param events Internal event queue. Should be empty with run-to-completion semantics.
       * @param configuration
       */
      function State(config) {
        var _this = this;

        var _a;

        this.actions = [];
        this.activities = EMPTY_ACTIVITY_MAP;
        this.meta = {};
        this.events = [];
        this.value = config.value;
        this.context = config.context;
        this._event = config._event;
        this._sessionid = config._sessionid;
        this.event = this._event.data;
        this.historyValue = config.historyValue;
        this.history = config.history;
        this.actions = config.actions || [];
        this.activities = config.activities || EMPTY_ACTIVITY_MAP;
        this.meta = getMeta(config.configuration);
        this.events = config.events || [];
        this.matches = this.matches.bind(this);
        this.toStrings = this.toStrings.bind(this);
        this.configuration = config.configuration;
        this.transitions = config.transitions;
        this.children = config.children;
        this.done = !!config.done;
        this.tags = (_a = Array.isArray(config.tags) ? new Set(config.tags) : config.tags) !== null && _a !== void 0 ? _a : new Set();
        this.machine = config.machine;
        Object.defineProperty(this, 'nextEvents', {
          get: function () {
            return nextEvents(_this.configuration);
          }
        });
      }
      /**
       * Creates a new State instance for the given `stateValue` and `context`.
       * @param stateValue
       * @param context
       */


      State.from = function (stateValue, context) {
        if (stateValue instanceof State) {
          if (stateValue.context !== context) {
            return new State({
              value: stateValue.value,
              context: context,
              _event: stateValue._event,
              _sessionid: null,
              historyValue: stateValue.historyValue,
              history: stateValue.history,
              actions: [],
              activities: stateValue.activities,
              meta: {},
              events: [],
              configuration: [],
              transitions: [],
              children: {}
            });
          }

          return stateValue;
        }

        var _event = initEvent;
        return new State({
          value: stateValue,
          context: context,
          _event: _event,
          _sessionid: null,
          historyValue: undefined,
          history: undefined,
          actions: [],
          activities: undefined,
          meta: undefined,
          events: [],
          configuration: [],
          transitions: [],
          children: {}
        });
      };
      /**
       * Creates a new State instance for the given `config`.
       * @param config The state config
       */


      State.create = function (config) {
        return new State(config);
      };
      /**
       * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
       * @param stateValue
       * @param context
       */


      State.inert = function (stateValue, context) {
        if (stateValue instanceof State) {
          if (!stateValue.actions.length) {
            return stateValue;
          }

          var _event = initEvent;
          return new State({
            value: stateValue.value,
            context: context,
            _event: _event,
            _sessionid: null,
            historyValue: stateValue.historyValue,
            history: stateValue.history,
            activities: stateValue.activities,
            configuration: stateValue.configuration,
            transitions: [],
            children: {}
          });
        }

        return State.from(stateValue, context);
      };
      /**
       * Returns an array of all the string leaf state node paths.
       * @param stateValue
       * @param delimiter The character(s) that separate each subpath in the string state node path.
       */


      State.prototype.toStrings = function (stateValue, delimiter) {
        var _this = this;

        if (stateValue === void 0) {
          stateValue = this.value;
        }

        if (delimiter === void 0) {
          delimiter = '.';
        }

        if (isString(stateValue)) {
          return [stateValue];
        }

        var valueKeys = Object.keys(stateValue);
        return valueKeys.concat.apply(valueKeys, __spreadArray([], __read(valueKeys.map(function (key) {
          return _this.toStrings(stateValue[key], delimiter).map(function (s) {
            return key + delimiter + s;
          });
        })), false));
      };

      State.prototype.toJSON = function () {
        var _a = this;
            _a.configuration;
            _a.transitions;
            var tags = _a.tags;
            _a.machine;
            var jsonValues = __rest$1(_a, ["configuration", "transitions", "tags", "machine"]);

        return __assign$1(__assign$1({}, jsonValues), {
          tags: Array.from(tags)
        });
      };

      State.prototype.matches = function (parentStateValue) {
        return matchesState(parentStateValue, this.value);
      };
      /**
       * Whether the current state configuration has a state node with the specified `tag`.
       * @param tag
       */


      State.prototype.hasTag = function (tag) {
        return this.tags.has(tag);
      };
      /**
       * Determines whether sending the `event` will cause a non-forbidden transition
       * to be selected, even if the transitions have no actions nor
       * change the state value.
       *
       * @param event The event to test
       * @returns Whether the event will cause a transition
       */


      State.prototype.can = function (event) {
        var _a;

        {
          warn(!!this.machine);
        }

        var transitionData = (_a = this.machine) === null || _a === void 0 ? void 0 : _a.getTransitionData(this, event);
        return !!(transitionData === null || transitionData === void 0 ? void 0 : transitionData.transitions.length) && // Check that at least one transition is not forbidden
        transitionData.transitions.some(function (t) {
          return t.target !== undefined || t.actions.length;
        });
      };

      return State;
    }();

    var defaultOptions$1 = {
      deferEvents: false
    };

    var Scheduler =
    /*#__PURE__*/

    /** @class */
    function () {
      function Scheduler(options) {
        this.processingEvent = false;
        this.queue = [];
        this.initialized = false;
        this.options = __assign$1(__assign$1({}, defaultOptions$1), options);
      }

      Scheduler.prototype.initialize = function (callback) {
        this.initialized = true;

        if (callback) {
          if (!this.options.deferEvents) {
            this.schedule(callback);
            return;
          }

          this.process(callback);
        }

        this.flushEvents();
      };

      Scheduler.prototype.schedule = function (task) {
        if (!this.initialized || this.processingEvent) {
          this.queue.push(task);
          return;
        }

        if (this.queue.length !== 0) {
          throw new Error('Event queue should be empty when it is not processing events');
        }

        this.process(task);
        this.flushEvents();
      };

      Scheduler.prototype.clear = function () {
        this.queue = [];
      };

      Scheduler.prototype.flushEvents = function () {
        var nextCallback = this.queue.shift();

        while (nextCallback) {
          this.process(nextCallback);
          nextCallback = this.queue.shift();
        }
      };

      Scheduler.prototype.process = function (callback) {
        this.processingEvent = true;

        try {
          callback();
        } catch (e) {
          // there is no use to keep the future events
          // as the situation is not anymore the same
          this.clear();
          throw e;
        } finally {
          this.processingEvent = false;
        }
      };

      return Scheduler;
    }();

    var children = /*#__PURE__*/new Map();
    var sessionIdIndex = 0;
    var registry = {
      bookId: function () {
        return "x:".concat(sessionIdIndex++);
      },
      register: function (id, actor) {
        children.set(id, actor);
        return id;
      },
      get: function (id) {
        return children.get(id);
      },
      free: function (id) {
        children.delete(id);
      }
    };

    function getGlobal() {
      if (typeof globalThis !== 'undefined') {
        return globalThis;
      }

      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof window !== 'undefined') {
        return window;
      }

      if (typeof global !== 'undefined') {
        return global;
      }
    }

    function getDevTools() {
      var global = getGlobal();

      if (global && '__xstate__' in global) {
        return global.__xstate__;
      }

      return undefined;
    }

    function registerService(service) {
      if (!getGlobal()) {
        return;
      }

      var devTools = getDevTools();

      if (devTools) {
        devTools.register(service);
      }
    }

    function spawnBehavior(behavior, options) {
      if (options === void 0) {
        options = {};
      }

      var state = behavior.initialState;
      var observers = new Set();
      var mailbox = [];
      var flushing = false;

      var flush = function () {
        if (flushing) {
          return;
        }

        flushing = true;

        while (mailbox.length > 0) {
          var event_1 = mailbox.shift();
          state = behavior.transition(state, event_1, actorCtx);
          observers.forEach(function (observer) {
            return observer.next(state);
          });
        }

        flushing = false;
      };

      var actor = toActorRef({
        id: options.id,
        send: function (event) {
          mailbox.push(event);
          flush();
        },
        getSnapshot: function () {
          return state;
        },
        subscribe: function (next, handleError, complete) {
          var observer = toObserver(next, handleError, complete);
          observers.add(observer);
          observer.next(state);
          return {
            unsubscribe: function () {
              observers.delete(observer);
            }
          };
        }
      });
      var actorCtx = {
        parent: options.parent,
        self: actor,
        id: options.id || 'anonymous',
        observers: observers
      };
      state = behavior.start ? behavior.start(actorCtx) : state;
      return actor;
    }

    var DEFAULT_SPAWN_OPTIONS = {
      sync: false,
      autoForward: false
    };
    var InterpreterStatus;

    (function (InterpreterStatus) {
      InterpreterStatus[InterpreterStatus["NotStarted"] = 0] = "NotStarted";
      InterpreterStatus[InterpreterStatus["Running"] = 1] = "Running";
      InterpreterStatus[InterpreterStatus["Stopped"] = 2] = "Stopped";
    })(InterpreterStatus || (InterpreterStatus = {}));

    var Interpreter =
    /*#__PURE__*/

    /** @class */
    function () {
      /**
       * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
       *
       * @param machine The machine to be interpreted
       * @param options Interpreter options
       */
      function Interpreter(machine, options) {
        var _this = this;

        if (options === void 0) {
          options = Interpreter.defaultOptions;
        }

        this.machine = machine;
        this.delayedEventsMap = {};
        this.listeners = new Set();
        this.contextListeners = new Set();
        this.stopListeners = new Set();
        this.doneListeners = new Set();
        this.eventListeners = new Set();
        this.sendListeners = new Set();
        /**
         * Whether the service is started.
         */

        this.initialized = false;
        this.status = InterpreterStatus.NotStarted;
        this.children = new Map();
        this.forwardTo = new Set();
        /**
         * Alias for Interpreter.prototype.start
         */

        this.init = this.start;
        /**
         * Sends an event to the running interpreter to trigger a transition.
         *
         * An array of events (batched) can be sent as well, which will send all
         * batched events to the running interpreter. The listeners will be
         * notified only **once** when all events are processed.
         *
         * @param event The event(s) to send
         */

        this.send = function (event, payload) {
          if (isArray(event)) {
            _this.batch(event);

            return _this.state;
          }

          var _event = toSCXMLEvent(toEventObject(event, payload));

          if (_this.status === InterpreterStatus.Stopped) {

            return _this.state;
          }

          if (_this.status !== InterpreterStatus.Running && !_this.options.deferEvents) {
            throw new Error("Event \"".concat(_event.name, "\" was sent to uninitialized service \"").concat(_this.machine.id // tslint:disable-next-line:max-line-length
            , "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: ").concat(JSON.stringify(_event.data)));
          }

          _this.scheduler.schedule(function () {
            // Forward copy of event to child actors
            _this.forward(_event);

            var nextState = _this.nextState(_event);

            _this.update(nextState, _event);
          });

          return _this._state; // TODO: deprecate (should return void)
          // tslint:disable-next-line:semicolon
        };

        this.sendTo = function (event, to) {
          var isParent = _this.parent && (to === SpecialTargets.Parent || _this.parent.id === to);
          var target = isParent ? _this.parent : isString(to) ? _this.children.get(to) || registry.get(to) : isActor$1(to) ? to : undefined;

          if (!target) {
            if (!isParent) {
              throw new Error("Unable to send event to child '".concat(to, "' from service '").concat(_this.id, "'."));
            } // tslint:disable-next-line:no-console

            return;
          }

          if ('machine' in target) {
            // Send SCXML events to machines
            target.send(__assign$1(__assign$1({}, event), {
              name: event.name === error$1 ? "".concat(error(_this.id)) : event.name,
              origin: _this.sessionId
            }));
          } else {
            // Send normal events to other targets
            target.send(event.data);
          }
        };

        var resolvedOptions = __assign$1(__assign$1({}, Interpreter.defaultOptions), options);

        var clock = resolvedOptions.clock,
            logger = resolvedOptions.logger,
            parent = resolvedOptions.parent,
            id = resolvedOptions.id;
        var resolvedId = id !== undefined ? id : machine.id;
        this.id = resolvedId;
        this.logger = logger;
        this.clock = clock;
        this.parent = parent;
        this.options = resolvedOptions;
        this.scheduler = new Scheduler({
          deferEvents: this.options.deferEvents
        });
        this.sessionId = registry.bookId();
      }

      Object.defineProperty(Interpreter.prototype, "initialState", {
        get: function () {
          var _this = this;

          if (this._initialState) {
            return this._initialState;
          }

          return provide(this, function () {
            _this._initialState = _this.machine.initialState;
            return _this._initialState;
          });
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Interpreter.prototype, "state", {
        get: function () {

          return this._state;
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Executes the actions of the given state, with that state's `context` and `event`.
       *
       * @param state The state whose actions will be executed
       * @param actionsConfig The action implementations to use
       */

      Interpreter.prototype.execute = function (state, actionsConfig) {
        var e_1, _a;

        try {
          for (var _b = __values$1(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
            var action = _c.value;
            this.exec(action, state, actionsConfig);
          }
        } catch (e_1_1) {
          e_1 = {
            error: e_1_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };

      Interpreter.prototype.update = function (state, _event) {
        var e_2, _a, e_3, _b, e_4, _c, e_5, _d;

        var _this = this; // Attach session ID to state


        state._sessionid = this.sessionId; // Update state

        this._state = state; // Execute actions

        if (this.options.execute) {
          this.execute(this.state);
        } // Update children


        this.children.forEach(function (child) {
          _this.state.children[child.id] = child;
        }); // Dev tools

        if (this.devTools) {
          this.devTools.send(_event.data, state);
        } // Execute listeners


        if (state.event) {
          try {
            for (var _e = __values$1(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
              var listener = _f.value;
              listener(state.event);
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1
            };
          } finally {
            try {
              if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }

        try {
          for (var _g = __values$1(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
            var listener = _h.value;
            listener(state, state.event);
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
          } finally {
            if (e_3) throw e_3.error;
          }
        }

        try {
          for (var _j = __values$1(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
            var contextListener = _k.value;
            contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
          } finally {
            if (e_4) throw e_4.error;
          }
        }

        var isDone = isInFinalState(state.configuration || [], this.machine);

        if (this.state.configuration && isDone) {
          // get final child state node
          var finalChildStateNode = state.configuration.find(function (sn) {
            return sn.type === 'final' && sn.parent === _this.machine;
          });
          var doneData = finalChildStateNode && finalChildStateNode.doneData ? mapContext(finalChildStateNode.doneData, state.context, _event) : undefined;

          try {
            for (var _l = __values$1(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
              var listener = _m.value;
              listener(doneInvoke(this.id, doneData));
            }
          } catch (e_5_1) {
            e_5 = {
              error: e_5_1
            };
          } finally {
            try {
              if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
            } finally {
              if (e_5) throw e_5.error;
            }
          }

          this.stop();
        }
      };
      /*
       * Adds a listener that is notified whenever a state transition happens. The listener is called with
       * the next state and the event object that caused the state transition.
       *
       * @param listener The state listener
       */


      Interpreter.prototype.onTransition = function (listener) {
        this.listeners.add(listener); // Send current state to listener

        if (this.status === InterpreterStatus.Running) {
          listener(this.state, this.state.event);
        }

        return this;
      };

      Interpreter.prototype.subscribe = function (nextListenerOrObserver, _, // TODO: error listener
      completeListener) {
        var _this = this;

        if (!nextListenerOrObserver) {
          return {
            unsubscribe: function () {
              return void 0;
            }
          };
        }

        var listener;
        var resolvedCompleteListener = completeListener;

        if (typeof nextListenerOrObserver === 'function') {
          listener = nextListenerOrObserver;
        } else {
          listener = nextListenerOrObserver.next.bind(nextListenerOrObserver);
          resolvedCompleteListener = nextListenerOrObserver.complete.bind(nextListenerOrObserver);
        }

        this.listeners.add(listener); // Send current state to listener

        if (this.status !== InterpreterStatus.NotStarted) {
          listener(this.state);
        }

        if (resolvedCompleteListener) {
          if (this.status === InterpreterStatus.Stopped) {
            resolvedCompleteListener();
          } else {
            this.onDone(resolvedCompleteListener);
          }
        }

        return {
          unsubscribe: function () {
            listener && _this.listeners.delete(listener);
            resolvedCompleteListener && _this.doneListeners.delete(resolvedCompleteListener);
          }
        };
      };
      /**
       * Adds an event listener that is notified whenever an event is sent to the running interpreter.
       * @param listener The event listener
       */


      Interpreter.prototype.onEvent = function (listener) {
        this.eventListeners.add(listener);
        return this;
      };
      /**
       * Adds an event listener that is notified whenever a `send` event occurs.
       * @param listener The event listener
       */


      Interpreter.prototype.onSend = function (listener) {
        this.sendListeners.add(listener);
        return this;
      };
      /**
       * Adds a context listener that is notified whenever the state context changes.
       * @param listener The context listener
       */


      Interpreter.prototype.onChange = function (listener) {
        this.contextListeners.add(listener);
        return this;
      };
      /**
       * Adds a listener that is notified when the machine is stopped.
       * @param listener The listener
       */


      Interpreter.prototype.onStop = function (listener) {
        this.stopListeners.add(listener);
        return this;
      };
      /**
       * Adds a state listener that is notified when the statechart has reached its final state.
       * @param listener The state listener
       */


      Interpreter.prototype.onDone = function (listener) {
        this.doneListeners.add(listener);
        return this;
      };
      /**
       * Removes a listener.
       * @param listener The listener to remove
       */


      Interpreter.prototype.off = function (listener) {
        this.listeners.delete(listener);
        this.eventListeners.delete(listener);
        this.sendListeners.delete(listener);
        this.stopListeners.delete(listener);
        this.doneListeners.delete(listener);
        this.contextListeners.delete(listener);
        return this;
      };
      /**
       * Starts the interpreter from the given state, or the initial state.
       * @param initialState The state to start the statechart from
       */


      Interpreter.prototype.start = function (initialState) {
        var _this = this;

        if (this.status === InterpreterStatus.Running) {
          // Do not restart the service if it is already started
          return this;
        } // yes, it's a hack but we need the related cache to be populated for some things to work (like delayed transitions)
        // this is usually called by `machine.getInitialState` but if we rehydrate from a state we might bypass this call
        // we also don't want to call this method here as it resolves the full initial state which might involve calling assign actions
        // and that could potentially lead to some unwanted side-effects (even such as creating some rogue actors)


        this.machine._init();

        registry.register(this.sessionId, this);
        this.initialized = true;
        this.status = InterpreterStatus.Running;
        var resolvedState = initialState === undefined ? this.initialState : provide(this, function () {
          return isStateConfig(initialState) ? _this.machine.resolveState(initialState) : _this.machine.resolveState(State.from(initialState, _this.machine.context));
        });

        if (this.options.devTools) {
          this.attachDev();
        }

        this.scheduler.initialize(function () {
          _this.update(resolvedState, initEvent);
        });
        return this;
      };
      /**
       * Stops the interpreter and unsubscribe all listeners.
       *
       * This will also notify the `onStop` listeners.
       */


      Interpreter.prototype.stop = function () {
        var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;

        var _this = this;

        try {
          for (var _f = __values$1(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
            var listener = _g.value;
            this.listeners.delete(listener);
          }
        } catch (e_6_1) {
          e_6 = {
            error: e_6_1
          };
        } finally {
          try {
            if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
          } finally {
            if (e_6) throw e_6.error;
          }
        }

        try {
          for (var _h = __values$1(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
            var listener = _j.value; // call listener, then remove

            listener();
            this.stopListeners.delete(listener);
          }
        } catch (e_7_1) {
          e_7 = {
            error: e_7_1
          };
        } finally {
          try {
            if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
          } finally {
            if (e_7) throw e_7.error;
          }
        }

        try {
          for (var _k = __values$1(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
            var listener = _l.value;
            this.contextListeners.delete(listener);
          }
        } catch (e_8_1) {
          e_8 = {
            error: e_8_1
          };
        } finally {
          try {
            if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
          } finally {
            if (e_8) throw e_8.error;
          }
        }

        try {
          for (var _m = __values$1(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
            var listener = _o.value;
            this.doneListeners.delete(listener);
          }
        } catch (e_9_1) {
          e_9 = {
            error: e_9_1
          };
        } finally {
          try {
            if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
          } finally {
            if (e_9) throw e_9.error;
          }
        }

        if (!this.initialized) {
          // Interpreter already stopped; do nothing
          return this;
        }

        __spreadArray([], __read(this.state.configuration), false).sort(function (a, b) {
          return b.order - a.order;
        }).forEach(function (stateNode) {
          var e_11, _a;

          try {
            for (var _b = __values$1(stateNode.definition.exit), _c = _b.next(); !_c.done; _c = _b.next()) {
              var action = _c.value;

              _this.exec(action, _this.state);
            }
          } catch (e_11_1) {
            e_11 = {
              error: e_11_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_11) throw e_11.error;
            }
          }
        }); // Stop all children


        this.children.forEach(function (child) {
          if (isFunction(child.stop)) {
            child.stop();
          }
        });
        this.children.clear();

        try {
          // Cancel all delayed events
          for (var _p = __values$1(Object.keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
            var key = _q.value;
            this.clock.clearTimeout(this.delayedEventsMap[key]);
          }
        } catch (e_10_1) {
          e_10 = {
            error: e_10_1
          };
        } finally {
          try {
            if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
          } finally {
            if (e_10) throw e_10.error;
          }
        }

        this.scheduler.clear();
        this.scheduler = new Scheduler({
          deferEvents: this.options.deferEvents
        });
        this.initialized = false;
        this.status = InterpreterStatus.Stopped;
        this._initialState = undefined;
        registry.free(this.sessionId);
        return this;
      };

      Interpreter.prototype.batch = function (events) {
        var _this = this;

        if (this.status === InterpreterStatus.NotStarted && this.options.deferEvents) ; else if (this.status !== InterpreterStatus.Running) {
          throw new Error( // tslint:disable-next-line:max-line-length
          "".concat(events.length, " event(s) were sent to uninitialized service \"").concat(this.machine.id, "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options."));
        }

        this.scheduler.schedule(function () {
          var e_12, _a;

          var nextState = _this.state;
          var batchChanged = false;
          var batchedActions = [];

          var _loop_1 = function (event_1) {
            var _event = toSCXMLEvent(event_1);

            _this.forward(_event);

            nextState = provide(_this, function () {
              return _this.machine.transition(nextState, _event);
            });
            batchedActions.push.apply(batchedActions, __spreadArray([], __read(nextState.actions.map(function (a) {
              return bindActionToState(a, nextState);
            })), false));
            batchChanged = batchChanged || !!nextState.changed;
          };

          try {
            for (var events_1 = __values$1(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
              var event_1 = events_1_1.value;

              _loop_1(event_1);
            }
          } catch (e_12_1) {
            e_12 = {
              error: e_12_1
            };
          } finally {
            try {
              if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
            } finally {
              if (e_12) throw e_12.error;
            }
          }

          nextState.changed = batchChanged;
          nextState.actions = batchedActions;

          _this.update(nextState, toSCXMLEvent(events[events.length - 1]));
        });
      };
      /**
       * Returns a send function bound to this interpreter instance.
       *
       * @param event The event to be sent by the sender.
       */


      Interpreter.prototype.sender = function (event) {
        return this.send.bind(this, event);
      };
      /**
       * Returns the next state given the interpreter's current state and the event.
       *
       * This is a pure method that does _not_ update the interpreter's state.
       *
       * @param event The event to determine the next state
       */


      Interpreter.prototype.nextState = function (event) {
        var _this = this;

        var _event = toSCXMLEvent(event);

        if (_event.name.indexOf(errorPlatform) === 0 && !this.state.nextEvents.some(function (nextEvent) {
          return nextEvent.indexOf(errorPlatform) === 0;
        })) {
          throw _event.data.data;
        }

        var nextState = provide(this, function () {
          return _this.machine.transition(_this.state, _event);
        });
        return nextState;
      };

      Interpreter.prototype.forward = function (event) {
        var e_13, _a;

        try {
          for (var _b = __values$1(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            var child = this.children.get(id);

            if (!child) {
              throw new Error("Unable to forward event '".concat(event, "' from interpreter '").concat(this.id, "' to nonexistant child '").concat(id, "'."));
            }

            child.send(event);
          }
        } catch (e_13_1) {
          e_13 = {
            error: e_13_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_13) throw e_13.error;
          }
        }
      };

      Interpreter.prototype.defer = function (sendAction) {
        var _this = this;

        this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function () {
          if (sendAction.to) {
            _this.sendTo(sendAction._event, sendAction.to);
          } else {
            _this.send(sendAction._event);
          }
        }, sendAction.delay);
      };

      Interpreter.prototype.cancel = function (sendId) {
        this.clock.clearTimeout(this.delayedEventsMap[sendId]);
        delete this.delayedEventsMap[sendId];
      };

      Interpreter.prototype.exec = function (action, state, actionFunctionMap) {
        if (actionFunctionMap === void 0) {
          actionFunctionMap = this.machine.options.actions;
        }

        var context = state.context,
            _event = state._event;
        var actionOrExec = action.exec || getActionFunction(action.type, actionFunctionMap);
        var exec = isFunction(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;

        if (exec) {
          try {
            return exec(context, _event.data, {
              action: action,
              state: this.state,
              _event: _event
            });
          } catch (err) {
            if (this.parent) {
              this.parent.send({
                type: 'xstate.error',
                data: err
              });
            }

            throw err;
          }
        }

        switch (action.type) {
          case send$1:
            var sendAction = action;

            if (typeof sendAction.delay === 'number') {
              this.defer(sendAction);
              return;
            } else {
              if (sendAction.to) {
                this.sendTo(sendAction._event, sendAction.to);
              } else {
                this.send(sendAction._event);
              }
            }

            break;

          case cancel$1:
            this.cancel(action.sendId);
            break;

          case start$1:
            {
              if (this.status !== InterpreterStatus.Running) {
                return;
              }

              var activity = action.activity; // If the activity will be stopped right after it's started
              // (such as in transient states)
              // don't bother starting the activity.

              if (!this.state.activities[activity.id || activity.type]) {
                break;
              } // Invoked services


              if (activity.type === ActionTypes.Invoke) {
                var invokeSource = toInvokeSource$1(activity.src);
                var serviceCreator = this.machine.options.services ? this.machine.options.services[invokeSource.type] : undefined;
                var id = activity.id,
                    data = activity.data;

                var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;

                if (!serviceCreator) {

                  return;
                }

                var resolvedData = data ? mapContext(data, context, _event) : undefined;

                if (typeof serviceCreator === 'string') {
                  // TODO: warn
                  return;
                }

                var source = isFunction(serviceCreator) ? serviceCreator(context, _event.data, {
                  data: resolvedData,
                  src: invokeSource,
                  meta: activity.meta
                }) : serviceCreator;

                if (!source) {
                  // TODO: warn?
                  return;
                }

                var options = void 0;

                if (isMachine(source)) {
                  source = resolvedData ? source.withContext(resolvedData) : source;
                  options = {
                    autoForward: autoForward
                  };
                }

                this.spawn(source, id, options);
              } else {
                this.spawnActivity(activity);
              }

              break;
            }

          case stop$1:
            {
              this.stopChild(action.activity.id);
              break;
            }

          case log:
            var label = action.label,
                value = action.value;

            if (label) {
              this.logger(label, value);
            } else {
              this.logger(value);
            }

            break;
        }

        return undefined;
      };

      Interpreter.prototype.removeChild = function (childId) {
        var _a;

        this.children.delete(childId);
        this.forwardTo.delete(childId); // this.state might not exist at the time this is called,
        // such as when a child is added then removed while initializing the state

        (_a = this.state) === null || _a === void 0 ? true : delete _a.children[childId];
      };

      Interpreter.prototype.stopChild = function (childId) {
        var child = this.children.get(childId);

        if (!child) {
          return;
        }

        this.removeChild(childId);

        if (isFunction(child.stop)) {
          child.stop();
        }
      };

      Interpreter.prototype.spawn = function (entity, name, options) {
        if (isPromiseLike(entity)) {
          return this.spawnPromise(Promise.resolve(entity), name);
        } else if (isFunction(entity)) {
          return this.spawnCallback(entity, name);
        } else if (isSpawnedActor(entity)) {
          return this.spawnActor(entity, name);
        } else if (isObservable(entity)) {
          return this.spawnObservable(entity, name);
        } else if (isMachine(entity)) {
          return this.spawnMachine(entity, __assign$1(__assign$1({}, options), {
            id: name
          }));
        } else if (isBehavior(entity)) {
          return this.spawnBehavior(entity, name);
        } else {
          throw new Error("Unable to spawn entity \"".concat(name, "\" of type \"").concat(typeof entity, "\"."));
        }
      };

      Interpreter.prototype.spawnMachine = function (machine, options) {
        var _this = this;

        if (options === void 0) {
          options = {};
        }

        var childService = new Interpreter(machine, __assign$1(__assign$1({}, this.options), {
          parent: this,
          id: options.id || machine.id
        }));

        var resolvedOptions = __assign$1(__assign$1({}, DEFAULT_SPAWN_OPTIONS), options);

        if (resolvedOptions.sync) {
          childService.onTransition(function (state) {
            _this.send(update, {
              state: state,
              id: childService.id
            });
          });
        }

        var actor = childService;
        this.children.set(childService.id, actor);

        if (resolvedOptions.autoForward) {
          this.forwardTo.add(childService.id);
        }

        childService.onDone(function (doneEvent) {
          _this.removeChild(childService.id);

          _this.send(toSCXMLEvent(doneEvent, {
            origin: childService.id
          }));
        }).start();
        return actor;
      };

      Interpreter.prototype.spawnBehavior = function (behavior, id) {
        var actorRef = spawnBehavior(behavior, {
          id: id,
          parent: this
        });
        this.children.set(id, actorRef);
        return actorRef;
      };

      Interpreter.prototype.spawnPromise = function (promise, id) {
        var _a;

        var _this = this;

        var canceled = false;
        var resolvedData;
        promise.then(function (response) {
          if (!canceled) {
            resolvedData = response;

            _this.removeChild(id);

            _this.send(toSCXMLEvent(doneInvoke(id, response), {
              origin: id
            }));
          }
        }, function (errorData) {
          if (!canceled) {
            _this.removeChild(id);

            var errorEvent = error(id, errorData);

            try {
              // Send "error.platform.id" to this (parent).
              _this.send(toSCXMLEvent(errorEvent, {
                origin: id
              }));
            } catch (error) {

              if (_this.devTools) {
                _this.devTools.send(errorEvent, _this.state);
              }

              if (_this.machine.strict) {
                // it would be better to always stop the state machine if unhandled
                // exception/promise rejection happens but because we don't want to
                // break existing code so enforce it on strict mode only especially so
                // because documentation says that onError is optional
                _this.stop();
              }
            }
          }
        });
        var actor = (_a = {
          id: id,
          send: function () {
            return void 0;
          },
          subscribe: function (next, handleError, complete) {
            var observer = toObserver(next, handleError, complete);
            var unsubscribed = false;
            promise.then(function (response) {
              if (unsubscribed) {
                return;
              }

              observer.next(response);

              if (unsubscribed) {
                return;
              }

              observer.complete();
            }, function (err) {
              if (unsubscribed) {
                return;
              }

              observer.error(err);
            });
            return {
              unsubscribe: function () {
                return unsubscribed = true;
              }
            };
          },
          stop: function () {
            canceled = true;
          },
          toJSON: function () {
            return {
              id: id
            };
          },
          getSnapshot: function () {
            return resolvedData;
          }
        }, _a[symbolObservable] = function () {
          return this;
        }, _a);
        this.children.set(id, actor);
        return actor;
      };

      Interpreter.prototype.spawnCallback = function (callback, id) {
        var _a;

        var _this = this;

        var canceled = false;
        var receivers = new Set();
        var listeners = new Set();
        var emitted;

        var receive = function (e) {
          emitted = e;
          listeners.forEach(function (listener) {
            return listener(e);
          });

          if (canceled) {
            return;
          }

          _this.send(toSCXMLEvent(e, {
            origin: id
          }));
        };

        var callbackStop;

        try {
          callbackStop = callback(receive, function (newListener) {
            receivers.add(newListener);
          });
        } catch (err) {
          this.send(error(id, err));
        }

        if (isPromiseLike(callbackStop)) {
          // it turned out to be an async function, can't reliably check this before calling `callback`
          // because transpiled async functions are not recognizable
          return this.spawnPromise(callbackStop, id);
        }

        var actor = (_a = {
          id: id,
          send: function (event) {
            return receivers.forEach(function (receiver) {
              return receiver(event);
            });
          },
          subscribe: function (next) {
            var observer = toObserver(next);
            listeners.add(observer.next);
            return {
              unsubscribe: function () {
                listeners.delete(observer.next);
              }
            };
          },
          stop: function () {
            canceled = true;

            if (isFunction(callbackStop)) {
              callbackStop();
            }
          },
          toJSON: function () {
            return {
              id: id
            };
          },
          getSnapshot: function () {
            return emitted;
          }
        }, _a[symbolObservable] = function () {
          return this;
        }, _a);
        this.children.set(id, actor);
        return actor;
      };

      Interpreter.prototype.spawnObservable = function (source, id) {
        var _a;

        var _this = this;

        var emitted;
        var subscription = source.subscribe(function (value) {
          emitted = value;

          _this.send(toSCXMLEvent(value, {
            origin: id
          }));
        }, function (err) {
          _this.removeChild(id);

          _this.send(toSCXMLEvent(error(id, err), {
            origin: id
          }));
        }, function () {
          _this.removeChild(id);

          _this.send(toSCXMLEvent(doneInvoke(id), {
            origin: id
          }));
        });
        var actor = (_a = {
          id: id,
          send: function () {
            return void 0;
          },
          subscribe: function (next, handleError, complete) {
            return source.subscribe(next, handleError, complete);
          },
          stop: function () {
            return subscription.unsubscribe();
          },
          getSnapshot: function () {
            return emitted;
          },
          toJSON: function () {
            return {
              id: id
            };
          }
        }, _a[symbolObservable] = function () {
          return this;
        }, _a);
        this.children.set(id, actor);
        return actor;
      };

      Interpreter.prototype.spawnActor = function (actor, name) {
        this.children.set(name, actor);
        return actor;
      };

      Interpreter.prototype.spawnActivity = function (activity) {
        var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;

        if (!implementation) {


          return;
        } // Start implementation


        var dispose = implementation(this.state.context, activity);
        this.spawnEffect(activity.id, dispose);
      };

      Interpreter.prototype.spawnEffect = function (id, dispose) {
        var _a;

        this.children.set(id, (_a = {
          id: id,
          send: function () {
            return void 0;
          },
          subscribe: function () {
            return {
              unsubscribe: function () {
                return void 0;
              }
            };
          },
          stop: dispose || undefined,
          getSnapshot: function () {
            return undefined;
          },
          toJSON: function () {
            return {
              id: id
            };
          }
        }, _a[symbolObservable] = function () {
          return this;
        }, _a));
      };

      Interpreter.prototype.attachDev = function () {
        var global = getGlobal();

        if (this.options.devTools && global) {
          if (global.__REDUX_DEVTOOLS_EXTENSION__) {
            var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;
            this.devTools = global.__REDUX_DEVTOOLS_EXTENSION__.connect(__assign$1(__assign$1({
              name: this.id,
              autoPause: true,
              stateSanitizer: function (state) {
                return {
                  value: state.value,
                  context: state.context,
                  actions: state.actions
                };
              }
            }, devToolsOptions), {
              features: __assign$1({
                jump: false,
                skip: false
              }, devToolsOptions ? devToolsOptions.features : undefined)
            }), this.machine);
            this.devTools.init(this.state);
          } // add XState-specific dev tooling hook


          registerService(this);
        }
      };

      Interpreter.prototype.toJSON = function () {
        return {
          id: this.id
        };
      };

      Interpreter.prototype[symbolObservable] = function () {
        return this;
      };

      Interpreter.prototype.getSnapshot = function () {
        if (this.status === InterpreterStatus.NotStarted) {
          return this.initialState;
        }

        return this._state;
      };
      /**
       * The default interpreter options:
       *
       * - `clock` uses the global `setTimeout` and `clearTimeout` functions
       * - `logger` uses the global `console.log()` method
       */


      Interpreter.defaultOptions = {
        execute: true,
        deferEvents: true,
        clock: {
          setTimeout: function (fn, ms) {
            return setTimeout(fn, ms);
          },
          clearTimeout: function (id) {
            return clearTimeout(id);
          }
        },
        logger: /*#__PURE__*/console.log.bind(console),
        devTools: false
      };
      Interpreter.interpret = interpret;
      return Interpreter;
    }();
    /**
     * Creates a new Interpreter instance for the given machine with the provided options, if any.
     *
     * @param machine The machine to interpret
     * @param options Interpreter options
     */

    function interpret(machine, options) {
      var interpreter = new Interpreter(machine, options);
      return interpreter;
    }

    function toInvokeSource(src) {
      if (typeof src === 'string') {
        var simpleSrc = {
          type: src
        };

        simpleSrc.toString = function () {
          return src;
        }; // v4 compat - TODO: remove in v5


        return simpleSrc;
      }

      return src;
    }
    function toInvokeDefinition(invokeConfig) {
      return __assign$1(__assign$1({
        type: invoke
      }, invokeConfig), {
        toJSON: function () {
          invokeConfig.onDone;
              invokeConfig.onError;
              var invokeDef = __rest$1(invokeConfig, ["onDone", "onError"]);

          return __assign$1(__assign$1({}, invokeDef), {
            type: invoke,
            src: toInvokeSource(invokeConfig.src)
          });
        }
      });
    }

    var NULL_EVENT = '';
    var STATE_IDENTIFIER = '#';
    var WILDCARD = '*';
    var EMPTY_OBJECT = {};

    var isStateId = function (str) {
      return str[0] === STATE_IDENTIFIER;
    };

    var createDefaultOptions = function () {
      return {
        actions: {},
        guards: {},
        services: {},
        activities: {},
        delays: {}
      };
    };

    var validateArrayifiedTransitions = function (stateNode, event, transitions) {
      var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {
        return !('cond' in transition) && !('in' in transition) && (isString(transition.target) || isMachine(transition.target));
      });
      var eventText = event === NULL_EVENT ? 'the transient event' : "event '".concat(event, "'");
      warn(!hasNonLastUnguardedTarget, "One or more transitions for ".concat(eventText, " on state '").concat(stateNode.id, "' are unreachable. ") + "Make sure that the default transition is the last one defined.");
    };

    var StateNode =
    /*#__PURE__*/

    /** @class */
    function () {
      function StateNode(
      /**
       * The raw config used to create the machine.
       */
      config, options,
      /**
       * The initial extended state
       */
      _context, // TODO: this is unsafe, but we're removing it in v5 anyway
      _stateInfo) {
        var _this = this;

        if (_context === void 0) {
          _context = 'context' in config ? config.context : undefined;
        }

        var _a;

        this.config = config;
        this._context = _context;
        /**
         * The order this state node appears. Corresponds to the implicit SCXML document order.
         */

        this.order = -1;
        this.__xstatenode = true;
        this.__cache = {
          events: undefined,
          relativeValue: new Map(),
          initialStateValue: undefined,
          initialState: undefined,
          on: undefined,
          transitions: undefined,
          candidates: {},
          delayedTransitions: undefined
        };
        this.idMap = {};
        this.tags = [];
        this.options = Object.assign(createDefaultOptions(), options);
        this.parent = _stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.parent;
        this.key = this.config.key || (_stateInfo === null || _stateInfo === void 0 ? void 0 : _stateInfo.key) || this.config.id || '(machine)';
        this.machine = this.parent ? this.parent.machine : this;
        this.path = this.parent ? this.parent.path.concat(this.key) : [];
        this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);
        this.id = this.config.id || __spreadArray([this.machine.key], __read(this.path), false).join(this.delimiter);
        this.version = this.parent ? this.parent.version : this.config.version;
        this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');
        this.schema = this.parent ? this.machine.schema : (_a = this.config.schema) !== null && _a !== void 0 ? _a : {};
        this.description = this.config.description;

        this.initial = this.config.initial;
        this.states = this.config.states ? mapValues(this.config.states, function (stateConfig, key) {
          var _a;

          var stateNode = new StateNode(stateConfig, {}, undefined, {
            parent: _this,
            key: key
          });
          Object.assign(_this.idMap, __assign$1((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
          return stateNode;
        }) : EMPTY_OBJECT; // Document order

        var order = 0;

        function dfs(stateNode) {
          var e_1, _a;

          stateNode.order = order++;

          try {
            for (var _b = __values$1(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {
              var child = _c.value;
              dfs(child);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }

        dfs(this); // History config

        this.history = this.config.history === true ? 'shallow' : this.config.history || false;
        this._transient = !!this.config.always || (!this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {
          var event = _a.event;
          return event === NULL_EVENT;
        }) : NULL_EVENT in this.config.on);
        this.strict = !!this.config.strict; // TODO: deprecate (entry)

        this.onEntry = toArray(this.config.entry || this.config.onEntry).map(function (action) {
          return toActionObject(action);
        }); // TODO: deprecate (exit)

        this.onExit = toArray(this.config.exit || this.config.onExit).map(function (action) {
          return toActionObject(action);
        });
        this.meta = this.config.meta;
        this.doneData = this.type === 'final' ? this.config.data : undefined;
        this.invoke = toArray(this.config.invoke).map(function (invokeConfig, i) {
          var _a, _b;

          if (isMachine(invokeConfig)) {
            var invokeId = createInvokeId(_this.id, i);
            _this.machine.options.services = __assign$1((_a = {}, _a[invokeId] = invokeConfig, _a), _this.machine.options.services);
            return toInvokeDefinition({
              src: invokeId,
              id: invokeId
            });
          } else if (isString(invokeConfig.src)) {
            var invokeId = invokeConfig.id || createInvokeId(_this.id, i);
            return toInvokeDefinition(__assign$1(__assign$1({}, invokeConfig), {
              id: invokeId,
              src: invokeConfig.src
            }));
          } else if (isMachine(invokeConfig.src) || isFunction(invokeConfig.src)) {
            var invokeId = invokeConfig.id || createInvokeId(_this.id, i);
            _this.machine.options.services = __assign$1((_b = {}, _b[invokeId] = invokeConfig.src, _b), _this.machine.options.services);
            return toInvokeDefinition(__assign$1(__assign$1({
              id: invokeId
            }, invokeConfig), {
              src: invokeId
            }));
          } else {
            var invokeSource = invokeConfig.src;
            return toInvokeDefinition(__assign$1(__assign$1({
              id: createInvokeId(_this.id, i)
            }, invokeConfig), {
              src: invokeSource
            }));
          }
        });
        this.activities = toArray(this.config.activities).concat(this.invoke).map(function (activity) {
          return toActivityDefinition(activity);
        });
        this.transition = this.transition.bind(this);
        this.tags = toArray(this.config.tags); // TODO: this is the real fix for initialization once
        // state node getters are deprecated
        // if (!this.parent) {
        //   this._init();
        // }
      }

      StateNode.prototype._init = function () {
        if (this.__cache.transitions) {
          return;
        }

        getAllStateNodes(this).forEach(function (stateNode) {
          return stateNode.on;
        });
      };
      /**
       * Clones this state machine with custom options and context.
       *
       * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
       * @param context Custom context (will override predefined context)
       */


      StateNode.prototype.withConfig = function (options, context) {
        var _a = this.options,
            actions = _a.actions,
            activities = _a.activities,
            guards = _a.guards,
            services = _a.services,
            delays = _a.delays;
        return new StateNode(this.config, {
          actions: __assign$1(__assign$1({}, actions), options.actions),
          activities: __assign$1(__assign$1({}, activities), options.activities),
          guards: __assign$1(__assign$1({}, guards), options.guards),
          services: __assign$1(__assign$1({}, services), options.services),
          delays: __assign$1(__assign$1({}, delays), options.delays)
        }, context !== null && context !== void 0 ? context : this.context);
      };
      /**
       * Clones this state machine with custom context.
       *
       * @param context Custom context (will override predefined context, not recursive)
       */


      StateNode.prototype.withContext = function (context) {
        return new StateNode(this.config, this.options, context);
      };

      Object.defineProperty(StateNode.prototype, "context", {
        get: function () {
          return isFunction(this._context) ? this._context() : this._context;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StateNode.prototype, "definition", {
        /**
         * The well-structured state node definition.
         */
        get: function () {
          return {
            id: this.id,
            key: this.key,
            version: this.version,
            context: this.context,
            type: this.type,
            initial: this.initial,
            history: this.history,
            states: mapValues(this.states, function (state) {
              return state.definition;
            }),
            on: this.on,
            transitions: this.transitions,
            entry: this.onEntry,
            exit: this.onExit,
            activities: this.activities || [],
            meta: this.meta,
            order: this.order || -1,
            data: this.doneData,
            invoke: this.invoke,
            description: this.description,
            tags: this.tags
          };
        },
        enumerable: false,
        configurable: true
      });

      StateNode.prototype.toJSON = function () {
        return this.definition;
      };

      Object.defineProperty(StateNode.prototype, "on", {
        /**
         * The mapping of events to transitions.
         */
        get: function () {
          if (this.__cache.on) {
            return this.__cache.on;
          }

          var transitions = this.transitions;
          return this.__cache.on = transitions.reduce(function (map, transition) {
            map[transition.eventType] = map[transition.eventType] || [];
            map[transition.eventType].push(transition);
            return map;
          }, {});
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StateNode.prototype, "after", {
        get: function () {
          return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StateNode.prototype, "transitions", {
        /**
         * All the transitions that can be taken from this state node.
         */
        get: function () {
          return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
        },
        enumerable: false,
        configurable: true
      });

      StateNode.prototype.getCandidates = function (eventName) {
        if (this.__cache.candidates[eventName]) {
          return this.__cache.candidates[eventName];
        }

        var transient = eventName === NULL_EVENT;
        var candidates = this.transitions.filter(function (transition) {
          var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions

          return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;
        });
        this.__cache.candidates[eventName] = candidates;
        return candidates;
      };
      /**
       * All delayed transitions from the config.
       */


      StateNode.prototype.getDelayedTransitions = function () {
        var _this = this;

        var afterConfig = this.config.after;

        if (!afterConfig) {
          return [];
        }

        var mutateEntryExit = function (delay, i) {
          var delayRef = isFunction(delay) ? "".concat(_this.id, ":delay[").concat(i, "]") : delay;
          var eventType = after(delayRef, _this.id);

          _this.onEntry.push(send(eventType, {
            delay: delay
          }));

          _this.onExit.push(cancel(eventType));

          return eventType;
        };

        var delayedTransitions = isArray(afterConfig) ? afterConfig.map(function (transition, i) {
          var eventType = mutateEntryExit(transition.delay, i);
          return __assign$1(__assign$1({}, transition), {
            event: eventType
          });
        }) : flatten(Object.keys(afterConfig).map(function (delay, i) {
          var configTransition = afterConfig[delay];
          var resolvedTransition = isString(configTransition) ? {
            target: configTransition
          } : configTransition;
          var resolvedDelay = !isNaN(+delay) ? +delay : delay;
          var eventType = mutateEntryExit(resolvedDelay, i);
          return toArray(resolvedTransition).map(function (transition) {
            return __assign$1(__assign$1({}, transition), {
              event: eventType,
              delay: resolvedDelay
            });
          });
        }));
        return delayedTransitions.map(function (delayedTransition) {
          var delay = delayedTransition.delay;
          return __assign$1(__assign$1({}, _this.formatTransition(delayedTransition)), {
            delay: delay
          });
        });
      };
      /**
       * Returns the state nodes represented by the current state value.
       *
       * @param state The state value or State instance
       */


      StateNode.prototype.getStateNodes = function (state) {
        var _a;

        var _this = this;

        if (!state) {
          return [];
        }

        var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);

        if (isString(stateValue)) {
          var initialStateValue = this.getStateNode(stateValue).initial;
          return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this, this.states[stateValue]];
        }

        var subStateKeys = Object.keys(stateValue);
        var subStateNodes = [this];
        subStateNodes.push.apply(subStateNodes, __spreadArray([], __read(flatten(subStateKeys.map(function (subStateKey) {
          return _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);
        }))), false));
        return subStateNodes;
      };
      /**
       * Returns `true` if this state node explicitly handles the given event.
       *
       * @param event The event in question
       */


      StateNode.prototype.handles = function (event) {
        var eventType = getEventType(event);
        return this.events.includes(eventType);
      };
      /**
       * Resolves the given `state` to a new `State` instance relative to this machine.
       *
       * This ensures that `.events` and `.nextEvents` represent the correct values.
       *
       * @param state The state to resolve
       */


      StateNode.prototype.resolveState = function (state) {
        var stateFromConfig = state instanceof State ? state : State.create(state);
        var configuration = Array.from(getConfiguration([], this.getStateNodes(stateFromConfig.value)));
        return new State(__assign$1(__assign$1({}, stateFromConfig), {
          value: this.resolve(stateFromConfig.value),
          configuration: configuration,
          done: isInFinalState(configuration, this),
          tags: getTagsFromConfiguration(configuration),
          machine: this.machine
        }));
      };

      StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {
        var stateNode = this.getStateNode(stateValue);
        var next = stateNode.next(state, _event);

        if (!next || !next.transitions.length) {
          return this.next(state, _event);
        }

        return next;
      };

      StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {
        var subStateKeys = Object.keys(stateValue);
        var stateNode = this.getStateNode(subStateKeys[0]);

        var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);

        if (!next || !next.transitions.length) {
          return this.next(state, _event);
        }

        return next;
      };

      StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {
        var e_2, _a;

        var transitionMap = {};

        try {
          for (var _b = __values$1(Object.keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var subStateKey = _c.value;
            var subStateValue = stateValue[subStateKey];

            if (!subStateValue) {
              continue;
            }

            var subStateNode = this.getStateNode(subStateKey);

            var next = subStateNode._transition(subStateValue, state, _event);

            if (next) {
              transitionMap[subStateKey] = next;
            }
          }
        } catch (e_2_1) {
          e_2 = {
            error: e_2_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_2) throw e_2.error;
          }
        }

        var stateTransitions = Object.keys(transitionMap).map(function (key) {
          return transitionMap[key];
        });
        var enabledTransitions = flatten(stateTransitions.map(function (st) {
          return st.transitions;
        }));
        var willTransition = stateTransitions.some(function (st) {
          return st.transitions.length > 0;
        });

        if (!willTransition) {
          return this.next(state, _event);
        }

        var entryNodes = flatten(stateTransitions.map(function (t) {
          return t.entrySet;
        }));
        var configuration = flatten(Object.keys(transitionMap).map(function (key) {
          return transitionMap[key].configuration;
        }));
        return {
          transitions: enabledTransitions,
          entrySet: entryNodes,
          exitSet: flatten(stateTransitions.map(function (t) {
            return t.exitSet;
          })),
          configuration: configuration,
          source: state,
          actions: flatten(Object.keys(transitionMap).map(function (key) {
            return transitionMap[key].actions;
          }))
        };
      };

      StateNode.prototype._transition = function (stateValue, state, _event) {
        // leaf node
        if (isString(stateValue)) {
          return this.transitionLeafNode(stateValue, state, _event);
        } // hierarchical node


        if (Object.keys(stateValue).length === 1) {
          return this.transitionCompoundNode(stateValue, state, _event);
        } // orthogonal node


        return this.transitionParallelNode(stateValue, state, _event);
      };

      StateNode.prototype.getTransitionData = function (state, event) {
        return this._transition(state.value, state, toSCXMLEvent(event));
      };

      StateNode.prototype.next = function (state, _event) {
        var e_3, _a;

        var _this = this;

        var eventName = _event.name;
        var actions = [];
        var nextStateNodes = [];
        var selectedTransition;

        try {
          for (var _b = __values$1(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var candidate = _c.value;
            var cond = candidate.cond,
                stateIn = candidate.in;
            var resolvedContext = state.context;
            var isInState = stateIn ? isString(stateIn) && isStateId(stateIn) ? // Check if in state by ID
            state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent
            matchesState(toStateValue(stateIn, this.delimiter), path(this.path.slice(0, -2))(state.value)) : true;
            var guardPassed = false;

            try {
              guardPassed = !cond || evaluateGuard(this.machine, cond, resolvedContext, _event, state);
            } catch (err) {
              throw new Error("Unable to evaluate guard '".concat(cond.name || cond.type, "' in transition for event '").concat(eventName, "' in state node '").concat(this.id, "':\n").concat(err.message));
            }

            if (guardPassed && isInState) {
              if (candidate.target !== undefined) {
                nextStateNodes = candidate.target;
              }

              actions.push.apply(actions, __spreadArray([], __read(candidate.actions), false));
              selectedTransition = candidate;
              break;
            }
          }
        } catch (e_3_1) {
          e_3 = {
            error: e_3_1
          };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_3) throw e_3.error;
          }
        }

        if (!selectedTransition) {
          return undefined;
        }

        if (!nextStateNodes.length) {
          return {
            transitions: [selectedTransition],
            entrySet: [],
            exitSet: [],
            configuration: state.value ? [this] : [],
            source: state,
            actions: actions
          };
        }

        var allNextStateNodes = flatten(nextStateNodes.map(function (stateNode) {
          return _this.getRelativeStateNodes(stateNode, state.historyValue);
        }));
        var isInternal = !!selectedTransition.internal;
        var reentryNodes = isInternal ? [] : flatten(allNextStateNodes.map(function (n) {
          return _this.nodesFromChild(n);
        }));
        return {
          transitions: [selectedTransition],
          entrySet: reentryNodes,
          exitSet: isInternal ? [] : [this],
          configuration: allNextStateNodes,
          source: state,
          actions: actions
        };
      };

      StateNode.prototype.nodesFromChild = function (childStateNode) {
        if (childStateNode.escapes(this)) {
          return [];
        }

        var nodes = [];
        var marker = childStateNode;

        while (marker && marker !== this) {
          nodes.push(marker);
          marker = marker.parent;
        }

        nodes.push(this); // inclusive

        return nodes;
      };
      /**
       * Whether the given state node "escapes" this state node. If the `stateNode` is equal to or the parent of
       * this state node, it does not escape.
       */


      StateNode.prototype.escapes = function (stateNode) {
        if (this === stateNode) {
          return false;
        }

        var parent = this.parent;

        while (parent) {
          if (parent === stateNode) {
            return false;
          }

          parent = parent.parent;
        }

        return true;
      };

      StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {
        var e_4, _a, e_5, _b;

        var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);
        var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;

        try {
          for (var resolvedConfig_1 = __values$1(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {
            var sn = resolvedConfig_1_1.value;

            if (!has(prevConfig, sn)) {
              transition.entrySet.push(sn);
            }
          }
        } catch (e_4_1) {
          e_4 = {
            error: e_4_1
          };
        } finally {
          try {
            if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);
          } finally {
            if (e_4) throw e_4.error;
          }
        }

        try {
          for (var prevConfig_1 = __values$1(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {
            var sn = prevConfig_1_1.value;

            if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {
              transition.exitSet.push(sn);
            }
          }
        } catch (e_5_1) {
          e_5 = {
            error: e_5_1
          };
        } finally {
          try {
            if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);
          } finally {
            if (e_5) throw e_5.error;
          }
        }

        var doneEvents = flatten(transition.entrySet.map(function (sn) {
          var events = [];

          if (sn.type !== 'final') {
            return events;
          }

          var parent = sn.parent;

          if (!parent.parent) {
            return events;
          }

          events.push(done(sn.id, sn.doneData), // TODO: deprecate - final states should not emit done events for their own state.
          done(parent.id, sn.doneData ? mapContext(sn.doneData, currentContext, _event) : undefined));
          var grandparent = parent.parent;

          if (grandparent.type === 'parallel') {
            if (getChildren(grandparent).every(function (parentNode) {
              return isInFinalState(transition.configuration, parentNode);
            })) {
              events.push(done(grandparent.id));
            }
          }

          return events;
        }));
        transition.exitSet.sort(function (a, b) {
          return b.order - a.order;
        });
        transition.entrySet.sort(function (a, b) {
          return a.order - b.order;
        });
        var entryStates = new Set(transition.entrySet);
        var exitStates = new Set(transition.exitSet);

        var _c = __read([flatten(Array.from(entryStates).map(function (stateNode) {
          return __spreadArray(__spreadArray([], __read(stateNode.activities.map(function (activity) {
            return start(activity);
          })), false), __read(stateNode.onEntry), false);
        })).concat(doneEvents.map(raise)), flatten(Array.from(exitStates).map(function (stateNode) {
          return __spreadArray(__spreadArray([], __read(stateNode.onExit), false), __read(stateNode.activities.map(function (activity) {
            return stop(activity);
          })), false);
        }))], 2),
            entryActions = _c[0],
            exitActions = _c[1];

        var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);
        return actions;
      };
      /**
       * Determines the next state given the current `state` and sent `event`.
       *
       * @param state The current State instance or state value
       * @param event The event that was sent at the current state
       * @param context The current context (extended state) of the current state
       */


      StateNode.prototype.transition = function (state, event, context) {
        if (state === void 0) {
          state = this.initialState;
        }

        var _event = toSCXMLEvent(event);

        var currentState;

        if (state instanceof State) {
          currentState = context === undefined ? state : this.resolveState(State.from(state, context));
        } else {
          var resolvedStateValue = isString(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);
          var resolvedContext = context !== null && context !== void 0 ? context : this.machine.context;
          currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));
        }

        if (!IS_PRODUCTION && _event.name === WILDCARD) {
          throw new Error("An event cannot have the wildcard type ('".concat(WILDCARD, "')"));
        }

        if (this.strict) {
          if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {
            throw new Error("Machine '".concat(this.id, "' does not accept event '").concat(_event.name, "'"));
          }
        }

        var stateTransition = this._transition(currentState.value, currentState, _event) || {
          transitions: [],
          configuration: [],
          entrySet: [],
          exitSet: [],
          source: currentState,
          actions: []
        };
        var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));
        var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;
        stateTransition.configuration = __spreadArray([], __read(resolvedConfig), false);
        return this.resolveTransition(stateTransition, currentState, currentState.context, _event);
      };

      StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {
        var _a;

        var currentActions = state.actions;
        state = this.transition(state, _event); // Save original event to state
        // TODO: this should be the raised event! Delete in V5 (breaking)

        state._event = originalEvent;
        state.event = originalEvent.data;

        (_a = state.actions).unshift.apply(_a, __spreadArray([], __read(currentActions), false));

        return state;
      };

      StateNode.prototype.resolveTransition = function (stateTransition, currentState, context, _event) {
        var e_6, _a;

        var _this = this;

        if (_event === void 0) {
          _event = initEvent;
        }

        var configuration = stateTransition.configuration; // Transition will "apply" if:
        // - this is the initial state (there is no current state)
        // - OR there are transitions

        var willTransition = !currentState || stateTransition.transitions.length > 0;
        var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : undefined;
        var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;
        var actions = this.getActions(stateTransition, context, _event, currentState);
        var activities = currentState ? __assign$1({}, currentState.activities) : {};

        try {
          for (var actions_1 = __values$1(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
            var action = actions_1_1.value;

            if (action.type === start$1) {
              activities[action.activity.id || action.activity.type] = action;
            } else if (action.type === stop$1) {
              activities[action.activity.id || action.activity.type] = false;
            }
          }
        } catch (e_6_1) {
          e_6 = {
            error: e_6_1
          };
        } finally {
          try {
            if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
          } finally {
            if (e_6) throw e_6.error;
          }
        }

        var _b = __read(resolveActions(this, currentState, context, _event, actions, this.machine.config.preserveActionOrder), 2),
            resolvedActions = _b[0],
            updatedContext = _b[1];

        var _c = __read(partition(resolvedActions, function (action) {
          return action.type === raise$1 || action.type === send$1 && action.to === SpecialTargets.Internal;
        }), 2),
            raisedEvents = _c[0],
            nonRaisedActions = _c[1];

        var invokeActions = resolvedActions.filter(function (action) {
          var _a;

          return action.type === start$1 && ((_a = action.activity) === null || _a === void 0 ? void 0 : _a.type) === invoke;
        });
        var children = invokeActions.reduce(function (acc, action) {
          acc[action.activity.id] = createInvocableActor(action.activity, _this.machine, updatedContext, _event);
          return acc;
        }, currentState ? __assign$1({}, currentState.children) : {});
        var resolvedConfiguration = willTransition ? stateTransition.configuration : currentState ? currentState.configuration : [];
        var isDone = isInFinalState(resolvedConfiguration, this);
        var nextState = new State({
          value: resolvedStateValue || currentState.value,
          context: updatedContext,
          _event: _event,
          // Persist _sessionid between states
          _sessionid: currentState ? currentState._sessionid : null,
          historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,
          history: !resolvedStateValue || stateTransition.source ? currentState : undefined,
          actions: resolvedStateValue ? nonRaisedActions : [],
          activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},
          events: [],
          configuration: resolvedConfiguration,
          transitions: stateTransition.transitions,
          children: children,
          done: isDone,
          tags: getTagsFromConfiguration(resolvedConfiguration),
          machine: this
        });
        var didUpdateContext = context !== updatedContext;
        nextState.changed = _event.name === update || didUpdateContext; // Dispose of penultimate histories to prevent memory leaks

        var history = nextState.history;

        if (history) {
          delete history.history;
        } // There are transient transitions if the machine is not in a final state
        // and if some of the state nodes have transient ("always") transitions.


        var isTransient = !isDone && (this._transient || configuration.some(function (stateNode) {
          return stateNode._transient;
        })); // If there are no enabled transitions, check if there are transient transitions.
        // If there are transient transitions, continue checking for more transitions
        // because an transient transition should be triggered even if there are no
        // enabled transitions.
        //
        // If we're already working on an transient transition (by checking
        // if the event is a NULL_EVENT), then stop to prevent an infinite loop.
        //
        // Otherwise, if there are no enabled nor transient transitions, we are done.

        if (!willTransition && (!isTransient || _event.name === NULL_EVENT)) {
          return nextState;
        }

        var maybeNextState = nextState;

        if (!isDone) {
          if (isTransient) {
            maybeNextState = this.resolveRaisedTransition(maybeNextState, {
              type: nullEvent
            }, _event);
          }

          while (raisedEvents.length) {
            var raisedEvent = raisedEvents.shift();
            maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);
          }
        } // Detect if state changed


        var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || didUpdateContext || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : undefined);
        maybeNextState.changed = changed; // Preserve original history after raised events

        maybeNextState.history = history;
        return maybeNextState;
      };
      /**
       * Returns the child state node from its relative `stateKey`, or throws.
       */


      StateNode.prototype.getStateNode = function (stateKey) {
        if (isStateId(stateKey)) {
          return this.machine.getStateNodeById(stateKey);
        }

        if (!this.states) {
          throw new Error("Unable to retrieve child state '".concat(stateKey, "' from '").concat(this.id, "'; no child states exist."));
        }

        var result = this.states[stateKey];

        if (!result) {
          throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
        }

        return result;
      };
      /**
       * Returns the state node with the given `stateId`, or throws.
       *
       * @param stateId The state ID. The prefix "#" is removed.
       */


      StateNode.prototype.getStateNodeById = function (stateId) {
        var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;

        if (resolvedStateId === this.id) {
          return this;
        }

        var stateNode = this.machine.idMap[resolvedStateId];

        if (!stateNode) {
          throw new Error("Child state node '#".concat(resolvedStateId, "' does not exist on machine '").concat(this.id, "'"));
        }

        return stateNode;
      };
      /**
       * Returns the relative state node from the given `statePath`, or throws.
       *
       * @param statePath The string or string array relative path to the state node.
       */


      StateNode.prototype.getStateNodeByPath = function (statePath) {
        if (typeof statePath === 'string' && isStateId(statePath)) {
          try {
            return this.getStateNodeById(statePath.slice(1));
          } catch (e) {// try individual paths
            // throw e;
          }
        }

        var arrayStatePath = toStatePath(statePath, this.delimiter).slice();
        var currentStateNode = this;

        while (arrayStatePath.length) {
          var key = arrayStatePath.shift();

          if (!key.length) {
            break;
          }

          currentStateNode = currentStateNode.getStateNode(key);
        }

        return currentStateNode;
      };
      /**
       * Resolves a partial state value with its full representation in this machine.
       *
       * @param stateValue The partial state value to resolve.
       */


      StateNode.prototype.resolve = function (stateValue) {
        var _a;

        var _this = this;

        if (!stateValue) {
          return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties
        }

        switch (this.type) {
          case 'parallel':
            return mapValues(this.initialStateValue, function (subStateValue, subStateKey) {
              return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;
            });

          case 'compound':
            if (isString(stateValue)) {
              var subStateNode = this.getStateNode(stateValue);

              if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {
                return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;
              }

              return stateValue;
            }

            if (!Object.keys(stateValue).length) {
              return this.initialStateValue || {};
            }

            return mapValues(stateValue, function (subStateValue, subStateKey) {
              return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;
            });

          default:
            return stateValue || EMPTY_OBJECT;
        }
      };

      StateNode.prototype.getResolvedPath = function (stateIdentifier) {
        if (isStateId(stateIdentifier)) {
          var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];

          if (!stateNode) {
            throw new Error("Unable to find state node '".concat(stateIdentifier, "'"));
          }

          return stateNode.path;
        }

        return toStatePath(stateIdentifier, this.delimiter);
      };

      Object.defineProperty(StateNode.prototype, "initialStateValue", {
        get: function () {
          var _a;

          if (this.__cache.initialStateValue) {
            return this.__cache.initialStateValue;
          }

          var initialStateValue;

          if (this.type === 'parallel') {
            initialStateValue = mapFilterValues(this.states, function (state) {
              return state.initialStateValue || EMPTY_OBJECT;
            }, function (stateNode) {
              return !(stateNode.type === 'history');
            });
          } else if (this.initial !== undefined) {
            if (!this.states[this.initial]) {
              throw new Error("Initial state '".concat(this.initial, "' not found on '").concat(this.key, "'"));
            }

            initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);
          } else {
            // The finite state value of a machine without child states is just an empty object
            initialStateValue = {};
          }

          this.__cache.initialStateValue = initialStateValue;
          return this.__cache.initialStateValue;
        },
        enumerable: false,
        configurable: true
      });

      StateNode.prototype.getInitialState = function (stateValue, context) {
        this._init(); // TODO: this should be in the constructor (see note in constructor)


        var configuration = this.getStateNodes(stateValue);
        return this.resolveTransition({
          configuration: configuration,
          entrySet: configuration,
          exitSet: [],
          transitions: [],
          source: undefined,
          actions: []
        }, undefined, context !== null && context !== void 0 ? context : this.machine.context, undefined);
      };

      Object.defineProperty(StateNode.prototype, "initialState", {
        /**
         * The initial State instance, which includes all actions to be executed from
         * entering the initial state.
         */
        get: function () {
          var initialStateValue = this.initialStateValue;

          if (!initialStateValue) {
            throw new Error("Cannot retrieve initial state from simple state '".concat(this.id, "'."));
          }

          return this.getInitialState(initialStateValue);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StateNode.prototype, "target", {
        /**
         * The target state value of the history state node, if it exists. This represents the
         * default state value to transition to if no history value exists yet.
         */
        get: function () {
          var target;

          if (this.type === 'history') {
            var historyConfig = this.config;

            if (isString(historyConfig.target)) {
              target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;
            } else {
              target = historyConfig.target;
            }
          }

          return target;
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Returns the leaf nodes from a state path relative to this state node.
       *
       * @param relativeStateId The relative state path to retrieve the state nodes
       * @param history The previous state to retrieve history
       * @param resolve Whether state nodes should resolve to initial child state nodes
       */

      StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {
        if (resolve === void 0) {
          resolve = true;
        }

        return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];
      };

      Object.defineProperty(StateNode.prototype, "initialStateNodes", {
        get: function () {
          var _this = this;

          if (isLeafNode(this)) {
            return [this];
          } // Case when state node is compound but no initial state is defined


          if (this.type === 'compound' && !this.initial) {
            if (!IS_PRODUCTION) {
              warn(false, "Compound state node '".concat(this.id, "' has no initial state."));
            }

            return [this];
          }

          var initialStateNodePaths = toStatePaths(this.initialStateValue);
          return flatten(initialStateNodePaths.map(function (initialPath) {
            return _this.getFromRelativePath(initialPath);
          }));
        },
        enumerable: false,
        configurable: true
      });
      /**
       * Retrieves state nodes from a relative path to this state node.
       *
       * @param relativePath The relative path from this state node
       * @param historyValue
       */

      StateNode.prototype.getFromRelativePath = function (relativePath) {
        if (!relativePath.length) {
          return [this];
        }

        var _a = __read(relativePath),
            stateKey = _a[0],
            childStatePath = _a.slice(1);

        if (!this.states) {
          throw new Error("Cannot retrieve subPath '".concat(stateKey, "' from node with no states"));
        }

        var childStateNode = this.getStateNode(stateKey);

        if (childStateNode.type === 'history') {
          return childStateNode.resolveHistory();
        }

        if (!this.states[stateKey]) {
          throw new Error("Child state '".concat(stateKey, "' does not exist on '").concat(this.id, "'"));
        }

        return this.states[stateKey].getFromRelativePath(childStatePath);
      };

      StateNode.prototype.historyValue = function (relativeStateValue) {
        if (!Object.keys(this.states).length) {
          return undefined;
        }

        return {
          current: relativeStateValue || this.initialStateValue,
          states: mapFilterValues(this.states, function (stateNode, key) {
            if (!relativeStateValue) {
              return stateNode.historyValue();
            }

            var subStateValue = isString(relativeStateValue) ? undefined : relativeStateValue[key];
            return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
          }, function (stateNode) {
            return !stateNode.history;
          })
        };
      };
      /**
       * Resolves to the historical value(s) of the parent state node,
       * represented by state nodes.
       *
       * @param historyValue
       */


      StateNode.prototype.resolveHistory = function (historyValue) {
        var _this = this;

        if (this.type !== 'history') {
          return [this];
        }

        var parent = this.parent;

        if (!historyValue) {
          var historyTarget = this.target;
          return historyTarget ? flatten(toStatePaths(historyTarget).map(function (relativeChildPath) {
            return parent.getFromRelativePath(relativeChildPath);
          })) : parent.initialStateNodes;
        }

        var subHistoryValue = nestedPath(parent.path, 'states')(historyValue).current;

        if (isString(subHistoryValue)) {
          return [parent.getStateNode(subHistoryValue)];
        }

        return flatten(toStatePaths(subHistoryValue).map(function (subStatePath) {
          return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];
        }));
      };

      Object.defineProperty(StateNode.prototype, "stateIds", {
        /**
         * All the state node IDs of this state node and its descendant state nodes.
         */
        get: function () {
          var _this = this;

          var childStateIds = flatten(Object.keys(this.states).map(function (stateKey) {
            return _this.states[stateKey].stateIds;
          }));
          return [this.id].concat(childStateIds);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StateNode.prototype, "events", {
        /**
         * All the event types accepted by this state node and its descendants.
         */
        get: function () {
          var e_7, _a, e_8, _b;

          if (this.__cache.events) {
            return this.__cache.events;
          }

          var states = this.states;
          var events = new Set(this.ownEvents);

          if (states) {
            try {
              for (var _c = __values$1(Object.keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var stateId = _d.value;
                var state = states[stateId];

                if (state.states) {
                  try {
                    for (var _e = (e_8 = void 0, __values$1(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {
                      var event_1 = _f.value;
                      events.add("".concat(event_1));
                    }
                  } catch (e_8_1) {
                    e_8 = {
                      error: e_8_1
                    };
                  } finally {
                    try {
                      if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    } finally {
                      if (e_8) throw e_8.error;
                    }
                  }
                }
              }
            } catch (e_7_1) {
              e_7 = {
                error: e_7_1
              };
            } finally {
              try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              } finally {
                if (e_7) throw e_7.error;
              }
            }
          }

          return this.__cache.events = Array.from(events);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(StateNode.prototype, "ownEvents", {
        /**
         * All the events that have transitions directly from this state node.
         *
         * Excludes any inert events.
         */
        get: function () {
          var events = new Set(this.transitions.filter(function (transition) {
            return !(!transition.target && !transition.actions.length && transition.internal);
          }).map(function (transition) {
            return transition.eventType;
          }));
          return Array.from(events);
        },
        enumerable: false,
        configurable: true
      });

      StateNode.prototype.resolveTarget = function (_target) {
        var _this = this;

        if (_target === undefined) {
          // an undefined target signals that the state node should not transition from that state when receiving that event
          return undefined;
        }

        return _target.map(function (target) {
          if (!isString(target)) {
            return target;
          }

          var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,
          // do not include machine key on target

          if (isInternalTarget && !_this.parent) {
            return _this.getStateNodeByPath(target.slice(1));
          }

          var resolvedTarget = isInternalTarget ? _this.key + target : target;

          if (_this.parent) {
            try {
              var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);

              return targetStateNode;
            } catch (err) {
              throw new Error("Invalid transition definition for state node '".concat(_this.id, "':\n").concat(err.message));
            }
          } else {
            return _this.getStateNodeByPath(resolvedTarget);
          }
        });
      };

      StateNode.prototype.formatTransition = function (transitionConfig) {
        var _this = this;

        var normalizedTarget = normalizeTarget(transitionConfig.target);
        var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {
          return isString(_target) && _target[0] === _this.delimiter;
        }) : true;
        var guards = this.machine.options.guards;
        var target = this.resolveTarget(normalizedTarget);

        var transition = __assign$1(__assign$1({}, transitionConfig), {
          actions: toActionObjects(toArray(transitionConfig.actions)),
          cond: toGuard(transitionConfig.cond, guards),
          target: target,
          source: this,
          internal: internal,
          eventType: transitionConfig.event,
          toJSON: function () {
            return __assign$1(__assign$1({}, transition), {
              target: transition.target ? transition.target.map(function (t) {
                return "#".concat(t.id);
              }) : undefined,
              source: "#".concat(_this.id)
            });
          }
        });

        return transition;
      };

      StateNode.prototype.formatTransitions = function () {
        var e_9, _a;

        var _this = this;

        var onConfig;

        if (!this.config.on) {
          onConfig = [];
        } else if (Array.isArray(this.config.on)) {
          onConfig = this.config.on;
        } else {
          var _b = this.config.on,
              _c = WILDCARD,
              _d = _b[_c],
              wildcardConfigs = _d === void 0 ? [] : _d,
              strictTransitionConfigs_1 = __rest$1(_b, [typeof _c === "symbol" ? _c : _c + ""]);

          onConfig = flatten(Object.keys(strictTransitionConfigs_1).map(function (key) {
            if (!IS_PRODUCTION && key === NULL_EVENT) {
              warn(false, "Empty string transition configs (e.g., `{ on: { '': ... }}`) for transient transitions are deprecated. Specify the transition in the `{ always: ... }` property instead. " + "Please check the `on` configuration for \"#".concat(_this.id, "\"."));
            }

            var transitionConfigArray = toTransitionConfigArray(key, strictTransitionConfigs_1[key]);

            if (!IS_PRODUCTION) {
              validateArrayifiedTransitions(_this, key, transitionConfigArray);
            }

            return transitionConfigArray;
          }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));
        }

        var eventlessConfig = this.config.always ? toTransitionConfigArray('', this.config.always) : [];
        var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];

        if (!IS_PRODUCTION) {
          warn(!(this.config.onDone && !this.parent), "Root nodes cannot have an \".onDone\" transition. Please check the config of \"".concat(this.id, "\"."));
        }

        var invokeConfig = flatten(this.invoke.map(function (invokeDef) {
          var settleTransitions = [];

          if (invokeDef.onDone) {
            settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)), false));
          }

          if (invokeDef.onError) {
            settleTransitions.push.apply(settleTransitions, __spreadArray([], __read(toTransitionConfigArray(String(error(invokeDef.id)), invokeDef.onError)), false));
          }

          return settleTransitions;
        }));
        var delayedTransitions = this.after;
        var formattedTransitions = flatten(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(doneConfig), false), __read(invokeConfig), false), __read(onConfig), false), __read(eventlessConfig), false).map(function (transitionConfig) {
          return toArray(transitionConfig).map(function (transition) {
            return _this.formatTransition(transition);
          });
        }));

        try {
          for (var delayedTransitions_1 = __values$1(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
            var delayedTransition = delayedTransitions_1_1.value;
            formattedTransitions.push(delayedTransition);
          }
        } catch (e_9_1) {
          e_9 = {
            error: e_9_1
          };
        } finally {
          try {
            if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);
          } finally {
            if (e_9) throw e_9.error;
          }
        }

        return formattedTransitions;
      };

      return StateNode;
    }();

    function createMachine(config, options) {
      return new StateNode(config, options);
    }

    var assign = assign$1;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    var fastSafeStringify = stringify$1;
    stringify$1.default = stringify$1;
    stringify$1.stable = deterministicStringify;
    stringify$1.stableStringify = deterministicStringify;

    var LIMIT_REPLACE_NODE = '[...]';
    var CIRCULAR_REPLACE_NODE = '[Circular]';

    var arr = [];
    var replacerStack = [];

    function defaultOptions () {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      }
    }

    // Regular stringify
    function stringify$1 (obj, replacer, spacer, options) {
      if (typeof options === 'undefined') {
        options = defaultOptions();
      }

      decirc(obj, '', 0, [], undefined, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res
    }

    function setReplace (replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== undefined) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }

    function decirc (val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === 'object' && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return
          }
        }

        if (
          typeof options.depthLimit !== 'undefined' &&
          depth > options.depthLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        if (
          typeof options.edgesLimit !== 'undefined' &&
          edgeIndex + 1 > options.edgesLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }

    // Stable-stringify
    function compareFunction (a, b) {
      if (a < b) {
        return -1
      }
      if (a > b) {
        return 1
      }
      return 0
    }

    function deterministicStringify (obj, replacer, spacer, options) {
      if (typeof options === 'undefined') {
        options = defaultOptions();
      }

      var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')
      } finally {
        // Ensure that we restore the object as it was.
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res
    }

    function deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === 'object' && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return
          }
        }
        try {
          if (typeof val.toJSON === 'function') {
            return
          }
        } catch (_) {
          return
        }

        if (
          typeof options.depthLimit !== 'undefined' &&
          depth > options.depthLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        if (
          typeof options.edgesLimit !== 'undefined' &&
          edgeIndex + 1 > options.edgesLimit
        ) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return
        }

        stack.push(val);
        // Optimize for Arrays. Big arrays could kill the performance otherwise!
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          // Create a temporary object in the required way
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== 'undefined') {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp
          }
        }
        stack.pop();
      }
    }

    // wraps replacer function to handle values we couldn't replace
    // and mark them as replaced value
    function replaceGetterValues (replacer) {
      replacer =
        typeof replacer !== 'undefined'
          ? replacer
          : function (k, v) {
            return v
          };
      return function (key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break
            }
          }
        }
        return replacer.call(this, key, val)
      }
    }

    var safeStringify = fastSafeStringify;

    function getLazy(value) {
        return typeof value === 'function' ? value() : value;
    }
    function stringify(value, replacer) {
        try {
            return JSON.stringify(value, replacer);
        }
        catch (e) {
            return safeStringify(value, replacer);
        }
    }

    function selectivelyStringify(value, keys, replacer) {
        var e_1, _a;
        var selected = {};
        try {
            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var key = keys_1_1.value;
                selected[key] = value[key];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var serialized = JSON.parse(stringify(selected, replacer));
        return stringify(__assign(__assign({}, value), serialized));
    }
    function stringifyState(state, replacer) {
        state.machine; state.configuration; state.history; var stateToStringify = __rest(state, ["machine", "configuration", "history"]);
        return selectivelyStringify(stateToStringify, ['context', 'event', '_event'], replacer);
    }
    function stringifyMachine(machine, replacer) {
        return selectivelyStringify(machine.definition, ['context'], replacer);
    }

    function createInspectMachine(devTools, options) {
        if (devTools === void 0) { devTools = globalThis.__xstate__; }
        var serviceMap = new Map();
        // Listen for services being registered and index them
        // by their sessionId for quicker lookup
        var sub = devTools.onRegister(function (service) {
            serviceMap.set(service.sessionId, service);
        });
        return createMachine({
            initial: 'pendingConnection',
            context: {
                client: undefined
            },
            states: {
                pendingConnection: {},
                connected: {
                    on: {
                        'service.state': {
                            actions: function (ctx, e) { return ctx.client.send(e); }
                        },
                        'service.event': {
                            actions: function (ctx, e) { return ctx.client.send(e); }
                        },
                        'service.register': {
                            actions: function (ctx, e) { return ctx.client.send(e); }
                        },
                        'service.stop': {
                            actions: function (ctx, e) { return ctx.client.send(e); }
                        },
                        'xstate.event': {
                            actions: function (_, e) {
                                var event = e.event;
                                var scxmlEventObject = JSON.parse(event);
                                var service = serviceMap.get(scxmlEventObject.origin);
                                service === null || service === void 0 ? void 0 : service.send(scxmlEventObject);
                            }
                        },
                        unload: {
                            actions: function (ctx) {
                                ctx.client.send({ type: 'xstate.disconnect' });
                            }
                        },
                        disconnect: 'disconnected'
                    }
                },
                disconnected: {
                    entry: function () {
                        sub.unsubscribe();
                    },
                    type: 'final'
                }
            },
            on: {
                'xstate.inspecting': {
                    target: '.connected',
                    actions: [
                        assign({
                            client: function (_, e) { return e.client; }
                        }),
                        function (ctx) {
                            devTools.services.forEach(function (service) {
                                var _a;
                                (_a = ctx.client) === null || _a === void 0 ? void 0 : _a.send({
                                    type: 'service.register',
                                    machine: stringifyMachine(service.machine, options === null || options === void 0 ? void 0 : options.serialize),
                                    state: stringifyState(service.state || service.initialState, options === null || options === void 0 ? void 0 : options.serialize),
                                    sessionId: service.sessionId
                                });
                            });
                        }
                    ]
                }
            }
        });
    }

    var serviceMap = new Map();
    function createDevTools() {
        var services = new Set();
        var serviceListeners = new Set();
        return {
            services: services,
            register: function (service) {
                services.add(service);
                serviceMap.set(service.sessionId, service);
                serviceListeners.forEach(function (listener) { return listener(service); });
                service.onStop(function () {
                    services.delete(service);
                    serviceMap.delete(service.sessionId);
                });
            },
            unregister: function (service) {
                services.delete(service);
                serviceMap.delete(service.sessionId);
            },
            onRegister: function (listener) {
                serviceListeners.add(listener);
                services.forEach(function (service) { return listener(service); });
                return {
                    unsubscribe: function () {
                        serviceListeners.delete(listener);
                    }
                };
            }
        };
    }
    var defaultInspectorOptions = {
        url: 'https://statecharts.io/inspect',
        iframe: function () {
            return document.querySelector('iframe[data-xstate]');
        },
        devTools: function () {
            var devTools = createDevTools();
            globalThis.__xstate__ = devTools;
            return devTools;
        },
        serialize: undefined
    };
    var getFinalOptions = function (options) {
        var withDefaults = __assign(__assign({}, defaultInspectorOptions), options);
        return __assign(__assign({}, withDefaults), { url: new URL(withDefaults.url), iframe: getLazy(withDefaults.iframe), devTools: getLazy(withDefaults.devTools) });
    };
    var patchedInterpreters = new Set();
    function inspect(options) {
        var _a = getFinalOptions(options), iframe = _a.iframe, url = _a.url, devTools = _a.devTools;
        if (iframe === null) {
            console.warn('No suitable <iframe> found to embed the inspector. Please pass an <iframe> element to `inspect(iframe)` or create an <iframe data-xstate></iframe> element.');
            return undefined;
        }
        var inspectMachine = createInspectMachine(devTools, options);
        var inspectService = interpret(inspectMachine).start();
        var listeners = new Set();
        var sub = inspectService.subscribe(function (state) {
            listeners.forEach(function (listener) { return listener.next(state); });
        });
        var targetWindow;
        var client;
        var messageHandler = function (event) {
            if (typeof event.data === 'object' &&
                event.data !== null &&
                'type' in event.data) {
                if (iframe && !targetWindow) {
                    targetWindow = iframe.contentWindow;
                }
                if (!client) {
                    client = {
                        send: function (e) {
                            targetWindow.postMessage(e, url.origin);
                        }
                    };
                }
                var inspectEvent = __assign(__assign({}, event.data), { client: client });
                inspectService.send(inspectEvent);
            }
        };
        window.addEventListener('message', messageHandler);
        window.addEventListener('unload', function () {
            inspectService.send({ type: 'unload' });
        });
        var stringifyWithSerializer = function (value) {
            return stringify(value, options === null || options === void 0 ? void 0 : options.serialize);
        };
        devTools.onRegister(function (service) {
            var _a;
            var state = service.state || service.initialState;
            inspectService.send({
                type: 'service.register',
                machine: stringifyMachine(service.machine, options === null || options === void 0 ? void 0 : options.serialize),
                state: stringifyState(state, options === null || options === void 0 ? void 0 : options.serialize),
                sessionId: service.sessionId,
                id: service.id,
                parent: (_a = service.parent) === null || _a === void 0 ? void 0 : _a.sessionId
            });
            inspectService.send({
                type: 'service.event',
                event: stringifyWithSerializer(state._event),
                sessionId: service.sessionId
            });
            if (!patchedInterpreters.has(service)) {
                patchedInterpreters.add(service);
                // monkey-patch service.send so that we know when an event was sent
                // to a service *before* it is processed, since other events might occur
                // while the sent one is being processed, which throws the order off
                var originalSend_1 = service.send.bind(service);
                service.send = function inspectSend(event, payload) {
                    inspectService.send({
                        type: 'service.event',
                        event: stringifyWithSerializer(toSCXMLEvent(toEventObject(event, payload))),
                        sessionId: service.sessionId
                    });
                    return originalSend_1(event, payload);
                };
            }
            service.subscribe(function (state) {
                // filter out synchronous notification from within `.start()` call
                // when the `service.state` has not yet been assigned
                if (state === undefined) {
                    return;
                }
                inspectService.send({
                    type: 'service.state',
                    // TODO: investigate usage of structuredClone in browsers if available
                    state: stringifyState(state, options === null || options === void 0 ? void 0 : options.serialize),
                    sessionId: service.sessionId
                });
            });
            service.onStop(function () {
                inspectService.send({
                    type: 'service.stop',
                    sessionId: service.sessionId
                });
            });
        });
        if (iframe) {
            iframe.addEventListener('load', function () {
                targetWindow = iframe.contentWindow;
            });
            iframe.setAttribute('src', String(url));
        }
        else {
            targetWindow = window.open(String(url), 'xstateinspector');
        }
        return {
            send: function (event) {
                inspectService.send(event);
            },
            subscribe: function (next, onError, onComplete) {
                var observer = toObserver(next, onError, onComplete);
                listeners.add(observer);
                observer.next(inspectService.state);
                return {
                    unsubscribe: function () {
                        listeners.delete(observer);
                    }
                };
            },
            disconnect: function () {
                inspectService.send('disconnect');
                window.removeEventListener('message', messageHandler);
                sub.unsubscribe();
            }
        };
    }

    /* src/components/VideoMixer2/Video.svelte generated by Svelte v3.47.0 */
    const file$c = "src/components/VideoMixer2/Video.svelte";

    function add_css$3(target) {
    	append_styles(target, "svelte-1hp1rqg", ".have-to-click-the-video.svelte-1hp1rqg{position:absolute;height:100vh;width:100vw;top:0px;bottom:0px;left:0px;right:0px;border-radius:0px !important;z-index:102;cursor:pointer}video.svelte-1hp1rqg{width:100%;min-width:40vw;border-radius:1em;transition:opacity var(--fade-time) ease;box-shadow:0px 0px 18px -10px rgba(var(--shadow), 0.4)}@media only screen and (max-width: 600px){video.svelte-1hp1rqg{border-radius:1em 1em 0 0}}.highlight.svelte-1hp1rqg{box-shadow:0px 0px 0px 3px rgb(var(--primary))}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlkZW8uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXlIRSx3QkFBd0IsZUFBQyxDQUFBLEFBQ3ZCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxLQUFLLENBQ2IsS0FBSyxDQUFFLEtBQUssQ0FDWixHQUFHLENBQUUsR0FBRyxDQUNSLE1BQU0sQ0FBRSxHQUFHLENBQ1gsSUFBSSxDQUFFLEdBQUcsQ0FDVCxLQUFLLENBQUUsR0FBRyxDQUNWLGFBQWEsQ0FBRSxHQUFHLENBQUMsVUFBVSxDQUM3QixPQUFPLENBQUUsR0FBRyxDQUNaLE1BQU0sQ0FBRSxPQUFPLEFBQ2pCLENBQUEsQUFDQSxLQUFLLGVBQUMsQ0FBQSxBQUNKLEtBQUssQ0FBRSxJQUFJLENBQ1gsU0FBUyxDQUFFLElBQUksQ0FDZixhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsT0FBTyxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsSUFBSSxDQUN6QyxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxBQUN6RCxDQUFBLEFBRUEsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDeEMsS0FBSyxlQUFDLENBQUEsQUFDSixhQUFhLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUM1QixDQUFBLEFBQ0YsQ0FBQSxBQUVBLFVBQVUsZUFBQyxDQUFBLEFBQ1QsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLENBQUMsQUFDakQsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWaWRlby5zdmVsdGUiXX0= */");
    }

    function create_fragment$i(ctx) {
    	let video;
    	let track;
    	let video_src_value;
    	let video_style_value;
    	let video_is_paused = true;
    	let video_updating = false;
    	let video_animationframe;
    	let mounted;
    	let dispose;

    	function video_timeupdate_handler() {
    		cancelAnimationFrame(video_animationframe);

    		if (!video.paused) {
    			video_animationframe = raf(video_timeupdate_handler);
    			video_updating = true;
    		}

    		/*video_timeupdate_handler*/ ctx[15].call(video);
    	}

    	const block = {
    		c: function create() {
    			video = element("video");
    			track = element("track");
    			attr_dev(track, "kind", "captions");
    			add_location(track, file$c, 99, 2, 3170);
    			if (!src_url_equal(video.src, video_src_value = /*src*/ ctx[2])) attr_dev(video, "src", video_src_value);
    			video.muted = /*$muted*/ ctx[6];
    			attr_dev(video, "style", video_style_value = `${/*paused*/ ctx[3] ? "opacity: 0" : "opacity: 100"};`);
    			attr_dev(video, "class", "svelte-1hp1rqg");
    			toggle_class(video, "have-to-click-the-video", /*firstClickRequested*/ ctx[4]);
    			toggle_class(video, "highlight", /*isTalking*/ ctx[0]);
    			add_location(video, file$c, 83, 0, 2808);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    			append_dev(video, track);
    			/*video_binding*/ ctx[13](video);

    			if (!mounted) {
    				dispose = [
    					listen_dev(video, "play", /*video_play_pause_handler*/ ctx[14]),
    					listen_dev(video, "pause", /*video_play_pause_handler*/ ctx[14]),
    					listen_dev(video, "timeupdate", video_timeupdate_handler),
    					listen_dev(video, "click", /*click_handler*/ ctx[16], { once: true }, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*src*/ 4 && !src_url_equal(video.src, video_src_value = /*src*/ ctx[2])) {
    				attr_dev(video, "src", video_src_value);
    			}

    			if (dirty & /*$muted*/ 64) {
    				prop_dev(video, "muted", /*$muted*/ ctx[6]);
    			}

    			if (dirty & /*paused*/ 8 && video_style_value !== (video_style_value = `${/*paused*/ ctx[3] ? "opacity: 0" : "opacity: 100"};`)) {
    				attr_dev(video, "style", video_style_value);
    			}

    			if (dirty & /*paused*/ 8 && video_is_paused !== (video_is_paused = /*paused*/ ctx[3])) {
    				video[video_is_paused ? "pause" : "play"]();
    			}

    			if (!video_updating && dirty & /*currentTime*/ 2 && !isNaN(/*currentTime*/ ctx[1])) {
    				video.currentTime = /*currentTime*/ ctx[1];
    			}

    			video_updating = false;

    			if (dirty & /*firstClickRequested*/ 16) {
    				toggle_class(video, "have-to-click-the-video", /*firstClickRequested*/ ctx[4]);
    			}

    			if (dirty & /*isTalking*/ 1) {
    				toggle_class(video, "highlight", /*isTalking*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    			/*video_binding*/ ctx[13](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $muted;
    	validate_store(muted, 'muted');
    	component_subscribe($$self, muted, $$value => $$invalidate(6, $muted = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Video', slots, []);
    	let { mimeCodec } = $$props;
    	let { isTalking = false } = $$props;
    	let src = "";
    	let paused = true;
    	let firstClickRequested = true;
    	let mediaSource;
    	let sourceBuffer;

    	// the queue to manage pending buffers to be appended
    	const bufferQueue = [];

    	// flag to debounce the video ending
    	let ready = false;

    	const dispatch = createEventDispatcher();

    	const appendBuffer = buffer => {
    		if (sourceBuffer.updating) {
    			bufferQueue.push(buffer);
    		} else {
    			sourceBuffer.appendBuffer(buffer);
    		}
    	};

    	let currentTime;
    	let bufferEndTime;
    	let videoRef;

    	const skipTalkingVideo = () => {
    		$$invalidate(5, videoRef.currentTime = bufferEndTime - 0.2, videoRef);
    	};

    	onMount(() => {
    		if ("MediaSource" in window && MediaSource.isTypeSupported(mimeCodec)) {
    			mediaSource = new MediaSource();
    			$$invalidate(2, src = URL.createObjectURL(mediaSource)); //create BLOB URL

    			mediaSource.addEventListener("sourceopen", () => {
    				// media source is ready to take buffers
    				// don't need the URL anymore
    				URL.revokeObjectURL(src); // not sure if we should do it

    				// set codec
    				$$invalidate(11, sourceBuffer = mediaSource.addSourceBuffer(mimeCodec));

    				// play buffer in appended order
    				$$invalidate(11, sourceBuffer.mode = "sequence", sourceBuffer);

    				// step
    				// function step() {
    				//   if (videoRef.readyState === (2 || 3)) {
    				//     dispatch("ending");
    				//   }
    				//   window.requestAnimationFrame(step);
    				// }
    				// window.requestAnimationFrame(step);
    				// detect that the buffer is ready to take frames and add pending buffers from queue
    				$$invalidate(
    					11,
    					sourceBuffer.onupdateend = () => {
    						bufferEndTime = sourceBuffer?.buffered.length && sourceBuffer?.buffered.end(sourceBuffer.buffered.length - 1);

    						// clear out the ready state
    						$$invalidate(12, ready = false);

    						// if buffer in queue, add it
    						if (bufferQueue.length) {
    							const buffer = bufferQueue.shift();
    							sourceBuffer.appendBuffer(buffer);
    						}
    					},
    					sourceBuffer
    				);
    			});
    		} else {
    			dispatch("error", "there is no MediaSource Extensions");
    		}
    	});

    	const writable_props = ['mimeCodec', 'isTalking'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Video> was created with unknown prop '${key}'`);
    	});

    	function video_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			videoRef = $$value;
    			$$invalidate(5, videoRef);
    		});
    	}

    	function video_play_pause_handler() {
    		paused = this.paused;
    		$$invalidate(3, paused);
    	}

    	function video_timeupdate_handler() {
    		currentTime = this.currentTime;
    		$$invalidate(1, currentTime);
    	}

    	const click_handler = () => {
    		$$invalidate(4, firstClickRequested = false);
    		dispatch("firstClick");
    		set_store_value(muted, $muted = false, $muted);
    		$$invalidate(3, paused = false);
    	};

    	$$self.$$set = $$props => {
    		if ('mimeCodec' in $$props) $$invalidate(8, mimeCodec = $$props.mimeCodec);
    		if ('isTalking' in $$props) $$invalidate(0, isTalking = $$props.isTalking);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		muted,
    		mimeCodec,
    		isTalking,
    		src,
    		paused,
    		firstClickRequested,
    		mediaSource,
    		sourceBuffer,
    		bufferQueue,
    		ready,
    		dispatch,
    		appendBuffer,
    		currentTime,
    		bufferEndTime,
    		videoRef,
    		skipTalkingVideo,
    		$muted
    	});

    	$$self.$inject_state = $$props => {
    		if ('mimeCodec' in $$props) $$invalidate(8, mimeCodec = $$props.mimeCodec);
    		if ('isTalking' in $$props) $$invalidate(0, isTalking = $$props.isTalking);
    		if ('src' in $$props) $$invalidate(2, src = $$props.src);
    		if ('paused' in $$props) $$invalidate(3, paused = $$props.paused);
    		if ('firstClickRequested' in $$props) $$invalidate(4, firstClickRequested = $$props.firstClickRequested);
    		if ('mediaSource' in $$props) mediaSource = $$props.mediaSource;
    		if ('sourceBuffer' in $$props) $$invalidate(11, sourceBuffer = $$props.sourceBuffer);
    		if ('ready' in $$props) $$invalidate(12, ready = $$props.ready);
    		if ('currentTime' in $$props) $$invalidate(1, currentTime = $$props.currentTime);
    		if ('bufferEndTime' in $$props) bufferEndTime = $$props.bufferEndTime;
    		if ('videoRef' in $$props) $$invalidate(5, videoRef = $$props.videoRef);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*ready, sourceBuffer, currentTime*/ 6146) {
    			// when video is ending, send the `ending` event
    			{
    				if (!ready) {
    					$$invalidate(12, ready = sourceBuffer?.buffered.length && currentTime >= sourceBuffer?.buffered.end(sourceBuffer.buffered.length - 1) - 2 / 25);

    					if (ready) {
    						dispatch("ending");
    						$$invalidate(0, isTalking = false);
    					}
    				}
    			}
    		}
    	};

    	return [
    		isTalking,
    		currentTime,
    		src,
    		paused,
    		firstClickRequested,
    		videoRef,
    		$muted,
    		dispatch,
    		mimeCodec,
    		appendBuffer,
    		skipTalkingVideo,
    		sourceBuffer,
    		ready,
    		video_binding,
    		video_play_pause_handler,
    		video_timeupdate_handler,
    		click_handler
    	];
    }

    class Video extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$e,
    			create_fragment$i,
    			safe_not_equal,
    			{
    				mimeCodec: 8,
    				isTalking: 0,
    				appendBuffer: 9,
    				skipTalkingVideo: 10
    			},
    			add_css$3
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Video",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*mimeCodec*/ ctx[8] === undefined && !('mimeCodec' in props)) {
    			console.warn("<Video> was created without expected prop 'mimeCodec'");
    		}
    	}

    	get mimeCodec() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mimeCodec(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isTalking() {
    		throw new Error("<Video>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isTalking(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get appendBuffer() {
    		return this.$$.ctx[9];
    	}

    	set appendBuffer(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skipTalkingVideo() {
    		return this.$$.ctx[10];
    	}

    	set skipTalkingVideo(value) {
    		throw new Error("<Video>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const INITIAL_DISTRACTION_TIME_MS = 5000;
    const RANDOM_DISTRACTION_TIME_MS = 10000;
    const INITIAL_DISTRACTION_EXIT_TIME_MS = 10000;
    const RANDOM_DISTRACTION_EXIT_TIME_MS = 20000;
    const randomTimeout = (context) => new Promise((resolve) => {
        const time = context.initialRandomTimeout +
            Math.random() * context.randomTimeoutDuration;
        let timeout = setTimeout(() => {
            timeout = null;
            resolve("TIMEOUT_EXPIRED");
        }, time);
        return () => {
            if (timeout != null) {
                clearTimeout(timeout);
            }
        };
    });
    // This machine is completely decoupled from Svelte
    const videoMixerMachine = createMachine({
        schema: {
            events: {},
            context: {},
        },
        id: "videomixer",
        context: {
            playDistracted: false,
            playInterested: false,
            playThinking: false,
            playWelcome: false,
            playWelcomeBack: false,
            startTalking: false,
            randomTimeoutDuration: RANDOM_DISTRACTION_TIME_MS,
            initialRandomTimeout: INITIAL_DISTRACTION_TIME_MS,
            ended: false,
            // sentiment: "neutral",
        },
        initial: "loading",
        on: {
            SKIP_TO_TALKING_VIDEO: "#videomixer.talking",
            VIDEO_SYNTH_ERROR: "#videomixer.waiting",
        },
        states: {
            loading: {
                entry: "load_all",
                exit: "append_init",
                on: {
                    CONTENT_LOADED: [
                        {
                            target: "#videomixer.talking",
                            cond: (context) => context.startTalking,
                        },
                        {
                            target: "welcome_back",
                            // target: "waiting",
                            cond: (context, event) => !event.newUser && context.playWelcomeBack,
                        },
                        {
                            target: "welcome",
                            cond: (context, event) => event.newUser && context.playWelcome,
                        },
                        {
                            target: "waiting",
                            cond: (context) => !context.playWelcome && !context.playWelcomeBack,
                        },
                    ],
                    SET_TALKING_VIDEO: {
                        actions: (context) => {
                            context.startTalking = true;
                        },
                    },
                },
            },
            welcome: {
                entry: "append_welcome",
                on: { VIDEO_ENDING: "waiting" },
            },
            welcome_back: {
                entry: "append_welcome_back",
                on: { VIDEO_ENDING: "waiting" },
            },
            waiting: {
                entry: "enable_chat",
                initial: "idling",
                on: {
                    PROCESSING: ".interested.processing",
                    STARTED_TYPING: {
                        target: "waiting.waiting_outro",
                        cond: (context) => context.playInterested,
                    },
                },
                states: {
                    waiting_outro: {
                        on: {
                            VIDEO_ENDING: { target: "interested" },
                        },
                    },
                    idling: {
                        states: {
                            idle_outro: {
                                on: {
                                    VIDEO_ENDING: "#videomixer.waiting.distracted",
                                },
                            },
                        },
                        invoke: {
                            id: "randomTimeoutDistraction",
                            src: randomTimeout,
                        },
                        entry: [
                            assign({
                                randomTimeoutDuration: RANDOM_DISTRACTION_TIME_MS,
                                initialRandomTimeout: INITIAL_DISTRACTION_TIME_MS,
                            }),
                            "append_next_idle",
                        ],
                        on: {
                            VIDEO_ENDING: { actions: "append_next_idle" },
                            TIMEOUT_EXPIRED: [
                                {
                                    target: "#videomixer.waiting.idling.idle_outro",
                                    cond: (context) => context.playDistracted,
                                },
                            ],
                        },
                    },
                    distracted: {
                        states: {
                            distracted_outro: {
                                entry: "append_distracted_outro",
                                on: {
                                    VIDEO_ENDING: "#videomixer.waiting.idling",
                                },
                            },
                        },
                        invoke: {
                            id: "randomTimeoutDistractionExit",
                            src: randomTimeout,
                        },
                        entry: [
                            assign({
                                randomTimeoutDuration: RANDOM_DISTRACTION_EXIT_TIME_MS,
                                initialRandomTimeout: INITIAL_DISTRACTION_EXIT_TIME_MS,
                            }),
                            "append_distracted_intro",
                        ],
                        on: {
                            VIDEO_ENDING: { actions: "append_next_distracted" },
                            TIMEOUT_EXPIRED: ".distracted_outro",
                        },
                    },
                    interested: {
                        initial: "interested",
                        entry: "append_interested_intro",
                        on: {
                            VIDEO_ENDING: { actions: "append_next_interested" },
                            STARTED_TYPING: {},
                        },
                        states: {
                            interested: {
                                on: {
                                    STOPPED_TYPING: "leaving_to_idle",
                                },
                            },
                            processing: {
                                entry: "disable_user_input",
                                on: {
                                    START_THINKING: {
                                        target: "leaving_to_thinking",
                                        cond: (context) => context.playThinking,
                                    },
                                    SET_TALKING_VIDEO: {
                                        target: "leaving_to_talking",
                                    },
                                },
                            },
                            leaving_to_talking: {
                                entry: "append_interested_outro",
                                on: {
                                    VIDEO_ENDING: "#videomixer.talking",
                                },
                            },
                            leaving_to_thinking: {
                                entry: "append_interested_outro",
                                on: {
                                    VIDEO_ENDING: "#videomixer.thinking",
                                    SET_TALKING_VIDEO: {
                                        target: "leaving_to_talking",
                                    },
                                },
                            },
                            leaving_to_idle: {
                                entry: "append_interested_outro",
                                on: {
                                    VIDEO_ENDING: "#videomixer.waiting",
                                    STARTED_TYPING: "#videomixer.waiting.interested",
                                },
                            },
                        },
                    },
                },
            },
            thinking: {
                entry: "append_thinking_intro",
                states: {
                    thinking_outro: {
                        entry: "append_thinking_outro",
                        on: {
                            VIDEO_ENDING: "#videomixer.talking",
                        },
                    },
                },
                on: {
                    VIDEO_ENDING: { actions: "append_next_thinking" },
                    SET_TALKING_VIDEO: { target: ".thinking_outro" },
                },
            },
            talking: {
                entry: "append_talking_video",
                exit: "handle_talking_video_end",
                on: {
                    SKIP: {
                        target: "waiting",
                        actions: "seek_video_to_end",
                    },
                    VIDEO_ENDING: [
                        {
                            target: "waiting",
                            cond: (event) => !event.ended,
                        },
                        {
                            target: "end",
                            cond: (event) => event.ended,
                            actions: "end",
                        },
                    ],
                },
            },
            end: {
                type: "final",
            },
            error: {
                type: "final",
            },
        },
    });

    const isDevelopment = location.hostname === ("localhost" );

    /* src/components/VideoMixer2/MachineWrapper.svelte generated by Svelte v3.47.0 */

    const { Object: Object_1$1, console: console_1$2 } = globals;

    // (224:0) {#if !!mimeCodec}
    function create_if_block$6(ctx) {
    	let video;
    	let updating_isTalking;
    	let current;

    	function video_isTalking_binding(value) {
    		/*video_isTalking_binding*/ ctx[17](value);
    	}

    	let video_props = { mimeCodec: /*mimeCodec*/ ctx[1] };

    	if (/*isTalking*/ ctx[3] !== void 0) {
    		video_props.isTalking = /*isTalking*/ ctx[3];
    	}

    	video = new Video({ props: video_props, $$inline: true });
    	/*video_binding*/ ctx[16](video);
    	binding_callbacks.push(() => bind(video, 'isTalking', video_isTalking_binding));
    	video.$on("firstClick", /*firstClick_handler*/ ctx[18]);
    	video.$on("ending", /*ending_handler*/ ctx[19]);

    	const block = {
    		c: function create() {
    			create_component(video.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(video, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const video_changes = {};
    			if (dirty & /*mimeCodec*/ 2) video_changes.mimeCodec = /*mimeCodec*/ ctx[1];

    			if (!updating_isTalking && dirty & /*isTalking*/ 8) {
    				updating_isTalking = true;
    				video_changes.isTalking = /*isTalking*/ ctx[3];
    				add_flush_callback(() => updating_isTalking = false);
    			}

    			video.$set(video_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(video.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(video.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*video_binding*/ ctx[16](null);
    			destroy_component(video, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(224:0) {#if !!mimeCodec}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !!/*mimeCodec*/ ctx[1] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!!/*mimeCodec*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*mimeCodec*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $disableChatInput;
    	validate_store(disableChatInput, 'disableChatInput');
    	component_subscribe($$self, disableChatInput, $$value => $$invalidate(24, $disableChatInput = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MachineWrapper', slots, []);
    	const dispatch = createEventDispatcher();
    	let { new_user = false } = $$props;
    	let { video_config_file } = $$props;

    	//context of machine
    	const playStates = {
    		distracted: { play: false },
    		interested: { play: false },
    		thinking: { play: false },
    		welcome: { play: false },
    		welcomeBack: { play: false }
    	};

    	let video_library = {};
    	let video_index = {};
    	let mimeCodec;
    	let video_element;
    	let current_talking_video;
    	let videoMixerService = undefined;
    	let isTalking = false;

    	const attach_welcome_video = () => {
    		disableChat();

    		videoMixerService.send({
    			type: "CONTENT_LOADED",
    			newUser: new_user
    		});

    		dispatch("clicked");
    	};

    	const process = () => {
    		videoMixerService.send({ type: "PROCESSING" });
    	};

    	const started_typing = () => {
    		videoMixerService.send({ type: "STARTED_TYPING" });
    	};

    	const stopped_typing = () => {
    		videoMixerService.send({ type: "STOPPED_TYPING" });
    	};

    	const video_synth_error = () => {
    		videoMixerService.send({ type: "VIDEO_SYNTH_ERROR" });
    		enableleChat();
    	};

    	// fetch buffer of URL its cool
    	const fetchBuffer = async url => {
    		const response = await fetch(url);
    		if (response.status != 200) throw "Error when loading a video";
    		return await response.arrayBuffer();
    	};

    	const disableChat = () => {
    		set_store_value(disableChatInput, $disableChatInput = true, $disableChatInput);
    	};

    	const enableleChat = () => {
    		set_store_value(disableChatInput, $disableChatInput = false, $disableChatInput);
    	};

    	const skipTalkingVideo = () => {
    		video_element.skipTalkingVideo();
    		videoMixerService.send({ type: "SKIP" });
    	};

    	// Load all Buffers from video_config_file
    	const load_all_from_json = async video_config_file => {
    		video_index = video_config_file.clips;

    		try {
    			$$invalidate(1, mimeCodec = 'video/mp4; codecs="avc1.64001F, mp4a.40.2"');
    			video_library["init"] = await fetchBuffer(video_config_file.init);

    			for (const element of Object.keys(video_index)) {
    				video_library[element] = {};

    				for (const key in video_index[element]) {
    					if (video_index[element][key] instanceof Array) {
    						//set context of segment to true if it exists in JSON
    						if (Object.prototype.hasOwnProperty.call(playStates, element)) {
    							playStates[element].play = true;
    						}

    						video_library[element][key] = [];

    						for (const i in video_index[element][key]) {
    							const video = video_index[element][key][i];
    							const buffer = await fetchBuffer(video); //video -> output2.m4s
    							video_library[element][key].push(buffer);
    						}
    					} else {
    						const video = video_index[element][key];
    						const buffer = await fetchBuffer(video);
    						video_library[element][key] = buffer;
    					}
    				}
    			}

    			//fetch welcome
    			dispatch("content_loaded");
    		} catch(e) {
    			console.error("could not load segments", e);
    			return;
    		}
    	};

    	isDevelopment && inspect({
    		// options
    		// url: 'https://statecharts.io/inspect', // (default)
    		iframe: false, // open in new window
    		
    	});

    	const setThinking = () => {
    		videoMixerService.send({ type: "START_THINKING" });
    	};

    	// in case machine is not defined at the beggining, we send again once it is
    	let saveForLater;

    	const setTalkingVideo = (talking_video_buffer, replay = false) => {
    		current_talking_video = talking_video_buffer;

    		try {
    			videoMixerService
    			? videoMixerService.send({
    					type: replay ? "SKIP_TO_TALKING_VIDEO" : "SET_TALKING_VIDEO"
    				})
    			: $$invalidate(15, saveForLater = current_talking_video);
    		} catch {
    			console.error("Error on setTalkingVideo");
    		}
    	};

    	onMount(async () => {
    		await load_all_from_json(video_config_file);

    		const appendRandomSegment = state => {
    			const items = video_library[state]["loop"];
    			const index = Math.floor(Math.random() * items.length);
    			video_element.appendBuffer(video_library[state]["loop"][index]);
    		};

    		const machine = videoMixerMachine.withConfig({
    			actions: {
    				load_all: () => {
    					machine.context.playDistracted = playStates.distracted.play;
    					machine.context.playInterested = playStates.interested.play;
    					machine.context.playThinking = playStates.thinking.play;
    					machine.context.playWelcome = playStates.thinking.play;
    					machine.context.playWelcomeBack = playStates.thinking.play;
    				},
    				end: () => null,
    				enable_chat: () => {
    					enableleChat();
    				},
    				handle_talking_video_end: () => {
    					enableleChat();
    					dispatch("talking_end");
    					$$invalidate(3, isTalking = false);
    				},
    				disable_user_input: () => {
    					disableChat();
    				},
    				append_init: () => {
    					video_element.appendBuffer(video_library["init"]);
    				},
    				// play single segment
    				append_welcome: () => {
    					video_element.appendBuffer(video_library["welcome"]["loop"][0]);
    				},
    				append_welcome_back: () => {
    					video_element.appendBuffer(video_library["welcome_back"]["loop"][0]);
    				},
    				append_talking_video: () => {
    					dispatch("talkingVideoAppended");
    					video_element.appendBuffer(current_talking_video);
    					$$invalidate(3, isTalking = true);
    				},
    				append_next_idle: () => {
    					appendRandomSegment("idling");
    				},
    				// play intro, loop inner segments, play outro
    				append_next_distracted: () => {
    					const items = video_library["distracted"]["loop"];
    					const index = Math.floor(Math.random() * items.length);
    					video_element.appendBuffer(video_library["distracted"]["loop"][index]);
    				},
    				append_next_interested: () => {
    					appendRandomSegment(playStates.interested.play ? "interested" : "idling");
    				},
    				append_next_thinking: () => {
    					const items = video_library["thinking"]["loop"];
    					const index = Math.floor(Math.random() * items.length);
    					video_element.appendBuffer(video_library["thinking"]["loop"][index]);
    				},
    				append_distracted_intro: () => {
    					video_element.appendBuffer(video_library["distracted"]["intro"]);
    				},
    				append_distracted_outro: () => {
    					video_element.appendBuffer(video_library["distracted"]["outro"]);
    				},
    				append_interested_intro: () => {
    					//just append the interested outro if there are interested segments in json
    					if (playStates.interested.play) {
    						video_element.appendBuffer(video_library["interested"]["intro"]);
    					}
    				},
    				append_interested_outro: () => {
    					video_element.appendBuffer(video_library["interested"]["outro"]);
    				},
    				append_thinking_intro: () => {
    					video_element.appendBuffer(video_library["thinking"]["intro"]);
    				},
    				append_thinking_outro: () => {
    					video_element.appendBuffer(video_library["thinking"]["outro"]);
    				},
    				seek_video_to_end: () => {
    					video_element.skipTalkingVideo();
    				}
    			}
    		});

    		$$invalidate(0, videoMixerService = interpret(machine, { devTools: true }).start());
    		dispatch("machine_ready");
    	});

    	const writable_props = ['new_user', 'video_config_file'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<MachineWrapper> was created with unknown prop '${key}'`);
    	});

    	function video_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			video_element = $$value;
    			$$invalidate(2, video_element);
    		});
    	}

    	function video_isTalking_binding(value) {
    		isTalking = value;
    		$$invalidate(3, isTalking);
    	}

    	const firstClick_handler = () => dispatch("firstClick");

    	const ending_handler = () => {
    		videoMixerService.send({ type: "VIDEO_ENDING" });
    		dispatch("ending");
    	};

    	$$self.$$set = $$props => {
    		if ('new_user' in $$props) $$invalidate(5, new_user = $$props.new_user);
    		if ('video_config_file' in $$props) $$invalidate(6, video_config_file = $$props.video_config_file);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		interpret,
    		inspect,
    		Video,
    		videoMixerMachine,
    		disableChatInput,
    		isDevelopment,
    		dispatch,
    		new_user,
    		video_config_file,
    		playStates,
    		video_library,
    		video_index,
    		mimeCodec,
    		video_element,
    		current_talking_video,
    		videoMixerService,
    		isTalking,
    		attach_welcome_video,
    		process,
    		started_typing,
    		stopped_typing,
    		video_synth_error,
    		fetchBuffer,
    		disableChat,
    		enableleChat,
    		skipTalkingVideo,
    		load_all_from_json,
    		setThinking,
    		saveForLater,
    		setTalkingVideo,
    		$disableChatInput
    	});

    	$$self.$inject_state = $$props => {
    		if ('new_user' in $$props) $$invalidate(5, new_user = $$props.new_user);
    		if ('video_config_file' in $$props) $$invalidate(6, video_config_file = $$props.video_config_file);
    		if ('video_library' in $$props) video_library = $$props.video_library;
    		if ('video_index' in $$props) video_index = $$props.video_index;
    		if ('mimeCodec' in $$props) $$invalidate(1, mimeCodec = $$props.mimeCodec);
    		if ('video_element' in $$props) $$invalidate(2, video_element = $$props.video_element);
    		if ('current_talking_video' in $$props) current_talking_video = $$props.current_talking_video;
    		if ('videoMixerService' in $$props) $$invalidate(0, videoMixerService = $$props.videoMixerService);
    		if ('isTalking' in $$props) $$invalidate(3, isTalking = $$props.isTalking);
    		if ('saveForLater' in $$props) $$invalidate(15, saveForLater = $$props.saveForLater);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*videoMixerService, saveForLater*/ 32769) {
    			if (videoMixerService && saveForLater) setTalkingVideo(saveForLater);
    		}
    	};

    	return [
    		videoMixerService,
    		mimeCodec,
    		video_element,
    		isTalking,
    		dispatch,
    		new_user,
    		video_config_file,
    		attach_welcome_video,
    		process,
    		started_typing,
    		stopped_typing,
    		video_synth_error,
    		skipTalkingVideo,
    		setThinking,
    		setTalkingVideo,
    		saveForLater,
    		video_binding,
    		video_isTalking_binding,
    		firstClick_handler,
    		ending_handler
    	];
    }

    class MachineWrapper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$d, create_fragment$h, safe_not_equal, {
    			new_user: 5,
    			video_config_file: 6,
    			attach_welcome_video: 7,
    			process: 8,
    			started_typing: 9,
    			stopped_typing: 10,
    			video_synth_error: 11,
    			skipTalkingVideo: 12,
    			setThinking: 13,
    			setTalkingVideo: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MachineWrapper",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*video_config_file*/ ctx[6] === undefined && !('video_config_file' in props)) {
    			console_1$2.warn("<MachineWrapper> was created without expected prop 'video_config_file'");
    		}
    	}

    	get new_user() {
    		throw new Error("<MachineWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set new_user(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get video_config_file() {
    		throw new Error("<MachineWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set video_config_file(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get attach_welcome_video() {
    		return this.$$.ctx[7];
    	}

    	set attach_welcome_video(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get process() {
    		return this.$$.ctx[8];
    	}

    	set process(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get started_typing() {
    		return this.$$.ctx[9];
    	}

    	set started_typing(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stopped_typing() {
    		return this.$$.ctx[10];
    	}

    	set stopped_typing(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get video_synth_error() {
    		return this.$$.ctx[11];
    	}

    	set video_synth_error(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skipTalkingVideo() {
    		return this.$$.ctx[12];
    	}

    	set skipTalkingVideo(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setThinking() {
    		return this.$$.ctx[13];
    	}

    	set setThinking(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setTalkingVideo() {
    		return this.$$.ctx[14];
    	}

    	set setTalkingVideo(value) {
    		throw new Error("<MachineWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/VideoMixer2/ConversationManager.svelte generated by Svelte v3.47.0 */

    const { console: console_1$1 } = globals;

    // (86:0) {#if display_loading_screen}
    function create_if_block_1$3(ctx) {
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loading.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(86:0) {#if display_loading_screen}",
    		ctx
    	});

    	return block;
    }

    // (90:0) {#if !!video_config_file}
    function create_if_block$5(ctx) {
    	let videomixer;
    	let updating_skipTalkingVideo;
    	let current;

    	function videomixer_skipTalkingVideo_binding(value) {
    		/*videomixer_skipTalkingVideo_binding*/ ctx[13](value);
    	}

    	let videomixer_props = {
    		video_config_file: /*video_config_file*/ ctx[2],
    		new_user: true
    	};

    	if (/*skipTalkingVideo*/ ctx[0] !== void 0) {
    		videomixer_props.skipTalkingVideo = /*skipTalkingVideo*/ ctx[0];
    	}

    	videomixer = new MachineWrapper({ props: videomixer_props, $$inline: true });
    	/*videomixer_binding*/ ctx[12](videomixer);
    	binding_callbacks.push(() => bind(videomixer, 'skipTalkingVideo', videomixer_skipTalkingVideo_binding));
    	videomixer.$on("firstClick", /*firstClick_handler*/ ctx[14]);
    	videomixer.$on("content_loaded", /*content_loaded_handler*/ ctx[15]);
    	videomixer.$on("talkingVideoAppended", /*displayChatMessage*/ ctx[5]);
    	videomixer.$on("clicked", clicked_handler);
    	videomixer.$on("ending", ending_handler);
    	videomixer.$on("talking_end", /*talking_end_handler*/ ctx[16]);
    	videomixer.$on("machine_ready", /*machine_ready_handler*/ ctx[17]);

    	const block = {
    		c: function create() {
    			create_component(videomixer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(videomixer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videomixer_changes = {};
    			if (dirty & /*video_config_file*/ 4) videomixer_changes.video_config_file = /*video_config_file*/ ctx[2];

    			if (!updating_skipTalkingVideo && dirty & /*skipTalkingVideo*/ 1) {
    				updating_skipTalkingVideo = true;
    				videomixer_changes.skipTalkingVideo = /*skipTalkingVideo*/ ctx[0];
    				add_flush_callback(() => updating_skipTalkingVideo = false);
    			}

    			videomixer.$set(videomixer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videomixer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videomixer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*videomixer_binding*/ ctx[12](null);
    			destroy_component(videomixer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(90:0) {#if !!video_config_file}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*display_loading_screen*/ ctx[3] && create_if_block_1$3(ctx);
    	let if_block1 = !!/*video_config_file*/ ctx[2] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*display_loading_screen*/ ctx[3]) {
    				if (if_block0) {
    					if (dirty & /*display_loading_screen*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!!/*video_config_file*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*video_config_file*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const clicked_handler = () => null;
    const ending_handler = () => null;

    function instance$c($$self, $$props, $$invalidate) {
    	let $backendWriting;
    	let $user_input_value;
    	let $talkingVideoSrc;
    	let $body_data;
    	validate_store(backendWriting, 'backendWriting');
    	component_subscribe($$self, backendWriting, $$value => $$invalidate(21, $backendWriting = $$value));
    	validate_store(user_input_value, 'user_input_value');
    	component_subscribe($$self, user_input_value, $$value => $$invalidate(11, $user_input_value = $$value));
    	validate_store(talkingVideoSrc, 'talkingVideoSrc');
    	component_subscribe($$self, talkingVideoSrc, $$value => $$invalidate(22, $talkingVideoSrc = $$value));
    	validate_store(body_data, 'body_data');
    	component_subscribe($$self, body_data, $$value => $$invalidate(23, $body_data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConversationManager', slots, []);
    	const dispatch = createEventDispatcher();
    	let { skipTalkingVideo = undefined } = $$props;
    	let writingTimeout = null;

    	const on_video_synth_error = () => {
    		video_mixer.video_synth_error();
    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);

    		if (writingTimeout) {
    			clearTimeout(writingTimeout);
    			writingTimeout = null;
    		}

    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);
    	};

    	let video_mixer;

    	//first spin up
    	let video_config_file;

    	// display loading screen
    	let display_loading_screen = true;

    	let last_talkingVideoSrc = "";

    	// Userinput
    	let userInputTimeout = null;

    	onMount(async () => {
    		try {
    			const response = await fetch(`${$body_data.api_base}/api/v1/get_vm2_segments/${$body_data.org_id}/${$body_data.head_id}`);
    			$$invalidate(2, video_config_file = await response.json());
    		} catch(e) {
    			console.error("Catastrophic error: failed to fetch json file");
    		}
    	});

    	const on_enter = () => {
    		// switch to process
    		video_mixer.process();

    		writingTimeout = setTimeout(
    			() => {
    				set_store_value(backendWriting, $backendWriting = true, $backendWriting);
    			},
    			1000
    		);
    	};

    	let saveForLater;

    	const on_video_received = async (replay = false) => {
    		const buffer = await getMedia($talkingVideoSrc);

    		video_mixer
    		? video_mixer.setTalkingVideo(buffer, replay)
    		: $$invalidate(10, saveForLater = buffer);

    		if (userInputTimeout) {
    			clearTimeout(userInputTimeout);
    			set_store_value(user_input_value, $user_input_value = "", $user_input_value);
    			userInputTimeout = null;
    		}

    		last_talkingVideoSrc = $talkingVideoSrc;
    	};

    	const on_cache_check = cached => {
    		!cached && video_mixer.setThinking();
    	};

    	const on_typing = () => {
    		if (video_mixer) {
    			video_mixer.started_typing();

    			if (userInputTimeout) {
    				clearTimeout(userInputTimeout);
    			}

    			userInputTimeout = setTimeout(
    				() => {
    					video_mixer.stopped_typing();
    					userInputTimeout = null;
    				},
    				4000 + Math.random() * 1000
    			);
    		}
    	};

    	const displayChatMessage = () => {
    		dispatch("displayChatMessage", last_talkingVideoSrc);
    		set_store_value(backendWriting, $backendWriting = false, $backendWriting);
    	};

    	const writable_props = ['skipTalkingVideo'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<ConversationManager> was created with unknown prop '${key}'`);
    	});

    	function videomixer_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			video_mixer = $$value;
    			$$invalidate(1, video_mixer);
    		});
    	}

    	function videomixer_skipTalkingVideo_binding(value) {
    		skipTalkingVideo = value;
    		$$invalidate(0, skipTalkingVideo);
    	}

    	const firstClick_handler = () => {
    		dispatch("firstClick");
    	};

    	const content_loaded_handler = () => {
    		$$invalidate(3, display_loading_screen = false);
    	};

    	const talking_end_handler = () => dispatch("talking_end");

    	const machine_ready_handler = () => {
    		video_mixer.attach_welcome_video();
    		dispatch("machine_ready");
    	};

    	$$self.$$set = $$props => {
    		if ('skipTalkingVideo' in $$props) $$invalidate(0, skipTalkingVideo = $$props.skipTalkingVideo);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		VideoMixer: MachineWrapper,
    		Loading,
    		talkingVideoSrc,
    		user_input_value,
    		backendWriting,
    		body_data,
    		getMedia,
    		dispatch,
    		skipTalkingVideo,
    		writingTimeout,
    		on_video_synth_error,
    		video_mixer,
    		video_config_file,
    		display_loading_screen,
    		last_talkingVideoSrc,
    		userInputTimeout,
    		on_enter,
    		saveForLater,
    		on_video_received,
    		on_cache_check,
    		on_typing,
    		displayChatMessage,
    		$backendWriting,
    		$user_input_value,
    		$talkingVideoSrc,
    		$body_data
    	});

    	$$self.$inject_state = $$props => {
    		if ('skipTalkingVideo' in $$props) $$invalidate(0, skipTalkingVideo = $$props.skipTalkingVideo);
    		if ('writingTimeout' in $$props) writingTimeout = $$props.writingTimeout;
    		if ('video_mixer' in $$props) $$invalidate(1, video_mixer = $$props.video_mixer);
    		if ('video_config_file' in $$props) $$invalidate(2, video_config_file = $$props.video_config_file);
    		if ('display_loading_screen' in $$props) $$invalidate(3, display_loading_screen = $$props.display_loading_screen);
    		if ('last_talkingVideoSrc' in $$props) last_talkingVideoSrc = $$props.last_talkingVideoSrc;
    		if ('userInputTimeout' in $$props) userInputTimeout = $$props.userInputTimeout;
    		if ('saveForLater' in $$props) $$invalidate(10, saveForLater = $$props.saveForLater);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*video_mixer, saveForLater*/ 1026) {
    			if (video_mixer && saveForLater) video_mixer.setTalkingVideo(saveForLater);
    		}

    		if ($$self.$$.dirty & /*$user_input_value*/ 2048) {
    			(on_typing());
    		}
    	};

    	return [
    		skipTalkingVideo,
    		video_mixer,
    		video_config_file,
    		display_loading_screen,
    		dispatch,
    		displayChatMessage,
    		on_video_synth_error,
    		on_enter,
    		on_video_received,
    		on_cache_check,
    		saveForLater,
    		$user_input_value,
    		videomixer_binding,
    		videomixer_skipTalkingVideo_binding,
    		firstClick_handler,
    		content_loaded_handler,
    		talking_end_handler,
    		machine_ready_handler
    	];
    }

    class ConversationManager extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$c, create_fragment$g, safe_not_equal, {
    			skipTalkingVideo: 0,
    			on_video_synth_error: 6,
    			on_enter: 7,
    			on_video_received: 8,
    			on_cache_check: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConversationManager",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get skipTalkingVideo() {
    		throw new Error("<ConversationManager>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set skipTalkingVideo(value) {
    		throw new Error("<ConversationManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_video_synth_error() {
    		return this.$$.ctx[6];
    	}

    	set on_video_synth_error(value) {
    		throw new Error("<ConversationManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_enter() {
    		return this.$$.ctx[7];
    	}

    	set on_enter(value) {
    		throw new Error("<ConversationManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_video_received() {
    		return this.$$.ctx[8];
    	}

    	set on_video_received(value) {
    		throw new Error("<ConversationManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_cache_check() {
    		return this.$$.ctx[9];
    	}

    	set on_cache_check(value) {
    		throw new Error("<ConversationManager>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/VideoMixer2/VideoMixer2.svelte generated by Svelte v3.47.0 */

    // (20:0) <VideoMixerPlaceholder   bind:sessionCount   bind:show_count   bind:name   bind:opmode   bind:start >
    function create_default_slot$3(ctx) {
    	let conversationmanager;
    	let updating_on_video_received;
    	let updating_on_enter;
    	let updating_on_cache_check;
    	let updating_skipTalkingVideo;
    	let updating_on_video_synth_error;
    	let current;

    	function conversationmanager_on_video_received_binding(value) {
    		/*conversationmanager_on_video_received_binding*/ ctx[12](value);
    	}

    	function conversationmanager_on_enter_binding(value) {
    		/*conversationmanager_on_enter_binding*/ ctx[13](value);
    	}

    	function conversationmanager_on_cache_check_binding(value) {
    		/*conversationmanager_on_cache_check_binding*/ ctx[14](value);
    	}

    	function conversationmanager_skipTalkingVideo_binding(value) {
    		/*conversationmanager_skipTalkingVideo_binding*/ ctx[15](value);
    	}

    	function conversationmanager_on_video_synth_error_binding(value) {
    		/*conversationmanager_on_video_synth_error_binding*/ ctx[16](value);
    	}

    	let conversationmanager_props = {};

    	if (/*on_video_received*/ ctx[0] !== void 0) {
    		conversationmanager_props.on_video_received = /*on_video_received*/ ctx[0];
    	}

    	if (/*on_enter*/ ctx[1] !== void 0) {
    		conversationmanager_props.on_enter = /*on_enter*/ ctx[1];
    	}

    	if (/*on_cache_check*/ ctx[2] !== void 0) {
    		conversationmanager_props.on_cache_check = /*on_cache_check*/ ctx[2];
    	}

    	if (/*skipTalkingVideo*/ ctx[3] !== void 0) {
    		conversationmanager_props.skipTalkingVideo = /*skipTalkingVideo*/ ctx[3];
    	}

    	if (/*on_video_synth_error*/ ctx[4] !== void 0) {
    		conversationmanager_props.on_video_synth_error = /*on_video_synth_error*/ ctx[4];
    	}

    	conversationmanager = new ConversationManager({
    			props: conversationmanager_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(conversationmanager, 'on_video_received', conversationmanager_on_video_received_binding));
    	binding_callbacks.push(() => bind(conversationmanager, 'on_enter', conversationmanager_on_enter_binding));
    	binding_callbacks.push(() => bind(conversationmanager, 'on_cache_check', conversationmanager_on_cache_check_binding));
    	binding_callbacks.push(() => bind(conversationmanager, 'skipTalkingVideo', conversationmanager_skipTalkingVideo_binding));
    	binding_callbacks.push(() => bind(conversationmanager, 'on_video_synth_error', conversationmanager_on_video_synth_error_binding));
    	conversationmanager.$on("firstClick", /*firstClick_handler*/ ctx[17]);
    	conversationmanager.$on("machine_ready", /*machine_ready_handler*/ ctx[18]);
    	conversationmanager.$on("displayChatMessage", /*displayChatMessage*/ ctx[11]);
    	conversationmanager.$on("talking_end", /*talking_end_handler*/ ctx[19]);

    	const block = {
    		c: function create() {
    			create_component(conversationmanager.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(conversationmanager, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const conversationmanager_changes = {};

    			if (!updating_on_video_received && dirty & /*on_video_received*/ 1) {
    				updating_on_video_received = true;
    				conversationmanager_changes.on_video_received = /*on_video_received*/ ctx[0];
    				add_flush_callback(() => updating_on_video_received = false);
    			}

    			if (!updating_on_enter && dirty & /*on_enter*/ 2) {
    				updating_on_enter = true;
    				conversationmanager_changes.on_enter = /*on_enter*/ ctx[1];
    				add_flush_callback(() => updating_on_enter = false);
    			}

    			if (!updating_on_cache_check && dirty & /*on_cache_check*/ 4) {
    				updating_on_cache_check = true;
    				conversationmanager_changes.on_cache_check = /*on_cache_check*/ ctx[2];
    				add_flush_callback(() => updating_on_cache_check = false);
    			}

    			if (!updating_skipTalkingVideo && dirty & /*skipTalkingVideo*/ 8) {
    				updating_skipTalkingVideo = true;
    				conversationmanager_changes.skipTalkingVideo = /*skipTalkingVideo*/ ctx[3];
    				add_flush_callback(() => updating_skipTalkingVideo = false);
    			}

    			if (!updating_on_video_synth_error && dirty & /*on_video_synth_error*/ 16) {
    				updating_on_video_synth_error = true;
    				conversationmanager_changes.on_video_synth_error = /*on_video_synth_error*/ ctx[4];
    				add_flush_callback(() => updating_on_video_synth_error = false);
    			}

    			conversationmanager.$set(conversationmanager_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(conversationmanager.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(conversationmanager.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(conversationmanager, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(20:0) <VideoMixerPlaceholder   bind:sessionCount   bind:show_count   bind:name   bind:opmode   bind:start >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let videomixerplaceholder;
    	let updating_sessionCount;
    	let updating_show_count;
    	let updating_name;
    	let updating_opmode;
    	let updating_start;
    	let current;

    	function videomixerplaceholder_sessionCount_binding(value) {
    		/*videomixerplaceholder_sessionCount_binding*/ ctx[20](value);
    	}

    	function videomixerplaceholder_show_count_binding(value) {
    		/*videomixerplaceholder_show_count_binding*/ ctx[21](value);
    	}

    	function videomixerplaceholder_name_binding(value) {
    		/*videomixerplaceholder_name_binding*/ ctx[22](value);
    	}

    	function videomixerplaceholder_opmode_binding(value) {
    		/*videomixerplaceholder_opmode_binding*/ ctx[23](value);
    	}

    	function videomixerplaceholder_start_binding(value) {
    		/*videomixerplaceholder_start_binding*/ ctx[24](value);
    	}

    	let videomixerplaceholder_props = {
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};

    	if (/*sessionCount*/ ctx[5] !== void 0) {
    		videomixerplaceholder_props.sessionCount = /*sessionCount*/ ctx[5];
    	}

    	if (/*show_count*/ ctx[6] !== void 0) {
    		videomixerplaceholder_props.show_count = /*show_count*/ ctx[6];
    	}

    	if (/*name*/ ctx[7] !== void 0) {
    		videomixerplaceholder_props.name = /*name*/ ctx[7];
    	}

    	if (/*opmode*/ ctx[8] !== void 0) {
    		videomixerplaceholder_props.opmode = /*opmode*/ ctx[8];
    	}

    	if (/*start*/ ctx[9] !== void 0) {
    		videomixerplaceholder_props.start = /*start*/ ctx[9];
    	}

    	videomixerplaceholder = new VideoMixerPlaceholder({
    			props: videomixerplaceholder_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(videomixerplaceholder, 'sessionCount', videomixerplaceholder_sessionCount_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'show_count', videomixerplaceholder_show_count_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'name', videomixerplaceholder_name_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'opmode', videomixerplaceholder_opmode_binding));
    	binding_callbacks.push(() => bind(videomixerplaceholder, 'start', videomixerplaceholder_start_binding));

    	const block = {
    		c: function create() {
    			create_component(videomixerplaceholder.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(videomixerplaceholder, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const videomixerplaceholder_changes = {};

    			if (dirty & /*$$scope, on_video_received, on_enter, on_cache_check, skipTalkingVideo, on_video_synth_error, start*/ 33554975) {
    				videomixerplaceholder_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_sessionCount && dirty & /*sessionCount*/ 32) {
    				updating_sessionCount = true;
    				videomixerplaceholder_changes.sessionCount = /*sessionCount*/ ctx[5];
    				add_flush_callback(() => updating_sessionCount = false);
    			}

    			if (!updating_show_count && dirty & /*show_count*/ 64) {
    				updating_show_count = true;
    				videomixerplaceholder_changes.show_count = /*show_count*/ ctx[6];
    				add_flush_callback(() => updating_show_count = false);
    			}

    			if (!updating_name && dirty & /*name*/ 128) {
    				updating_name = true;
    				videomixerplaceholder_changes.name = /*name*/ ctx[7];
    				add_flush_callback(() => updating_name = false);
    			}

    			if (!updating_opmode && dirty & /*opmode*/ 256) {
    				updating_opmode = true;
    				videomixerplaceholder_changes.opmode = /*opmode*/ ctx[8];
    				add_flush_callback(() => updating_opmode = false);
    			}

    			if (!updating_start && dirty & /*start*/ 512) {
    				updating_start = true;
    				videomixerplaceholder_changes.start = /*start*/ ctx[9];
    				add_flush_callback(() => updating_start = false);
    			}

    			videomixerplaceholder.$set(videomixerplaceholder_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videomixerplaceholder.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videomixerplaceholder.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(videomixerplaceholder, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('VideoMixer2', slots, []);
    	const dispatch = createEventDispatcher();
    	let { on_video_received = undefined } = $$props;
    	let { on_enter = undefined } = $$props;
    	let { on_cache_check = undefined } = $$props;
    	let { skipTalkingVideo = undefined } = $$props;
    	let { on_video_synth_error = undefined } = $$props;
    	let { sessionCount = 0 } = $$props;
    	let { show_count = false } = $$props;
    	let { name } = $$props;
    	let { opmode = "ttt" } = $$props;
    	let start = true;

    	const displayChatMessage = e => {
    		dispatch("displayChatMessage", e.detail);
    	};

    	const writable_props = [
    		'on_video_received',
    		'on_enter',
    		'on_cache_check',
    		'skipTalkingVideo',
    		'on_video_synth_error',
    		'sessionCount',
    		'show_count',
    		'name',
    		'opmode'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoMixer2> was created with unknown prop '${key}'`);
    	});

    	function conversationmanager_on_video_received_binding(value) {
    		on_video_received = value;
    		$$invalidate(0, on_video_received);
    	}

    	function conversationmanager_on_enter_binding(value) {
    		on_enter = value;
    		$$invalidate(1, on_enter);
    	}

    	function conversationmanager_on_cache_check_binding(value) {
    		on_cache_check = value;
    		$$invalidate(2, on_cache_check);
    	}

    	function conversationmanager_skipTalkingVideo_binding(value) {
    		skipTalkingVideo = value;
    		$$invalidate(3, skipTalkingVideo);
    	}

    	function conversationmanager_on_video_synth_error_binding(value) {
    		on_video_synth_error = value;
    		$$invalidate(4, on_video_synth_error);
    	}

    	const firstClick_handler = () => {
    		$$invalidate(9, start = false);
    	};

    	const machine_ready_handler = () => {
    		dispatch("ready");
    	};

    	const talking_end_handler = () => dispatch("talking_end");

    	function videomixerplaceholder_sessionCount_binding(value) {
    		sessionCount = value;
    		$$invalidate(5, sessionCount);
    	}

    	function videomixerplaceholder_show_count_binding(value) {
    		show_count = value;
    		$$invalidate(6, show_count);
    	}

    	function videomixerplaceholder_name_binding(value) {
    		name = value;
    		$$invalidate(7, name);
    	}

    	function videomixerplaceholder_opmode_binding(value) {
    		opmode = value;
    		$$invalidate(8, opmode);
    	}

    	function videomixerplaceholder_start_binding(value) {
    		start = value;
    		$$invalidate(9, start);
    	}

    	$$self.$$set = $$props => {
    		if ('on_video_received' in $$props) $$invalidate(0, on_video_received = $$props.on_video_received);
    		if ('on_enter' in $$props) $$invalidate(1, on_enter = $$props.on_enter);
    		if ('on_cache_check' in $$props) $$invalidate(2, on_cache_check = $$props.on_cache_check);
    		if ('skipTalkingVideo' in $$props) $$invalidate(3, skipTalkingVideo = $$props.skipTalkingVideo);
    		if ('on_video_synth_error' in $$props) $$invalidate(4, on_video_synth_error = $$props.on_video_synth_error);
    		if ('sessionCount' in $$props) $$invalidate(5, sessionCount = $$props.sessionCount);
    		if ('show_count' in $$props) $$invalidate(6, show_count = $$props.show_count);
    		if ('name' in $$props) $$invalidate(7, name = $$props.name);
    		if ('opmode' in $$props) $$invalidate(8, opmode = $$props.opmode);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		VideoMixerPlaceholder,
    		ConversationManager,
    		dispatch,
    		on_video_received,
    		on_enter,
    		on_cache_check,
    		skipTalkingVideo,
    		on_video_synth_error,
    		sessionCount,
    		show_count,
    		name,
    		opmode,
    		start,
    		displayChatMessage
    	});

    	$$self.$inject_state = $$props => {
    		if ('on_video_received' in $$props) $$invalidate(0, on_video_received = $$props.on_video_received);
    		if ('on_enter' in $$props) $$invalidate(1, on_enter = $$props.on_enter);
    		if ('on_cache_check' in $$props) $$invalidate(2, on_cache_check = $$props.on_cache_check);
    		if ('skipTalkingVideo' in $$props) $$invalidate(3, skipTalkingVideo = $$props.skipTalkingVideo);
    		if ('on_video_synth_error' in $$props) $$invalidate(4, on_video_synth_error = $$props.on_video_synth_error);
    		if ('sessionCount' in $$props) $$invalidate(5, sessionCount = $$props.sessionCount);
    		if ('show_count' in $$props) $$invalidate(6, show_count = $$props.show_count);
    		if ('name' in $$props) $$invalidate(7, name = $$props.name);
    		if ('opmode' in $$props) $$invalidate(8, opmode = $$props.opmode);
    		if ('start' in $$props) $$invalidate(9, start = $$props.start);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		on_video_received,
    		on_enter,
    		on_cache_check,
    		skipTalkingVideo,
    		on_video_synth_error,
    		sessionCount,
    		show_count,
    		name,
    		opmode,
    		start,
    		dispatch,
    		displayChatMessage,
    		conversationmanager_on_video_received_binding,
    		conversationmanager_on_enter_binding,
    		conversationmanager_on_cache_check_binding,
    		conversationmanager_skipTalkingVideo_binding,
    		conversationmanager_on_video_synth_error_binding,
    		firstClick_handler,
    		machine_ready_handler,
    		talking_end_handler,
    		videomixerplaceholder_sessionCount_binding,
    		videomixerplaceholder_show_count_binding,
    		videomixerplaceholder_name_binding,
    		videomixerplaceholder_opmode_binding,
    		videomixerplaceholder_start_binding
    	];
    }

    class VideoMixer2 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$b, create_fragment$f, safe_not_equal, {
    			on_video_received: 0,
    			on_enter: 1,
    			on_cache_check: 2,
    			skipTalkingVideo: 3,
    			on_video_synth_error: 4,
    			sessionCount: 5,
    			show_count: 6,
    			name: 7,
    			opmode: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoMixer2",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[7] === undefined && !('name' in props)) {
    			console.warn("<VideoMixer2> was created without expected prop 'name'");
    		}
    	}

    	get on_video_received() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set on_video_received(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_enter() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set on_enter(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_cache_check() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set on_cache_check(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skipTalkingVideo() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set skipTalkingVideo(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get on_video_synth_error() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set on_video_synth_error(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sessionCount() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionCount(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get show_count() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set show_count(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get opmode() {
    		throw new Error("<VideoMixer2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opmode(value) {
    		throw new Error("<VideoMixer2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Error.svelte generated by Svelte v3.47.0 */

    const { Error: Error_1$2 } = globals;
    const file$b = "src/components/Error.svelte";

    function add_css$2(target) {
    	append_styles(target, "svelte-6ee5mq", ".error.svelte-6ee5mq.svelte-6ee5mq{background-color:rgb(var(--background));color:rgb(var(--body));font-size:xx-large;text-align:center;display:flex;flex-direction:column;align-items:center}.error.svelte-6ee5mq div.svelte-6ee5mq{max-width:80vw}.title.svelte-6ee5mq.svelte-6ee5mq{font-weight:800;font-size:3em;margin-bottom:1em}.error-msg.svelte-6ee5mq.svelte-6ee5mq{color:rgb(var(--primary));font-size:large}.decoration.svelte-6ee5mq.svelte-6ee5mq{position:fixed;z-index:-1}.decoration.logo.svelte-6ee5mq.svelte-6ee5mq{top:1em;left:1em}.decoration.rectangle.svelte-6ee5mq.svelte-6ee5mq{width:20em;height:9em}.decoration.rectangle.one.svelte-6ee5mq.svelte-6ee5mq{background-color:rgba(var(--primary), 0.2);border-radius:4em;right:5vw}.decoration.rectangle.two.svelte-6ee5mq.svelte-6ee5mq{background-color:rgba(var(--primary), 0.1);border-radius:10em;bottom:5vh}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXJyb3Iuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXNCRSxNQUFNLDRCQUFDLENBQUEsQUFDTCxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksWUFBWSxDQUFDLENBQUMsQ0FDeEMsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixTQUFTLENBQUUsUUFBUSxDQUNuQixVQUFVLENBQUUsTUFBTSxDQUNsQixPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLFdBQVcsQ0FBRSxNQUFNLEFBQ3JCLENBQUEsQUFDQSxvQkFBTSxDQUFDLEdBQUcsY0FBQyxDQUFBLEFBQ1QsU0FBUyxDQUFFLElBQUksQUFDakIsQ0FBQSxBQUNBLE1BQU0sNEJBQUMsQ0FBQSxBQUNMLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLFNBQVMsQ0FBRSxHQUFHLENBQ2QsYUFBYSxDQUFFLEdBQUcsQUFDcEIsQ0FBQSxBQUNBLFVBQVUsNEJBQUMsQ0FBQSxBQUNULEtBQUssQ0FBRSxJQUFJLElBQUksU0FBUyxDQUFDLENBQUMsQ0FDMUIsU0FBUyxDQUFFLEtBQUssQUFDbEIsQ0FBQSxBQUNBLFdBQVcsNEJBQUMsQ0FBQSxBQUNWLFFBQVEsQ0FBRSxLQUFLLENBQ2YsT0FBTyxDQUFFLEVBQUUsQUFDYixDQUFBLEFBRUEsV0FBVyxLQUFLLDRCQUFDLENBQUEsQUFDZixHQUFHLENBQUUsR0FBRyxDQUNSLElBQUksQ0FBRSxHQUFHLEFBQ1gsQ0FBQSxBQUVBLFdBQVcsVUFBVSw0QkFBQyxDQUFBLEFBQ3BCLEtBQUssQ0FBRSxJQUFJLENBQ1gsTUFBTSxDQUFFLEdBQUcsQUFDYixDQUFBLEFBQ0EsV0FBVyxVQUFVLElBQUksNEJBQUMsQ0FBQSxBQUN4QixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDM0MsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsS0FBSyxDQUFFLEdBQUcsQUFDWixDQUFBLEFBQ0EsV0FBVyxVQUFVLElBQUksNEJBQUMsQ0FBQSxBQUN4QixnQkFBZ0IsQ0FBRSxLQUFLLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDM0MsYUFBYSxDQUFFLElBQUksQ0FDbkIsTUFBTSxDQUFFLEdBQUcsQUFDYixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkVycm9yLnN2ZWx0ZSJdfQ== */");
    }

    function create_fragment$e(ctx) {
    	let div6;
    	let div0;
    	let t0_value = /*$_*/ ctx[0]("error.title") + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*$_*/ ctx[0]("error.description") + "";
    	let t2;
    	let t3;
    	let div2;
    	let raw_value = /*$error*/ ctx[1].replaceAll("\n", "<br />") + "";
    	let t4;
    	let div3;
    	let logo;
    	let t5;
    	let div4;
    	let t6;
    	let div5;
    	let div6_transition;
    	let current;
    	logo = new Logo({ $$inline: true });

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = space();
    			div3 = element("div");
    			create_component(logo.$$.fragment);
    			t5 = space();
    			div4 = element("div");
    			t6 = space();
    			div5 = element("div");
    			attr_dev(div0, "class", "title svelte-6ee5mq");
    			add_location(div0, file$b, 7, 2, 251);
    			attr_dev(div1, "class", "svelte-6ee5mq");
    			add_location(div1, file$b, 8, 2, 298);
    			attr_dev(div2, "class", "error-msg svelte-6ee5mq");
    			add_location(div2, file$b, 9, 2, 337);
    			attr_dev(div3, "class", "decoration logo svelte-6ee5mq");
    			add_location(div3, file$b, 12, 2, 418);
    			attr_dev(div4, "class", "decoration rectangle one svelte-6ee5mq");
    			add_location(div4, file$b, 13, 2, 464);
    			attr_dev(div5, "class", "decoration rectangle two svelte-6ee5mq");
    			add_location(div5, file$b, 14, 2, 507);
    			attr_dev(div6, "class", "error center-text full-screen svelte-6ee5mq");
    			add_location(div6, file$b, 6, 0, 189);
    		},
    		l: function claim(nodes) {
    			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			append_dev(div0, t0);
    			append_dev(div6, t1);
    			append_dev(div6, div1);
    			append_dev(div1, t2);
    			append_dev(div6, t3);
    			append_dev(div6, div2);
    			div2.innerHTML = raw_value;
    			append_dev(div6, t4);
    			append_dev(div6, div3);
    			mount_component(logo, div3, null);
    			append_dev(div6, t5);
    			append_dev(div6, div4);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$_*/ 1) && t0_value !== (t0_value = /*$_*/ ctx[0]("error.title") + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$_*/ 1) && t2_value !== (t2_value = /*$_*/ ctx[0]("error.description") + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*$error*/ 2) && raw_value !== (raw_value = /*$error*/ ctx[1].replaceAll("\n", "<br />") + "")) div2.innerHTML = raw_value;		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div6_transition) div6_transition = create_bidirectional_transition(div6, fade, {}, true);
    				div6_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			if (!div6_transition) div6_transition = create_bidirectional_transition(div6, fade, {}, false);
    			div6_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			destroy_component(logo);
    			if (detaching && div6_transition) div6_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $_;
    	let $error;
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(0, $_ = $$value));
    	validate_store(error$2, 'error');
    	component_subscribe($$self, error$2, $$value => $$invalidate(1, $error = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Error', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Error> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ fade, error: error$2, _: Y, Logo, $_, $error });
    	return [$_, $error];
    }

    class Error$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$a, create_fragment$e, safe_not_equal, {}, add_css$2);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Error",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src/components/AuthenticationController.svelte generated by Svelte v3.47.0 */

    function create_fragment$d(ctx) {
    	const block = {
    		c: noop$1,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop$1,
    		p: noop$1,
    		i: noop$1,
    		o: noop$1,
    		d: noop$1
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const ANONYMOUS = "anonymous";
    const ANON_PSW = "Password1";

    function instance$9($$self, $$props, $$invalidate) {
    	let $body_data;
    	validate_store(body_data, 'body_data');
    	component_subscribe($$self, body_data, $$value => $$invalidate(9, $body_data = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AuthenticationController', slots, []);
    	const TOKEN_ENDPOINT = `${$body_data.api_base}/token`;
    	let { logged_username = ANONYMOUS } = $$props;
    	let { access_token = "" } = $$props;
    	let { _user_id = "" } = $$props;
    	let { decoded_token = undefined } = $$props;
    	let username = ANONYMOUS;
    	let password;
    	let timer;

    	const login = async (_username, _password, errorCb) => {
    		username = _username;
    		password = _password;
    		return await renew_token(errorCb);
    	};

    	const logout = async () => {
    		username = ANONYMOUS;
    		password = ANON_PSW;
    		return await renew_token();
    	};

    	const renew_token = async (errorCb = undefined) => {
    		const formData = new FormData();
    		formData.append("username", username);
    		formData.append("password", password);

    		try {
    			const response = await fetch(TOKEN_ENDPOINT, { method: "POST", body: formData });
    			const res = await response.json();
    			$$invalidate(0, access_token = res.access_token);
    			$$invalidate(2, _user_id = res.user_id);
    			await tick(); // let svelte compute decoded_token
    		} catch(raw_error) {
    			const e = raw_error;

    			if (e?.response?.status_code !== 401 || username === ANONYMOUS) {
    				let err = "";

    				if (e?.response?.data?.detail) {
    					const error = e.response.data.detail;

    					if (typeof error === "string") {
    						err = `${error}`;
    					} else if (typeof error === "object") {
    						// This error is a default from fastapi
    						const fastapi_error = error;

    						for (let i = 0; i < fastapi_error.length; i++) {
    							const el = fastapi_error[i];

    							if (i > 0) {
    								err += "\n";
    							}

    							err += el.msg + ": " + el.loc[1];
    						}
    					}
    				} else {
    					err = `${JSON.stringify(e)}`;
    				}

    				if (errorCb) {
    					errorCb(err);
    				} else {
    					error$2.set(err);
    				}
    			}

    			return;
    		}

    		if (access_token) {
    			$$invalidate(1, logged_username = username);

    			if (timer) {
    				clearTimeout(timer);
    				timer = undefined;
    			}

    			// arm timer to renew token
    			const time_left = moment(decoded_token.exp * 1000).valueOf() - moment().valueOf();

    			timer = setTimeout(
    				() => {
    					timer = undefined;
    					void renew_token();
    				},
    				Math.floor(time_left * 0.8)
    			);
    		}

    		const typed_token = decoded_token;
    		return { access_token, typed_token, _user_id };
    	};

    	// when start, log as anonymous
    	onMount(async () => {
    		await logout();
    	});

    	const writable_props = ['logged_username', 'access_token', '_user_id', 'decoded_token'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AuthenticationController> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('logged_username' in $$props) $$invalidate(1, logged_username = $$props.logged_username);
    		if ('access_token' in $$props) $$invalidate(0, access_token = $$props.access_token);
    		if ('_user_id' in $$props) $$invalidate(2, _user_id = $$props._user_id);
    		if ('decoded_token' in $$props) $$invalidate(3, decoded_token = $$props.decoded_token);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		moment,
    		error: error$2,
    		body_data,
    		TOKEN_ENDPOINT,
    		ANONYMOUS,
    		ANON_PSW,
    		logged_username,
    		access_token,
    		_user_id,
    		decoded_token,
    		username,
    		password,
    		timer,
    		login,
    		logout,
    		renew_token,
    		$body_data
    	});

    	$$self.$inject_state = $$props => {
    		if ('logged_username' in $$props) $$invalidate(1, logged_username = $$props.logged_username);
    		if ('access_token' in $$props) $$invalidate(0, access_token = $$props.access_token);
    		if ('_user_id' in $$props) $$invalidate(2, _user_id = $$props._user_id);
    		if ('decoded_token' in $$props) $$invalidate(3, decoded_token = $$props.decoded_token);
    		if ('username' in $$props) username = $$props.username;
    		if ('password' in $$props) password = $$props.password;
    		if ('timer' in $$props) timer = $$props.timer;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*access_token*/ 1) {
    			$$invalidate(3, decoded_token = access_token && JSON.parse(window.atob(access_token.split(".")[1])));
    		}
    	};

    	return [access_token, logged_username, _user_id, decoded_token, login, logout];
    }

    class AuthenticationController extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$9, create_fragment$d, safe_not_equal, {
    			logged_username: 1,
    			access_token: 0,
    			_user_id: 2,
    			decoded_token: 3,
    			login: 4,
    			logout: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AuthenticationController",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get logged_username() {
    		throw new Error("<AuthenticationController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set logged_username(value) {
    		throw new Error("<AuthenticationController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get access_token() {
    		throw new Error("<AuthenticationController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set access_token(value) {
    		throw new Error("<AuthenticationController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get _user_id() {
    		throw new Error("<AuthenticationController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set _user_id(value) {
    		throw new Error("<AuthenticationController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get decoded_token() {
    		throw new Error("<AuthenticationController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set decoded_token(value) {
    		throw new Error("<AuthenticationController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get login() {
    		return this.$$.ctx[4];
    	}

    	set login(value) {
    		throw new Error("<AuthenticationController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get logout() {
    		return this.$$.ctx[5];
    	}

    	set logout(value) {
    		throw new Error("<AuthenticationController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFoundation = /** @class */ (function () {
        function MDCFoundation(adapter) {
            if (adapter === void 0) { adapter = {}; }
            this.adapter = adapter;
        }
        Object.defineProperty(MDCFoundation, "cssClasses", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports every
                // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
                return {};
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "strings", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
                return {};
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "numbers", {
            get: function () {
                // Classes extending MDCFoundation should implement this method to return an object which exports all
                // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
                return {};
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFoundation, "defaultAdapter", {
            get: function () {
                // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
                // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
                // validation.
                return {};
            },
            enumerable: false,
            configurable: true
        });
        MDCFoundation.prototype.init = function () {
            // Subclasses should override this method to perform initialization routines (registering events, etc.)
        };
        MDCFoundation.prototype.destroy = function () {
            // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
        };
        return MDCFoundation;
    }());

    /**
     * @license
     * Copyright 2019 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * Determine whether the current browser supports passive event listeners, and
     * if so, use them.
     */
    function applyPassive$1(globalObj) {
        if (globalObj === void 0) { globalObj = window; }
        return supportsPassiveOption(globalObj) ?
            { passive: true } :
            false;
    }
    function supportsPassiveOption(globalObj) {
        if (globalObj === void 0) { globalObj = window; }
        // See
        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
        var passiveSupported = false;
        try {
            var options = {
                // This function will be called when the browser
                // attempts to access the passive property.
                get passive() {
                    passiveSupported = true;
                    return false;
                }
            };
            var handler = function () { };
            globalObj.document.addEventListener('test', handler, options);
            globalObj.document.removeEventListener('test', handler, options);
        }
        catch (err) {
            passiveSupported = false;
        }
        return passiveSupported;
    }

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        applyPassive: applyPassive$1
    });

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    /**
     * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
     * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
     */
    function closest(element, selector) {
        if (element.closest) {
            return element.closest(selector);
        }
        var el = element;
        while (el) {
            if (matches$1(el, selector)) {
                return el;
            }
            el = el.parentElement;
        }
        return null;
    }
    function matches$1(element, selector) {
        var nativeMatches = element.matches
            || element.webkitMatchesSelector
            || element.msMatchesSelector;
        return nativeMatches.call(element, selector);
    }
    /**
     * Used to compute the estimated scroll width of elements. When an element is
     * hidden due to display: none; being applied to a parent element, the width is
     * returned as 0. However, the element will have a true width once no longer
     * inside a display: none context. This method computes an estimated width when
     * the element is hidden or returns the true width when the element is visble.
     * @param {Element} element the element whose width to estimate
     */
    function estimateScrollWidth(element) {
        // Check the offsetParent. If the element inherits display: none from any
        // parent, the offsetParent property will be null (see
        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent).
        // This check ensures we only clone the node when necessary.
        var htmlEl = element;
        if (htmlEl.offsetParent !== null) {
            return htmlEl.scrollWidth;
        }
        var clone = htmlEl.cloneNode(true);
        clone.style.setProperty('position', 'absolute');
        clone.style.setProperty('transform', 'translate(-9999px, -9999px)');
        document.documentElement.appendChild(clone);
        var scrollWidth = clone.scrollWidth;
        document.documentElement.removeChild(clone);
        return scrollWidth;
    }

    var ponyfill = /*#__PURE__*/Object.freeze({
        __proto__: null,
        closest: closest,
        matches: matches$1,
        estimateScrollWidth: estimateScrollWidth
    });

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$4 = {
        LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
        LABEL_REQUIRED: 'mdc-floating-label--required',
        LABEL_SHAKE: 'mdc-floating-label--shake',
        ROOT: 'mdc-floating-label',
    };

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCFloatingLabelFoundation = /** @class */ (function (_super) {
        __extends(MDCFloatingLabelFoundation, _super);
        function MDCFloatingLabelFoundation(adapter) {
            var _this = _super.call(this, __assign$2(__assign$2({}, MDCFloatingLabelFoundation.defaultAdapter), adapter)) || this;
            _this.shakeAnimationEndHandler = function () {
                _this.handleShakeAnimationEnd();
            };
            return _this;
        }
        Object.defineProperty(MDCFloatingLabelFoundation, "cssClasses", {
            get: function () {
                return cssClasses$4;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCFloatingLabelFoundation, "defaultAdapter", {
            /**
             * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    getWidth: function () { return 0; },
                    registerInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: false,
            configurable: true
        });
        MDCFloatingLabelFoundation.prototype.init = function () {
            this.adapter.registerInteractionHandler('animationend', this.shakeAnimationEndHandler);
        };
        MDCFloatingLabelFoundation.prototype.destroy = function () {
            this.adapter.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler);
        };
        /**
         * Returns the width of the label element.
         */
        MDCFloatingLabelFoundation.prototype.getWidth = function () {
            return this.adapter.getWidth();
        };
        /**
         * Styles the label to produce a shake animation to indicate an error.
         * @param shouldShake If true, adds the shake CSS class; otherwise, removes shake class.
         */
        MDCFloatingLabelFoundation.prototype.shake = function (shouldShake) {
            var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
            if (shouldShake) {
                this.adapter.addClass(LABEL_SHAKE);
            }
            else {
                this.adapter.removeClass(LABEL_SHAKE);
            }
        };
        /**
         * Styles the label to float or dock.
         * @param shouldFloat If true, adds the float CSS class; otherwise, removes float and shake classes to dock the label.
         */
        MDCFloatingLabelFoundation.prototype.float = function (shouldFloat) {
            var _a = MDCFloatingLabelFoundation.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
            if (shouldFloat) {
                this.adapter.addClass(LABEL_FLOAT_ABOVE);
            }
            else {
                this.adapter.removeClass(LABEL_FLOAT_ABOVE);
                this.adapter.removeClass(LABEL_SHAKE);
            }
        };
        /**
         * Styles the label as required.
         * @param isRequired If true, adds an asterisk to the label, indicating that it is required.
         */
        MDCFloatingLabelFoundation.prototype.setRequired = function (isRequired) {
            var LABEL_REQUIRED = MDCFloatingLabelFoundation.cssClasses.LABEL_REQUIRED;
            if (isRequired) {
                this.adapter.addClass(LABEL_REQUIRED);
            }
            else {
                this.adapter.removeClass(LABEL_REQUIRED);
            }
        };
        MDCFloatingLabelFoundation.prototype.handleShakeAnimationEnd = function () {
            var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
            this.adapter.removeClass(LABEL_SHAKE);
        };
        return MDCFloatingLabelFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$3 = {
        LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
        LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating',
    };

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCLineRippleFoundation = /** @class */ (function (_super) {
        __extends(MDCLineRippleFoundation, _super);
        function MDCLineRippleFoundation(adapter) {
            var _this = _super.call(this, __assign$2(__assign$2({}, MDCLineRippleFoundation.defaultAdapter), adapter)) || this;
            _this.transitionEndHandler = function (evt) {
                _this.handleTransitionEnd(evt);
            };
            return _this;
        }
        Object.defineProperty(MDCLineRippleFoundation, "cssClasses", {
            get: function () {
                return cssClasses$3;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCLineRippleFoundation, "defaultAdapter", {
            /**
             * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return false; },
                    setStyle: function () { return undefined; },
                    registerEventHandler: function () { return undefined; },
                    deregisterEventHandler: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: false,
            configurable: true
        });
        MDCLineRippleFoundation.prototype.init = function () {
            this.adapter.registerEventHandler('transitionend', this.transitionEndHandler);
        };
        MDCLineRippleFoundation.prototype.destroy = function () {
            this.adapter.deregisterEventHandler('transitionend', this.transitionEndHandler);
        };
        MDCLineRippleFoundation.prototype.activate = function () {
            this.adapter.removeClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
            this.adapter.addClass(cssClasses$3.LINE_RIPPLE_ACTIVE);
        };
        MDCLineRippleFoundation.prototype.setRippleCenter = function (xCoordinate) {
            this.adapter.setStyle('transform-origin', xCoordinate + "px center");
        };
        MDCLineRippleFoundation.prototype.deactivate = function () {
            this.adapter.addClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
        };
        MDCLineRippleFoundation.prototype.handleTransitionEnd = function (evt) {
            // Wait for the line ripple to be either transparent or opaque
            // before emitting the animation end event
            var isDeactivating = this.adapter.hasClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
            if (evt.propertyName === 'opacity') {
                if (isDeactivating) {
                    this.adapter.removeClass(cssClasses$3.LINE_RIPPLE_ACTIVE);
                    this.adapter.removeClass(cssClasses$3.LINE_RIPPLE_DEACTIVATING);
                }
            }
        };
        return MDCLineRippleFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2018 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings$2 = {
        NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch',
    };
    var numbers$2 = {
        // This should stay in sync with $mdc-notched-outline-padding * 2.
        NOTCH_ELEMENT_PADDING: 8,
    };
    var cssClasses$2 = {
        NO_LABEL: 'mdc-notched-outline--no-label',
        OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
        OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
    };

    /**
     * @license
     * Copyright 2017 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var MDCNotchedOutlineFoundation = /** @class */ (function (_super) {
        __extends(MDCNotchedOutlineFoundation, _super);
        function MDCNotchedOutlineFoundation(adapter) {
            return _super.call(this, __assign$2(__assign$2({}, MDCNotchedOutlineFoundation.defaultAdapter), adapter)) || this;
        }
        Object.defineProperty(MDCNotchedOutlineFoundation, "strings", {
            get: function () {
                return strings$2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCNotchedOutlineFoundation, "cssClasses", {
            get: function () {
                return cssClasses$2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCNotchedOutlineFoundation, "numbers", {
            get: function () {
                return numbers$2;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCNotchedOutlineFoundation, "defaultAdapter", {
            /**
             * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    setNotchWidthProperty: function () { return undefined; },
                    removeNotchWidthProperty: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Adds the outline notched selector and updates the notch width calculated based off of notchWidth.
         */
        MDCNotchedOutlineFoundation.prototype.notch = function (notchWidth) {
            var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
            if (notchWidth > 0) {
                notchWidth += numbers$2.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
            }
            this.adapter.setNotchWidthProperty(notchWidth);
            this.adapter.addClass(OUTLINE_NOTCHED);
        };
        /**
         * Removes notched outline selector to close the notch in the outline.
         */
        MDCNotchedOutlineFoundation.prototype.closeNotch = function () {
            var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
            this.adapter.removeClass(OUTLINE_NOTCHED);
            this.adapter.removeNotchWidthProperty();
        };
        return MDCNotchedOutlineFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var cssClasses$1 = {
        // Ripple is a special case where the "root" component is really a "mixin" of sorts,
        // given that it's an 'upgrade' to an existing component. That being said it is the root
        // CSS class that all other CSS classes derive from.
        BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
        FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
        FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation',
        ROOT: 'mdc-ripple-upgraded',
        UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    };
    var strings$1 = {
        VAR_FG_SCALE: '--mdc-ripple-fg-scale',
        VAR_FG_SIZE: '--mdc-ripple-fg-size',
        VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end',
        VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
        VAR_LEFT: '--mdc-ripple-left',
        VAR_TOP: '--mdc-ripple-top',
    };
    var numbers$1 = {
        DEACTIVATION_TIMEOUT_MS: 225,
        FG_DEACTIVATION_MS: 150,
        INITIAL_ORIGIN_SCALE: 0.6,
        PADDING: 10,
        TAP_DELAY_MS: 300, // Delay between touch and simulated mouse events on touch devices
    };

    /**
     * Stores result from supportsCssVariables to avoid redundant processing to
     * detect CSS custom variable support.
     */
    var supportsCssVariables_;
    function supportsCssVariables(windowObj, forceRefresh) {
        if (forceRefresh === void 0) { forceRefresh = false; }
        var CSS = windowObj.CSS;
        var supportsCssVars = supportsCssVariables_;
        if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
            return supportsCssVariables_;
        }
        var supportsFunctionPresent = CSS && typeof CSS.supports === 'function';
        if (!supportsFunctionPresent) {
            return false;
        }
        var explicitlySupportsCssVars = CSS.supports('--css-vars', 'yes');
        // See: https://bugs.webkit.org/show_bug.cgi?id=154669
        // See: README section on Safari
        var weAreFeatureDetectingSafari10plus = (CSS.supports('(--css-vars: yes)') &&
            CSS.supports('color', '#00000000'));
        supportsCssVars =
            explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
        if (!forceRefresh) {
            supportsCssVariables_ = supportsCssVars;
        }
        return supportsCssVars;
    }
    function getNormalizedEventCoords(evt, pageOffset, clientRect) {
        if (!evt) {
            return { x: 0, y: 0 };
        }
        var x = pageOffset.x, y = pageOffset.y;
        var documentX = x + clientRect.left;
        var documentY = y + clientRect.top;
        var normalizedX;
        var normalizedY;
        // Determine touch point relative to the ripple container.
        if (evt.type === 'touchstart') {
            var touchEvent = evt;
            normalizedX = touchEvent.changedTouches[0].pageX - documentX;
            normalizedY = touchEvent.changedTouches[0].pageY - documentY;
        }
        else {
            var mouseEvent = evt;
            normalizedX = mouseEvent.pageX - documentX;
            normalizedY = mouseEvent.pageY - documentY;
        }
        return { x: normalizedX, y: normalizedY };
    }

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    // Activation events registered on the root element of each instance for activation
    var ACTIVATION_EVENT_TYPES = [
        'touchstart', 'pointerdown', 'mousedown', 'keydown',
    ];
    // Deactivation events registered on documentElement when a pointer-related down event occurs
    var POINTER_DEACTIVATION_EVENT_TYPES = [
        'touchend', 'pointerup', 'mouseup', 'contextmenu',
    ];
    // simultaneous nested activations
    var activatedTargets = [];
    var MDCRippleFoundation = /** @class */ (function (_super) {
        __extends(MDCRippleFoundation, _super);
        function MDCRippleFoundation(adapter) {
            var _this = _super.call(this, __assign$2(__assign$2({}, MDCRippleFoundation.defaultAdapter), adapter)) || this;
            _this.activationAnimationHasEnded = false;
            _this.activationTimer = 0;
            _this.fgDeactivationRemovalTimer = 0;
            _this.fgScale = '0';
            _this.frame = { width: 0, height: 0 };
            _this.initialSize = 0;
            _this.layoutFrame = 0;
            _this.maxRadius = 0;
            _this.unboundedCoords = { left: 0, top: 0 };
            _this.activationState = _this.defaultActivationState();
            _this.activationTimerCallback = function () {
                _this.activationAnimationHasEnded = true;
                _this.runDeactivationUXLogicIfReady();
            };
            _this.activateHandler = function (e) {
                _this.activateImpl(e);
            };
            _this.deactivateHandler = function () {
                _this.deactivateImpl();
            };
            _this.focusHandler = function () {
                _this.handleFocus();
            };
            _this.blurHandler = function () {
                _this.handleBlur();
            };
            _this.resizeHandler = function () {
                _this.layout();
            };
            return _this;
        }
        Object.defineProperty(MDCRippleFoundation, "cssClasses", {
            get: function () {
                return cssClasses$1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "strings", {
            get: function () {
                return strings$1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "numbers", {
            get: function () {
                return numbers$1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCRippleFoundation, "defaultAdapter", {
            get: function () {
                return {
                    addClass: function () { return undefined; },
                    browserSupportsCssVars: function () { return true; },
                    computeBoundingRect: function () {
                        return ({ top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 });
                    },
                    containsEventTarget: function () { return true; },
                    deregisterDocumentInteractionHandler: function () { return undefined; },
                    deregisterInteractionHandler: function () { return undefined; },
                    deregisterResizeHandler: function () { return undefined; },
                    getWindowPageOffset: function () { return ({ x: 0, y: 0 }); },
                    isSurfaceActive: function () { return true; },
                    isSurfaceDisabled: function () { return true; },
                    isUnbounded: function () { return true; },
                    registerDocumentInteractionHandler: function () { return undefined; },
                    registerInteractionHandler: function () { return undefined; },
                    registerResizeHandler: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    updateCssVariable: function () { return undefined; },
                };
            },
            enumerable: false,
            configurable: true
        });
        MDCRippleFoundation.prototype.init = function () {
            var _this = this;
            var supportsPressRipple = this.supportsPressRipple();
            this.registerRootHandlers(supportsPressRipple);
            if (supportsPressRipple) {
                var _a = MDCRippleFoundation.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter.addClass(ROOT_1);
                    if (_this.adapter.isUnbounded()) {
                        _this.adapter.addClass(UNBOUNDED_1);
                        // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
                        _this.layoutInternal();
                    }
                });
            }
        };
        MDCRippleFoundation.prototype.destroy = function () {
            var _this = this;
            if (this.supportsPressRipple()) {
                if (this.activationTimer) {
                    clearTimeout(this.activationTimer);
                    this.activationTimer = 0;
                    this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
                }
                if (this.fgDeactivationRemovalTimer) {
                    clearTimeout(this.fgDeactivationRemovalTimer);
                    this.fgDeactivationRemovalTimer = 0;
                    this.adapter.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
                }
                var _a = MDCRippleFoundation.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
                requestAnimationFrame(function () {
                    _this.adapter.removeClass(ROOT_2);
                    _this.adapter.removeClass(UNBOUNDED_2);
                    _this.removeCssVars();
                });
            }
            this.deregisterRootHandlers();
            this.deregisterDeactivationHandlers();
        };
        /**
         * @param evt Optional event containing position information.
         */
        MDCRippleFoundation.prototype.activate = function (evt) {
            this.activateImpl(evt);
        };
        MDCRippleFoundation.prototype.deactivate = function () {
            this.deactivateImpl();
        };
        MDCRippleFoundation.prototype.layout = function () {
            var _this = this;
            if (this.layoutFrame) {
                cancelAnimationFrame(this.layoutFrame);
            }
            this.layoutFrame = requestAnimationFrame(function () {
                _this.layoutInternal();
                _this.layoutFrame = 0;
            });
        };
        MDCRippleFoundation.prototype.setUnbounded = function (unbounded) {
            var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;
            if (unbounded) {
                this.adapter.addClass(UNBOUNDED);
            }
            else {
                this.adapter.removeClass(UNBOUNDED);
            }
        };
        MDCRippleFoundation.prototype.handleFocus = function () {
            var _this = this;
            requestAnimationFrame(function () { return _this.adapter.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });
        };
        MDCRippleFoundation.prototype.handleBlur = function () {
            var _this = this;
            requestAnimationFrame(function () { return _this.adapter.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED); });
        };
        /**
         * We compute this property so that we are not querying information about the client
         * until the point in time where the foundation requests it. This prevents scenarios where
         * client-side feature-detection may happen too early, such as when components are rendered on the server
         * and then initialized at mount time on the client.
         */
        MDCRippleFoundation.prototype.supportsPressRipple = function () {
            return this.adapter.browserSupportsCssVars();
        };
        MDCRippleFoundation.prototype.defaultActivationState = function () {
            return {
                activationEvent: undefined,
                hasDeactivationUXRun: false,
                isActivated: false,
                isProgrammatic: false,
                wasActivatedByPointer: false,
                wasElementMadeActive: false,
            };
        };
        /**
         * supportsPressRipple Passed from init to save a redundant function call
         */
        MDCRippleFoundation.prototype.registerRootHandlers = function (supportsPressRipple) {
            var e_1, _a;
            if (supportsPressRipple) {
                try {
                    for (var ACTIVATION_EVENT_TYPES_1 = __values$2(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
                        var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
                        this.adapter.registerInteractionHandler(evtType, this.activateHandler);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return)) _a.call(ACTIVATION_EVENT_TYPES_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (this.adapter.isUnbounded()) {
                    this.adapter.registerResizeHandler(this.resizeHandler);
                }
            }
            this.adapter.registerInteractionHandler('focus', this.focusHandler);
            this.adapter.registerInteractionHandler('blur', this.blurHandler);
        };
        MDCRippleFoundation.prototype.registerDeactivationHandlers = function (evt) {
            var e_2, _a;
            if (evt.type === 'keydown') {
                this.adapter.registerInteractionHandler('keyup', this.deactivateHandler);
            }
            else {
                try {
                    for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values$2(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
                        var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
                        this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
        };
        MDCRippleFoundation.prototype.deregisterRootHandlers = function () {
            var e_3, _a;
            try {
                for (var ACTIVATION_EVENT_TYPES_2 = __values$2(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
                    var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
                    this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return)) _a.call(ACTIVATION_EVENT_TYPES_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
            this.adapter.deregisterInteractionHandler('focus', this.focusHandler);
            this.adapter.deregisterInteractionHandler('blur', this.blurHandler);
            if (this.adapter.isUnbounded()) {
                this.adapter.deregisterResizeHandler(this.resizeHandler);
            }
        };
        MDCRippleFoundation.prototype.deregisterDeactivationHandlers = function () {
            var e_4, _a;
            this.adapter.deregisterInteractionHandler('keyup', this.deactivateHandler);
            try {
                for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values$2(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
                    var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
                    this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
        };
        MDCRippleFoundation.prototype.removeCssVars = function () {
            var _this = this;
            var rippleStrings = MDCRippleFoundation.strings;
            var keys = Object.keys(rippleStrings);
            keys.forEach(function (key) {
                if (key.indexOf('VAR_') === 0) {
                    _this.adapter.updateCssVariable(rippleStrings[key], null);
                }
            });
        };
        MDCRippleFoundation.prototype.activateImpl = function (evt) {
            var _this = this;
            if (this.adapter.isSurfaceDisabled()) {
                return;
            }
            var activationState = this.activationState;
            if (activationState.isActivated) {
                return;
            }
            // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
            var previousActivationEvent = this.previousActivationEvent;
            var isSameInteraction = previousActivationEvent && evt !== undefined && previousActivationEvent.type !== evt.type;
            if (isSameInteraction) {
                return;
            }
            activationState.isActivated = true;
            activationState.isProgrammatic = evt === undefined;
            activationState.activationEvent = evt;
            activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== undefined && (evt.type === 'mousedown' || evt.type === 'touchstart' || evt.type === 'pointerdown');
            var hasActivatedChild = evt !== undefined &&
                activatedTargets.length > 0 &&
                activatedTargets.some(function (target) { return _this.adapter.containsEventTarget(target); });
            if (hasActivatedChild) {
                // Immediately reset activation state, while preserving logic that prevents touch follow-on events
                this.resetActivationState();
                return;
            }
            if (evt !== undefined) {
                activatedTargets.push(evt.target);
                this.registerDeactivationHandlers(evt);
            }
            activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
            if (activationState.wasElementMadeActive) {
                this.animateActivation();
            }
            requestAnimationFrame(function () {
                // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
                activatedTargets = [];
                if (!activationState.wasElementMadeActive
                    && evt !== undefined
                    && (evt.key === ' ' || evt.keyCode === 32)) {
                    // If space was pressed, try again within an rAF call to detect :active, because different UAs report
                    // active states inconsistently when they're called within event handling code:
                    // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
                    // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
                    // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
                    // variable is set within a rAF callback for a submit button interaction (#2241).
                    activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
                    if (activationState.wasElementMadeActive) {
                        _this.animateActivation();
                    }
                }
                if (!activationState.wasElementMadeActive) {
                    // Reset activation state immediately if element was not made active.
                    _this.activationState = _this.defaultActivationState();
                }
            });
        };
        MDCRippleFoundation.prototype.checkElementMadeActive = function (evt) {
            return (evt !== undefined && evt.type === 'keydown') ?
                this.adapter.isSurfaceActive() :
                true;
        };
        MDCRippleFoundation.prototype.animateActivation = function () {
            var _this = this;
            var _a = MDCRippleFoundation.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
            var _b = MDCRippleFoundation.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
            var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
            this.layoutInternal();
            var translateStart = '';
            var translateEnd = '';
            if (!this.adapter.isUnbounded()) {
                var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
                translateStart = startPoint.x + "px, " + startPoint.y + "px";
                translateEnd = endPoint.x + "px, " + endPoint.y + "px";
            }
            this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
            this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
            // Cancel any ongoing activation/deactivation animations
            clearTimeout(this.activationTimer);
            clearTimeout(this.fgDeactivationRemovalTimer);
            this.rmBoundedActivationClasses();
            this.adapter.removeClass(FG_DEACTIVATION);
            // Force layout in order to re-trigger the animation.
            this.adapter.computeBoundingRect();
            this.adapter.addClass(FG_ACTIVATION);
            this.activationTimer = setTimeout(function () {
                _this.activationTimerCallback();
            }, DEACTIVATION_TIMEOUT_MS);
        };
        MDCRippleFoundation.prototype.getFgTranslationCoordinates = function () {
            var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
            var startPoint;
            if (wasActivatedByPointer) {
                startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
            }
            else {
                startPoint = {
                    x: this.frame.width / 2,
                    y: this.frame.height / 2,
                };
            }
            // Center the element around the start point.
            startPoint = {
                x: startPoint.x - (this.initialSize / 2),
                y: startPoint.y - (this.initialSize / 2),
            };
            var endPoint = {
                x: (this.frame.width / 2) - (this.initialSize / 2),
                y: (this.frame.height / 2) - (this.initialSize / 2),
            };
            return { startPoint: startPoint, endPoint: endPoint };
        };
        MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady = function () {
            var _this = this;
            // This method is called both when a pointing device is released, and when the activation animation ends.
            // The deactivation animation should only run after both of those occur.
            var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
            var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
            var activationHasEnded = hasDeactivationUXRun || !isActivated;
            if (activationHasEnded && this.activationAnimationHasEnded) {
                this.rmBoundedActivationClasses();
                this.adapter.addClass(FG_DEACTIVATION);
                this.fgDeactivationRemovalTimer = setTimeout(function () {
                    _this.adapter.removeClass(FG_DEACTIVATION);
                }, numbers$1.FG_DEACTIVATION_MS);
            }
        };
        MDCRippleFoundation.prototype.rmBoundedActivationClasses = function () {
            var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
            this.adapter.removeClass(FG_ACTIVATION);
            this.activationAnimationHasEnded = false;
            this.adapter.computeBoundingRect();
        };
        MDCRippleFoundation.prototype.resetActivationState = function () {
            var _this = this;
            this.previousActivationEvent = this.activationState.activationEvent;
            this.activationState = this.defaultActivationState();
            // Touch devices may fire additional events for the same interaction within a short time.
            // Store the previous event until it's safe to assume that subsequent events are for new interactions.
            setTimeout(function () { return _this.previousActivationEvent = undefined; }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
        };
        MDCRippleFoundation.prototype.deactivateImpl = function () {
            var _this = this;
            var activationState = this.activationState;
            // This can happen in scenarios such as when you have a keyup event that blurs the element.
            if (!activationState.isActivated) {
                return;
            }
            var state = __assign$2({}, activationState);
            if (activationState.isProgrammatic) {
                requestAnimationFrame(function () {
                    _this.animateDeactivation(state);
                });
                this.resetActivationState();
            }
            else {
                this.deregisterDeactivationHandlers();
                requestAnimationFrame(function () {
                    _this.activationState.hasDeactivationUXRun = true;
                    _this.animateDeactivation(state);
                    _this.resetActivationState();
                });
            }
        };
        MDCRippleFoundation.prototype.animateDeactivation = function (_a) {
            var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
            if (wasActivatedByPointer || wasElementMadeActive) {
                this.runDeactivationUXLogicIfReady();
            }
        };
        MDCRippleFoundation.prototype.layoutInternal = function () {
            var _this = this;
            this.frame = this.adapter.computeBoundingRect();
            var maxDim = Math.max(this.frame.height, this.frame.width);
            // Surface diameter is treated differently for unbounded vs. bounded ripples.
            // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
            // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
            // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
            // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
            // `overflow: hidden`.
            var getBoundedRadius = function () {
                var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
                return hypotenuse + MDCRippleFoundation.numbers.PADDING;
            };
            this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
            // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
            var initialSize = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
            // Unbounded ripple size should always be even number to equally center align.
            if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
                this.initialSize = initialSize - 1;
            }
            else {
                this.initialSize = initialSize;
            }
            this.fgScale = "" + this.maxRadius / this.initialSize;
            this.updateLayoutCssVars();
        };
        MDCRippleFoundation.prototype.updateLayoutCssVars = function () {
            var _a = MDCRippleFoundation.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
            this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
            this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
            if (this.adapter.isUnbounded()) {
                this.unboundedCoords = {
                    left: Math.round((this.frame.width / 2) - (this.initialSize / 2)),
                    top: Math.round((this.frame.height / 2) - (this.initialSize / 2)),
                };
                this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
                this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
            }
        };
        return MDCRippleFoundation;
    }(MDCFoundation));

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var strings = {
        ARIA_CONTROLS: 'aria-controls',
        ARIA_DESCRIBEDBY: 'aria-describedby',
        INPUT_SELECTOR: '.mdc-text-field__input',
        LABEL_SELECTOR: '.mdc-floating-label',
        LEADING_ICON_SELECTOR: '.mdc-text-field__icon--leading',
        LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
        OUTLINE_SELECTOR: '.mdc-notched-outline',
        PREFIX_SELECTOR: '.mdc-text-field__affix--prefix',
        SUFFIX_SELECTOR: '.mdc-text-field__affix--suffix',
        TRAILING_ICON_SELECTOR: '.mdc-text-field__icon--trailing'
    };
    var cssClasses = {
        DISABLED: 'mdc-text-field--disabled',
        FOCUSED: 'mdc-text-field--focused',
        HELPER_LINE: 'mdc-text-field-helper-line',
        INVALID: 'mdc-text-field--invalid',
        LABEL_FLOATING: 'mdc-text-field--label-floating',
        NO_LABEL: 'mdc-text-field--no-label',
        OUTLINED: 'mdc-text-field--outlined',
        ROOT: 'mdc-text-field',
        TEXTAREA: 'mdc-text-field--textarea',
        WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon',
        WITH_TRAILING_ICON: 'mdc-text-field--with-trailing-icon',
        WITH_INTERNAL_COUNTER: 'mdc-text-field--with-internal-counter',
    };
    var numbers = {
        LABEL_SCALE: 0.75,
    };
    /**
     * Whitelist based off of
     * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
     * under the "Validation-related attributes" section.
     */
    var VALIDATION_ATTR_WHITELIST = [
        'pattern',
        'min',
        'max',
        'required',
        'step',
        'minlength',
        'maxlength',
    ];
    /**
     * Label should always float for these types as they show some UI even if value
     * is empty.
     */
    var ALWAYS_FLOAT_TYPES = [
        'color',
        'date',
        'datetime-local',
        'month',
        'range',
        'time',
        'week',
    ];

    /**
     * @license
     * Copyright 2016 Google Inc.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     */
    var POINTERDOWN_EVENTS = ['mousedown', 'touchstart'];
    var INTERACTION_EVENTS = ['click', 'keydown'];
    var MDCTextFieldFoundation = /** @class */ (function (_super) {
        __extends(MDCTextFieldFoundation, _super);
        /**
         * @param adapter
         * @param foundationMap Map from subcomponent names to their subfoundations.
         */
        function MDCTextFieldFoundation(adapter, foundationMap) {
            if (foundationMap === void 0) { foundationMap = {}; }
            var _this = _super.call(this, __assign$2(__assign$2({}, MDCTextFieldFoundation.defaultAdapter), adapter)) || this;
            _this.isFocused = false;
            _this.receivedUserInput = false;
            _this.valid = true;
            _this.useNativeValidation = true;
            _this.validateOnValueChange = true;
            _this.helperText = foundationMap.helperText;
            _this.characterCounter = foundationMap.characterCounter;
            _this.leadingIcon = foundationMap.leadingIcon;
            _this.trailingIcon = foundationMap.trailingIcon;
            _this.inputFocusHandler = function () {
                _this.activateFocus();
            };
            _this.inputBlurHandler = function () {
                _this.deactivateFocus();
            };
            _this.inputInputHandler = function () {
                _this.handleInput();
            };
            _this.setPointerXOffset = function (evt) {
                _this.setTransformOrigin(evt);
            };
            _this.textFieldInteractionHandler = function () {
                _this.handleTextFieldInteraction();
            };
            _this.validationAttributeChangeHandler = function (attributesList) {
                _this.handleValidationAttributeChange(attributesList);
            };
            return _this;
        }
        Object.defineProperty(MDCTextFieldFoundation, "cssClasses", {
            get: function () {
                return cssClasses;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation, "strings", {
            get: function () {
                return strings;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation, "numbers", {
            get: function () {
                return numbers;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldAlwaysFloat", {
            get: function () {
                var type = this.getNativeInput().type;
                return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldFloat", {
            get: function () {
                return this.shouldAlwaysFloat || this.isFocused || !!this.getValue() ||
                    this.isBadInput();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation.prototype, "shouldShake", {
            get: function () {
                return !this.isFocused && !this.isValid() && !!this.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MDCTextFieldFoundation, "defaultAdapter", {
            /**
             * See {@link MDCTextFieldAdapter} for typing information on parameters and
             * return types.
             */
            get: function () {
                // tslint:disable:object-literal-sort-keys Methods should be in the same order as the adapter interface.
                return {
                    addClass: function () { return undefined; },
                    removeClass: function () { return undefined; },
                    hasClass: function () { return true; },
                    setInputAttr: function () { return undefined; },
                    removeInputAttr: function () { return undefined; },
                    registerTextFieldInteractionHandler: function () { return undefined; },
                    deregisterTextFieldInteractionHandler: function () { return undefined; },
                    registerInputInteractionHandler: function () { return undefined; },
                    deregisterInputInteractionHandler: function () { return undefined; },
                    registerValidationAttributeChangeHandler: function () {
                        return new MutationObserver(function () { return undefined; });
                    },
                    deregisterValidationAttributeChangeHandler: function () { return undefined; },
                    getNativeInput: function () { return null; },
                    isFocused: function () { return false; },
                    activateLineRipple: function () { return undefined; },
                    deactivateLineRipple: function () { return undefined; },
                    setLineRippleTransformOrigin: function () { return undefined; },
                    shakeLabel: function () { return undefined; },
                    floatLabel: function () { return undefined; },
                    setLabelRequired: function () { return undefined; },
                    hasLabel: function () { return false; },
                    getLabelWidth: function () { return 0; },
                    hasOutline: function () { return false; },
                    notchOutline: function () { return undefined; },
                    closeOutline: function () { return undefined; },
                };
                // tslint:enable:object-literal-sort-keys
            },
            enumerable: false,
            configurable: true
        });
        MDCTextFieldFoundation.prototype.init = function () {
            var e_1, _a, e_2, _b;
            if (this.adapter.hasLabel() && this.getNativeInput().required) {
                this.adapter.setLabelRequired(true);
            }
            if (this.adapter.isFocused()) {
                this.inputFocusHandler();
            }
            else if (this.adapter.hasLabel() && this.shouldFloat) {
                this.notchOutline(true);
                this.adapter.floatLabel(true);
                this.styleFloating(true);
            }
            this.adapter.registerInputInteractionHandler('focus', this.inputFocusHandler);
            this.adapter.registerInputInteractionHandler('blur', this.inputBlurHandler);
            this.adapter.registerInputInteractionHandler('input', this.inputInputHandler);
            try {
                for (var POINTERDOWN_EVENTS_1 = __values$2(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next(); !POINTERDOWN_EVENTS_1_1.done; POINTERDOWN_EVENTS_1_1 = POINTERDOWN_EVENTS_1.next()) {
                    var evtType = POINTERDOWN_EVENTS_1_1.value;
                    this.adapter.registerInputInteractionHandler(evtType, this.setPointerXOffset);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (POINTERDOWN_EVENTS_1_1 && !POINTERDOWN_EVENTS_1_1.done && (_a = POINTERDOWN_EVENTS_1.return)) _a.call(POINTERDOWN_EVENTS_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            try {
                for (var INTERACTION_EVENTS_1 = __values$2(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
                    var evtType = INTERACTION_EVENTS_1_1.value;
                    this.adapter.registerTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_b = INTERACTION_EVENTS_1.return)) _b.call(INTERACTION_EVENTS_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.validationObserver =
                this.adapter.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler);
            this.setcharacterCounter(this.getValue().length);
        };
        MDCTextFieldFoundation.prototype.destroy = function () {
            var e_3, _a, e_4, _b;
            this.adapter.deregisterInputInteractionHandler('focus', this.inputFocusHandler);
            this.adapter.deregisterInputInteractionHandler('blur', this.inputBlurHandler);
            this.adapter.deregisterInputInteractionHandler('input', this.inputInputHandler);
            try {
                for (var POINTERDOWN_EVENTS_2 = __values$2(POINTERDOWN_EVENTS), POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next(); !POINTERDOWN_EVENTS_2_1.done; POINTERDOWN_EVENTS_2_1 = POINTERDOWN_EVENTS_2.next()) {
                    var evtType = POINTERDOWN_EVENTS_2_1.value;
                    this.adapter.deregisterInputInteractionHandler(evtType, this.setPointerXOffset);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (POINTERDOWN_EVENTS_2_1 && !POINTERDOWN_EVENTS_2_1.done && (_a = POINTERDOWN_EVENTS_2.return)) _a.call(POINTERDOWN_EVENTS_2);
                }
                finally { if (e_3) throw e_3.error; }
            }
            try {
                for (var INTERACTION_EVENTS_2 = __values$2(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
                    var evtType = INTERACTION_EVENTS_2_1.value;
                    this.adapter.deregisterTextFieldInteractionHandler(evtType, this.textFieldInteractionHandler);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_b = INTERACTION_EVENTS_2.return)) _b.call(INTERACTION_EVENTS_2);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this.adapter.deregisterValidationAttributeChangeHandler(this.validationObserver);
        };
        /**
         * Handles user interactions with the Text Field.
         */
        MDCTextFieldFoundation.prototype.handleTextFieldInteraction = function () {
            var nativeInput = this.adapter.getNativeInput();
            if (nativeInput && nativeInput.disabled) {
                return;
            }
            this.receivedUserInput = true;
        };
        /**
         * Handles validation attribute changes
         */
        MDCTextFieldFoundation.prototype.handleValidationAttributeChange = function (attributesList) {
            var _this = this;
            attributesList.some(function (attributeName) {
                if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
                    _this.styleValidity(true);
                    _this.adapter.setLabelRequired(_this.getNativeInput().required);
                    return true;
                }
                return false;
            });
            if (attributesList.indexOf('maxlength') > -1) {
                this.setcharacterCounter(this.getValue().length);
            }
        };
        /**
         * Opens/closes the notched outline.
         */
        MDCTextFieldFoundation.prototype.notchOutline = function (openNotch) {
            if (!this.adapter.hasOutline() || !this.adapter.hasLabel()) {
                return;
            }
            if (openNotch) {
                var labelWidth = this.adapter.getLabelWidth() * numbers.LABEL_SCALE;
                this.adapter.notchOutline(labelWidth);
            }
            else {
                this.adapter.closeOutline();
            }
        };
        /**
         * Activates the text field focus state.
         */
        MDCTextFieldFoundation.prototype.activateFocus = function () {
            this.isFocused = true;
            this.styleFocused(this.isFocused);
            this.adapter.activateLineRipple();
            if (this.adapter.hasLabel()) {
                this.notchOutline(this.shouldFloat);
                this.adapter.floatLabel(this.shouldFloat);
                this.styleFloating(this.shouldFloat);
                this.adapter.shakeLabel(this.shouldShake);
            }
            if (this.helperText &&
                (this.helperText.isPersistent() || !this.helperText.isValidation() ||
                    !this.valid)) {
                this.helperText.showToScreenReader();
            }
        };
        /**
         * Sets the line ripple's transform origin, so that the line ripple activate
         * animation will animate out from the user's click location.
         */
        MDCTextFieldFoundation.prototype.setTransformOrigin = function (evt) {
            if (this.isDisabled() || this.adapter.hasOutline()) {
                return;
            }
            var touches = evt.touches;
            var targetEvent = touches ? touches[0] : evt;
            var targetClientRect = targetEvent.target.getBoundingClientRect();
            var normalizedX = targetEvent.clientX - targetClientRect.left;
            this.adapter.setLineRippleTransformOrigin(normalizedX);
        };
        /**
         * Handles input change of text input and text area.
         */
        MDCTextFieldFoundation.prototype.handleInput = function () {
            this.autoCompleteFocus();
            this.setcharacterCounter(this.getValue().length);
        };
        /**
         * Activates the Text Field's focus state in cases when the input value
         * changes without user input (e.g. programmatically).
         */
        MDCTextFieldFoundation.prototype.autoCompleteFocus = function () {
            if (!this.receivedUserInput) {
                this.activateFocus();
            }
        };
        /**
         * Deactivates the Text Field's focus state.
         */
        MDCTextFieldFoundation.prototype.deactivateFocus = function () {
            this.isFocused = false;
            this.adapter.deactivateLineRipple();
            var isValid = this.isValid();
            this.styleValidity(isValid);
            this.styleFocused(this.isFocused);
            if (this.adapter.hasLabel()) {
                this.notchOutline(this.shouldFloat);
                this.adapter.floatLabel(this.shouldFloat);
                this.styleFloating(this.shouldFloat);
                this.adapter.shakeLabel(this.shouldShake);
            }
            if (!this.shouldFloat) {
                this.receivedUserInput = false;
            }
        };
        MDCTextFieldFoundation.prototype.getValue = function () {
            return this.getNativeInput().value;
        };
        /**
         * @param value The value to set on the input Element.
         */
        MDCTextFieldFoundation.prototype.setValue = function (value) {
            // Prevent Safari from moving the caret to the end of the input when the
            // value has not changed.
            if (this.getValue() !== value) {
                this.getNativeInput().value = value;
            }
            this.setcharacterCounter(value.length);
            if (this.validateOnValueChange) {
                var isValid = this.isValid();
                this.styleValidity(isValid);
            }
            if (this.adapter.hasLabel()) {
                this.notchOutline(this.shouldFloat);
                this.adapter.floatLabel(this.shouldFloat);
                this.styleFloating(this.shouldFloat);
                if (this.validateOnValueChange) {
                    this.adapter.shakeLabel(this.shouldShake);
                }
            }
        };
        /**
         * @return The custom validity state, if set; otherwise, the result of a
         *     native validity check.
         */
        MDCTextFieldFoundation.prototype.isValid = function () {
            return this.useNativeValidation ? this.isNativeInputValid() : this.valid;
        };
        /**
         * @param isValid Sets the custom validity state of the Text Field.
         */
        MDCTextFieldFoundation.prototype.setValid = function (isValid) {
            this.valid = isValid;
            this.styleValidity(isValid);
            var shouldShake = !isValid && !this.isFocused && !!this.getValue();
            if (this.adapter.hasLabel()) {
                this.adapter.shakeLabel(shouldShake);
            }
        };
        /**
         * @param shouldValidate Whether or not validity should be updated on
         *     value change.
         */
        MDCTextFieldFoundation.prototype.setValidateOnValueChange = function (shouldValidate) {
            this.validateOnValueChange = shouldValidate;
        };
        /**
         * @return Whether or not validity should be updated on value change. `true`
         *     by default.
         */
        MDCTextFieldFoundation.prototype.getValidateOnValueChange = function () {
            return this.validateOnValueChange;
        };
        /**
         * Enables or disables the use of native validation. Use this for custom
         * validation.
         * @param useNativeValidation Set this to false to ignore native input
         *     validation.
         */
        MDCTextFieldFoundation.prototype.setUseNativeValidation = function (useNativeValidation) {
            this.useNativeValidation = useNativeValidation;
        };
        MDCTextFieldFoundation.prototype.isDisabled = function () {
            return this.getNativeInput().disabled;
        };
        /**
         * @param disabled Sets the text-field disabled or enabled.
         */
        MDCTextFieldFoundation.prototype.setDisabled = function (disabled) {
            this.getNativeInput().disabled = disabled;
            this.styleDisabled(disabled);
        };
        /**
         * @param content Sets the content of the helper text.
         */
        MDCTextFieldFoundation.prototype.setHelperTextContent = function (content) {
            if (this.helperText) {
                this.helperText.setContent(content);
            }
        };
        /**
         * Sets the aria label of the leading icon.
         */
        MDCTextFieldFoundation.prototype.setLeadingIconAriaLabel = function (label) {
            if (this.leadingIcon) {
                this.leadingIcon.setAriaLabel(label);
            }
        };
        /**
         * Sets the text content of the leading icon.
         */
        MDCTextFieldFoundation.prototype.setLeadingIconContent = function (content) {
            if (this.leadingIcon) {
                this.leadingIcon.setContent(content);
            }
        };
        /**
         * Sets the aria label of the trailing icon.
         */
        MDCTextFieldFoundation.prototype.setTrailingIconAriaLabel = function (label) {
            if (this.trailingIcon) {
                this.trailingIcon.setAriaLabel(label);
            }
        };
        /**
         * Sets the text content of the trailing icon.
         */
        MDCTextFieldFoundation.prototype.setTrailingIconContent = function (content) {
            if (this.trailingIcon) {
                this.trailingIcon.setContent(content);
            }
        };
        /**
         * Sets character counter values that shows characters used and the total
         * character limit.
         */
        MDCTextFieldFoundation.prototype.setcharacterCounter = function (currentLength) {
            if (!this.characterCounter) {
                return;
            }
            var maxLength = this.getNativeInput().maxLength;
            if (maxLength === -1) {
                throw new Error('MDCTextFieldFoundation: Expected maxlength html property on text input or textarea.');
            }
            this.characterCounter.setCounterValue(currentLength, maxLength);
        };
        /**
         * @return True if the Text Field input fails in converting the user-supplied
         *     value.
         */
        MDCTextFieldFoundation.prototype.isBadInput = function () {
            // The badInput property is not supported in IE 11 💩.
            return this.getNativeInput().validity.badInput || false;
        };
        /**
         * @return The result of native validity checking (ValidityState.valid).
         */
        MDCTextFieldFoundation.prototype.isNativeInputValid = function () {
            return this.getNativeInput().validity.valid;
        };
        /**
         * Styles the component based on the validity state.
         */
        MDCTextFieldFoundation.prototype.styleValidity = function (isValid) {
            var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;
            if (isValid) {
                this.adapter.removeClass(INVALID);
            }
            else {
                this.adapter.addClass(INVALID);
            }
            if (this.helperText) {
                this.helperText.setValidity(isValid);
                // We dynamically set or unset aria-describedby for validation helper text
                // only, based on whether the field is valid
                var helperTextValidation = this.helperText.isValidation();
                if (!helperTextValidation) {
                    return;
                }
                var helperTextVisible = this.helperText.isVisible();
                var helperTextId = this.helperText.getId();
                if (helperTextVisible && helperTextId) {
                    this.adapter.setInputAttr(strings.ARIA_DESCRIBEDBY, helperTextId);
                }
                else {
                    this.adapter.removeInputAttr(strings.ARIA_DESCRIBEDBY);
                }
            }
        };
        /**
         * Styles the component based on the focused state.
         */
        MDCTextFieldFoundation.prototype.styleFocused = function (isFocused) {
            var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;
            if (isFocused) {
                this.adapter.addClass(FOCUSED);
            }
            else {
                this.adapter.removeClass(FOCUSED);
            }
        };
        /**
         * Styles the component based on the disabled state.
         */
        MDCTextFieldFoundation.prototype.styleDisabled = function (isDisabled) {
            var _a = MDCTextFieldFoundation.cssClasses, DISABLED = _a.DISABLED, INVALID = _a.INVALID;
            if (isDisabled) {
                this.adapter.addClass(DISABLED);
                this.adapter.removeClass(INVALID);
            }
            else {
                this.adapter.removeClass(DISABLED);
            }
            if (this.leadingIcon) {
                this.leadingIcon.setDisabled(isDisabled);
            }
            if (this.trailingIcon) {
                this.trailingIcon.setDisabled(isDisabled);
            }
        };
        /**
         * Styles the component based on the label floating state.
         */
        MDCTextFieldFoundation.prototype.styleFloating = function (isFloating) {
            var LABEL_FLOATING = MDCTextFieldFoundation.cssClasses.LABEL_FLOATING;
            if (isFloating) {
                this.adapter.addClass(LABEL_FLOATING);
            }
            else {
                this.adapter.removeClass(LABEL_FLOATING);
            }
        };
        /**
         * @return The native text input element from the host environment, or an
         *     object with the same shape for unit tests.
         */
        MDCTextFieldFoundation.prototype.getNativeInput = function () {
            // this.adapter may be undefined in foundation unit tests. This happens when
            // testdouble is creating a mock object and invokes the
            // shouldShake/shouldFloat getters (which in turn call getValue(), which
            // calls this method) before init() has been called from the MDCTextField
            // constructor. To work around that issue, we return a dummy object.
            var nativeInput = this.adapter ? this.adapter.getNativeInput() : null;
            return nativeInput || {
                disabled: false,
                maxLength: -1,
                required: false,
                type: 'input',
                validity: {
                    badInput: false,
                    valid: true,
                },
                value: '',
            };
        };
        return MDCTextFieldFoundation;
    }(MDCFoundation));

    function classMap(classObj) {
        return Object.entries(classObj)
            .filter(([name, value]) => name !== '' && value)
            .map(([name]) => name)
            .join(' ');
    }

    function dispatch(element, eventType, detail, eventInit = { bubbles: true }, 
    /** This is an internal thing used by SMUI to duplicate some SMUI events as MDC events. */
    duplicateEventForMDC = false) {
        if (typeof Event !== 'undefined' && element) {
            const event = new CustomEvent(eventType, Object.assign(Object.assign({}, eventInit), { detail }));
            element === null || element === void 0 ? void 0 : element.dispatchEvent(event);
            if (duplicateEventForMDC && eventType.startsWith('SMUI')) {
                const duplicateEvent = new CustomEvent(eventType.replace(/^SMUI/g, () => 'MDC'), Object.assign(Object.assign({}, eventInit), { detail }));
                element === null || element === void 0 ? void 0 : element.dispatchEvent(duplicateEvent);
                if (duplicateEvent.defaultPrevented) {
                    event.preventDefault();
                }
            }
            return event;
        }
    }

    function exclude(obj, keys) {
        let names = Object.getOwnPropertyNames(obj);
        const newObj = {};
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            const cashIndex = name.indexOf('$');
            if (cashIndex !== -1 &&
                keys.indexOf(name.substring(0, cashIndex + 1)) !== -1) {
                continue;
            }
            if (keys.indexOf(name) !== -1) {
                continue;
            }
            newObj[name] = obj[name];
        }
        return newObj;
    }

    // Match old modifiers. (only works on DOM events)
    const oldModifierRegex = /^[a-z]+(?::(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    // Match new modifiers.
    const newModifierRegex = /^[^$]+(?:\$(?:preventDefault|stopPropagation|passive|nonpassive|capture|once|self))+$/;
    function forwardEventsBuilder(component) {
        // This is our pseudo $on function. It is defined on component mount.
        let $on;
        // This is a list of events bound before mount.
        let events = [];
        // And we override the $on function to forward all bound events.
        component.$on = (fullEventType, callback) => {
            let eventType = fullEventType;
            let destructor = () => { };
            if ($on) {
                // The event was bound programmatically.
                destructor = $on(eventType, callback);
            }
            else {
                // The event was bound before mount by Svelte.
                events.push([eventType, callback]);
            }
            const oldModifierMatch = eventType.match(oldModifierRegex);
            if (oldModifierMatch && console) {
                console.warn('Event modifiers in SMUI now use "$" instead of ":", so that ' +
                    'all events can be bound with modifiers. Please update your ' +
                    'event binding: ', eventType);
            }
            return () => {
                destructor();
            };
        };
        function forward(e) {
            // Internally bubble the event up from Svelte components.
            bubble(component, e);
        }
        return (node) => {
            const destructors = [];
            const forwardDestructors = {};
            // This function is responsible for listening and forwarding
            // all bound events.
            $on = (fullEventType, callback) => {
                let eventType = fullEventType;
                let handler = callback;
                // DOM addEventListener options argument.
                let options = false;
                const oldModifierMatch = eventType.match(oldModifierRegex);
                const newModifierMatch = eventType.match(newModifierRegex);
                const modifierMatch = oldModifierMatch || newModifierMatch;
                if (eventType.match(/^SMUI:\w+:/)) {
                    const newEventTypeParts = eventType.split(':');
                    let newEventType = '';
                    for (let i = 0; i < newEventTypeParts.length; i++) {
                        newEventType +=
                            i === newEventTypeParts.length - 1
                                ? ':' + newEventTypeParts[i]
                                : newEventTypeParts[i]
                                    .split('-')
                                    .map((value) => value.slice(0, 1).toUpperCase() + value.slice(1))
                                    .join('');
                    }
                    console.warn(`The event ${eventType.split('$')[0]} has been renamed to ${newEventType.split('$')[0]}.`);
                    eventType = newEventType;
                }
                if (modifierMatch) {
                    // Parse the event modifiers.
                    // Supported modifiers:
                    // - preventDefault
                    // - stopPropagation
                    // - passive
                    // - nonpassive
                    // - capture
                    // - once
                    const parts = eventType.split(oldModifierMatch ? ':' : '$');
                    eventType = parts[0];
                    const eventOptions = Object.fromEntries(parts.slice(1).map((mod) => [mod, true]));
                    if (eventOptions.passive) {
                        options = options || {};
                        options.passive = true;
                    }
                    if (eventOptions.nonpassive) {
                        options = options || {};
                        options.passive = false;
                    }
                    if (eventOptions.capture) {
                        options = options || {};
                        options.capture = true;
                    }
                    if (eventOptions.once) {
                        options = options || {};
                        options.once = true;
                    }
                    if (eventOptions.preventDefault) {
                        handler = prevent_default(handler);
                    }
                    if (eventOptions.stopPropagation) {
                        handler = stop_propagation(handler);
                    }
                }
                // Listen for the event directly, with the given options.
                const off = listen(node, eventType, handler, options);
                const destructor = () => {
                    off();
                    const idx = destructors.indexOf(destructor);
                    if (idx > -1) {
                        destructors.splice(idx, 1);
                    }
                };
                destructors.push(destructor);
                // Forward the event from Svelte.
                if (!(eventType in forwardDestructors)) {
                    forwardDestructors[eventType] = listen(node, eventType, forward);
                }
                return destructor;
            };
            for (let i = 0; i < events.length; i++) {
                // Listen to all the events added before mount.
                $on(events[i][0], events[i][1]);
            }
            return {
                destroy: () => {
                    // Remove all event listeners.
                    for (let i = 0; i < destructors.length; i++) {
                        destructors[i]();
                    }
                    // Remove all event forwarders.
                    for (let entry of Object.entries(forwardDestructors)) {
                        entry[1]();
                    }
                },
            };
        };
    }

    function prefixFilter(obj, prefix) {
        let names = Object.getOwnPropertyNames(obj);
        const newObj = {};
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            if (name.substring(0, prefix.length) === prefix) {
                newObj[name.substring(prefix.length)] = obj[name];
            }
        }
        return newObj;
    }

    function useActions(node, actions) {
        let actionReturns = [];
        if (actions) {
            for (let i = 0; i < actions.length; i++) {
                const actionEntry = actions[i];
                const action = Array.isArray(actionEntry) ? actionEntry[0] : actionEntry;
                if (Array.isArray(actionEntry) && actionEntry.length > 1) {
                    actionReturns.push(action(node, actionEntry[1]));
                }
                else {
                    actionReturns.push(action(node));
                }
            }
        }
        return {
            update(actions) {
                if (((actions && actions.length) || 0) != actionReturns.length) {
                    throw new Error('You must not change the length of an actions array.');
                }
                if (actions) {
                    for (let i = 0; i < actions.length; i++) {
                        const returnEntry = actionReturns[i];
                        if (returnEntry && returnEntry.update) {
                            const actionEntry = actions[i];
                            if (Array.isArray(actionEntry) && actionEntry.length > 1) {
                                returnEntry.update(actionEntry[1]);
                            }
                            else {
                                returnEntry.update();
                            }
                        }
                    }
                }
            },
            destroy() {
                for (let i = 0; i < actionReturns.length; i++) {
                    const returnEntry = actionReturns[i];
                    if (returnEntry && returnEntry.destroy) {
                        returnEntry.destroy();
                    }
                }
            },
        };
    }

    /* node_modules/@smui/common/dist/elements/Span.svelte generated by Svelte v3.47.0 */
    const file$a = "node_modules/@smui/common/dist/elements/Span.svelte";

    function create_fragment$c(ctx) {
    	let span;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let span_levels = [/*$$restProps*/ ctx[3]];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign$4(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[7](span);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[2].call(null, span))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			/*span_binding*/ ctx[7](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	const omit_props_names = ["use","getElement"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Span', slots, ['default']);
    	let { use = [] } = $$props;
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let element;

    	function getElement() {
    		return element;
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		useActions,
    		use,
    		forwardEvents,
    		element,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(1, element = $$new_props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		use,
    		element,
    		forwardEvents,
    		$$restProps,
    		getElement,
    		$$scope,
    		slots,
    		span_binding
    	];
    }

    class Span$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$8, create_fragment$c, safe_not_equal, { use: 0, getElement: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Span",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get use() {
    		throw new Error("<Span>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[4];
    	}

    	set getElement(value) {
    		throw new Error("<Span>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/common/dist/ContextFragment.svelte generated by Svelte v3.47.0 */

    function create_fragment$b(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $storeValue;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContextFragment', slots, ['default']);
    	let { key } = $$props;
    	let { value } = $$props;
    	const storeValue = writable(value);
    	validate_store(storeValue, 'storeValue');
    	component_subscribe($$self, storeValue, value => $$invalidate(5, $storeValue = value));
    	setContext(key, storeValue);

    	onDestroy(() => {
    		storeValue.set(undefined);
    	});

    	const writable_props = ['key', 'value'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContextFragment> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('key' in $$props) $$invalidate(1, key = $$props.key);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		setContext,
    		writable,
    		key,
    		value,
    		storeValue,
    		$storeValue
    	});

    	$$self.$inject_state = $$props => {
    		if ('key' in $$props) $$invalidate(1, key = $$props.key);
    		if ('value' in $$props) $$invalidate(2, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*value*/ 4) {
    			set_store_value(storeValue, $storeValue = value, $storeValue);
    		}
    	};

    	return [storeValue, key, value, $$scope, slots];
    }

    class ContextFragment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$7, create_fragment$b, safe_not_equal, { key: 1, value: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContextFragment",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*key*/ ctx[1] === undefined && !('key' in props)) {
    			console.warn("<ContextFragment> was created without expected prop 'key'");
    		}

    		if (/*value*/ ctx[2] === undefined && !('value' in props)) {
    			console.warn("<ContextFragment> was created without expected prop 'value'");
    		}
    	}

    	get key() {
    		throw new Error("<ContextFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<ContextFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<ContextFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ContextFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const { applyPassive } = events;
    const { matches } = ponyfill;
    function Ripple(node, { ripple = true, surface = false, unbounded = false, disabled = false, color, active, rippleElement, eventTarget, activeTarget, addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className), addStyle = (name, value) => node.style.setProperty(name, value), initPromise = Promise.resolve(), } = {}) {
        let instance;
        let addLayoutListener = getContext('SMUI:addLayoutListener');
        let removeLayoutListener;
        let oldActive = active;
        let oldEventTarget = eventTarget;
        let oldActiveTarget = activeTarget;
        function handleProps() {
            if (surface) {
                addClass('mdc-ripple-surface');
                if (color === 'primary') {
                    addClass('smui-ripple-surface--primary');
                    removeClass('smui-ripple-surface--secondary');
                }
                else if (color === 'secondary') {
                    removeClass('smui-ripple-surface--primary');
                    addClass('smui-ripple-surface--secondary');
                }
                else {
                    removeClass('smui-ripple-surface--primary');
                    removeClass('smui-ripple-surface--secondary');
                }
            }
            else {
                removeClass('mdc-ripple-surface');
                removeClass('smui-ripple-surface--primary');
                removeClass('smui-ripple-surface--secondary');
            }
            // Handle activation first.
            if (instance && oldActive !== active) {
                oldActive = active;
                if (active) {
                    instance.activate();
                }
                else if (active === false) {
                    instance.deactivate();
                }
            }
            // Then create/destroy an instance.
            if (ripple && !instance) {
                instance = new MDCRippleFoundation({
                    addClass,
                    browserSupportsCssVars: () => supportsCssVariables(window),
                    computeBoundingRect: () => (rippleElement || node).getBoundingClientRect(),
                    containsEventTarget: (target) => node.contains(target),
                    deregisterDocumentInteractionHandler: (evtType, handler) => document.documentElement.removeEventListener(evtType, handler, applyPassive()),
                    deregisterInteractionHandler: (evtType, handler) => (eventTarget || node).removeEventListener(evtType, handler, applyPassive()),
                    deregisterResizeHandler: (handler) => window.removeEventListener('resize', handler),
                    getWindowPageOffset: () => ({
                        x: window.pageXOffset,
                        y: window.pageYOffset,
                    }),
                    isSurfaceActive: () => active == null ? matches(activeTarget || node, ':active') : active,
                    isSurfaceDisabled: () => !!disabled,
                    isUnbounded: () => !!unbounded,
                    registerDocumentInteractionHandler: (evtType, handler) => document.documentElement.addEventListener(evtType, handler, applyPassive()),
                    registerInteractionHandler: (evtType, handler) => (eventTarget || node).addEventListener(evtType, handler, applyPassive()),
                    registerResizeHandler: (handler) => window.addEventListener('resize', handler),
                    removeClass,
                    updateCssVariable: addStyle,
                });
                initPromise.then(() => {
                    if (instance) {
                        instance.init();
                        instance.setUnbounded(unbounded);
                    }
                });
            }
            else if (instance && !ripple) {
                initPromise.then(() => {
                    if (instance) {
                        instance.destroy();
                        instance = undefined;
                    }
                });
            }
            // Now handle event/active targets
            if (instance &&
                (oldEventTarget !== eventTarget || oldActiveTarget !== activeTarget)) {
                oldEventTarget = eventTarget;
                oldActiveTarget = activeTarget;
                instance.destroy();
                requestAnimationFrame(() => {
                    if (instance) {
                        instance.init();
                        instance.setUnbounded(unbounded);
                    }
                });
            }
            if (!ripple && unbounded) {
                addClass('mdc-ripple-upgraded--unbounded');
            }
        }
        handleProps();
        if (addLayoutListener) {
            removeLayoutListener = addLayoutListener(layout);
        }
        function layout() {
            if (instance) {
                instance.layout();
            }
        }
        return {
            update(props) {
                ({
                    ripple,
                    surface,
                    unbounded,
                    disabled,
                    color,
                    active,
                    rippleElement,
                    eventTarget,
                    activeTarget,
                    addClass,
                    removeClass,
                    addStyle,
                    initPromise,
                } = Object.assign({ ripple: true, surface: false, unbounded: false, disabled: false, color: undefined, active: undefined, rippleElement: undefined, eventTarget: undefined, activeTarget: undefined, addClass: (className) => node.classList.add(className), removeClass: (className) => node.classList.remove(className), addStyle: (name, value) => node.style.setProperty(name, value), initPromise: Promise.resolve() }, props));
                handleProps();
            },
            destroy() {
                if (instance) {
                    instance.destroy();
                    instance = undefined;
                    removeClass('mdc-ripple-surface');
                    removeClass('smui-ripple-surface--primary');
                    removeClass('smui-ripple-surface--secondary');
                }
                if (removeLayoutListener) {
                    removeLayoutListener();
                }
            },
        };
    }

    /* node_modules/@smui/floating-label/dist/FloatingLabel.svelte generated by Svelte v3.47.0 */

    const file$9 = "node_modules/@smui/floating-label/dist/FloatingLabel.svelte";

    // (19:0) {:else}
    function create_else_block$2(ctx) {
    	let label;
    	let label_class_value;
    	let label_style_value;
    	let label_for_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

    	let label_levels = [
    		{
    			class: label_class_value = classMap({
    				[/*className*/ ctx[3]]: true,
    				'mdc-floating-label': true,
    				'mdc-floating-label--float-above': /*floatAbove*/ ctx[0],
    				'mdc-floating-label--required': /*required*/ ctx[1],
    				.../*internalClasses*/ ctx[8]
    			})
    		},
    		{
    			style: label_style_value = Object.entries(/*internalStyles*/ ctx[9]).map(func_1$1).concat([/*style*/ ctx[4]]).join(' ')
    		},
    		{
    			for: label_for_value = /*forId*/ ctx[5] || (/*inputProps*/ ctx[11]
    			? /*inputProps*/ ctx[11].id
    			: undefined)
    		},
    		/*$$restProps*/ ctx[12]
    	];

    	let label_data = {};

    	for (let i = 0; i < label_levels.length; i += 1) {
    		label_data = assign$4(label_data, label_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			if (default_slot) default_slot.c();
    			set_attributes(label, label_data);
    			add_location(label, file$9, 19, 2, 494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);

    			if (default_slot) {
    				default_slot.m(label, null);
    			}

    			/*label_binding*/ ctx[24](label);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, label, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[10].call(null, label))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[21],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(label, label_data = get_spread_update(label_levels, [
    				(!current || dirty & /*className, floatAbove, required, internalClasses*/ 267 && label_class_value !== (label_class_value = classMap({
    					[/*className*/ ctx[3]]: true,
    					'mdc-floating-label': true,
    					'mdc-floating-label--float-above': /*floatAbove*/ ctx[0],
    					'mdc-floating-label--required': /*required*/ ctx[1],
    					.../*internalClasses*/ ctx[8]
    				}))) && { class: label_class_value },
    				(!current || dirty & /*internalStyles, style*/ 528 && label_style_value !== (label_style_value = Object.entries(/*internalStyles*/ ctx[9]).map(func_1$1).concat([/*style*/ ctx[4]]).join(' '))) && { style: label_style_value },
    				(!current || dirty & /*forId*/ 32 && label_for_value !== (label_for_value = /*forId*/ ctx[5] || (/*inputProps*/ ctx[11]
    				? /*inputProps*/ ctx[11].id
    				: undefined))) && { for: label_for_value },
    				dirty & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (default_slot) default_slot.d(detaching);
    			/*label_binding*/ ctx[24](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(19:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if wrapped}
    function create_if_block$4(ctx) {
    	let span;
    	let span_class_value;
    	let span_style_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

    	let span_levels = [
    		{
    			class: span_class_value = classMap({
    				[/*className*/ ctx[3]]: true,
    				'mdc-floating-label': true,
    				'mdc-floating-label--float-above': /*floatAbove*/ ctx[0],
    				'mdc-floating-label--required': /*required*/ ctx[1],
    				.../*internalClasses*/ ctx[8]
    			})
    		},
    		{
    			style: span_style_value = Object.entries(/*internalStyles*/ ctx[9]).map(func$3).concat([/*style*/ ctx[4]]).join(' ')
    		},
    		/*$$restProps*/ ctx[12]
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign$4(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			add_location(span, file$9, 1, 2, 16);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			/*span_binding*/ ctx[23](span);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, span, /*use*/ ctx[2])),
    					action_destroyer(/*forwardEvents*/ ctx[10].call(null, span))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[21],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				(!current || dirty & /*className, floatAbove, required, internalClasses*/ 267 && span_class_value !== (span_class_value = classMap({
    					[/*className*/ ctx[3]]: true,
    					'mdc-floating-label': true,
    					'mdc-floating-label--float-above': /*floatAbove*/ ctx[0],
    					'mdc-floating-label--required': /*required*/ ctx[1],
    					.../*internalClasses*/ ctx[8]
    				}))) && { class: span_class_value },
    				(!current || dirty & /*internalStyles, style*/ 528 && span_style_value !== (span_style_value = Object.entries(/*internalStyles*/ ctx[9]).map(func$3).concat([/*style*/ ctx[4]]).join(' '))) && { style: span_style_value },
    				dirty & /*$$restProps*/ 4096 && /*$$restProps*/ ctx[12]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 4) useActions_action.update.call(null, /*use*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			/*span_binding*/ ctx[23](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(1:0) {#if wrapped}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$4, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*wrapped*/ ctx[6]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$3 = ([name, value]) => `${name}: ${value};`;
    const func_1$1 = ([name, value]) => `${name}: ${value};`;

    function instance_1$3($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"use","class","style","for","floatAbove","required","wrapped","shake","float","setRequired","getWidth","getElement"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FloatingLabel', slots, ['default']);
    	var _a;
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { style = '' } = $$props;
    	let { for: forId = undefined } = $$props;
    	let { floatAbove = false } = $$props;
    	let { required = false } = $$props;
    	let { wrapped = false } = $$props;
    	let element;
    	let instance;
    	let internalClasses = {};
    	let internalStyles = {};

    	let inputProps = (_a = getContext('SMUI:generic:input:props')) !== null && _a !== void 0
    	? _a
    	: {};

    	let previousFloatAbove = floatAbove;
    	let previousRequired = required;

    	onMount(() => {
    		$$invalidate(18, instance = new MDCFloatingLabelFoundation({
    				addClass,
    				removeClass,
    				getWidth: () => {
    					var _a, _b;
    					const el = getElement();
    					const clone = el.cloneNode(true);

    					(_a = el.parentNode) === null || _a === void 0
    					? void 0
    					: _a.appendChild(clone);

    					clone.classList.add('smui-floating-label--remove-transition');
    					clone.classList.add('smui-floating-label--force-size');
    					clone.classList.remove('mdc-floating-label--float-above');
    					const scrollWidth = clone.scrollWidth;

    					(_b = el.parentNode) === null || _b === void 0
    					? void 0
    					: _b.removeChild(clone);

    					return scrollWidth;
    				},
    				registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
    				deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    			}));

    		const accessor = {
    			get element() {
    				return getElement();
    			},
    			addStyle,
    			removeStyle
    		};

    		dispatch(element, 'SMUIFloatingLabel:mount', accessor);
    		instance.init();

    		return () => {
    			dispatch(element, 'SMUIFloatingLabel:unmount', accessor);
    			instance.destroy();
    		};
    	});

    	function addClass(className) {
    		if (!internalClasses[className]) {
    			$$invalidate(8, internalClasses[className] = true, internalClasses);
    		}
    	}

    	function removeClass(className) {
    		if (!(className in internalClasses) || internalClasses[className]) {
    			$$invalidate(8, internalClasses[className] = false, internalClasses);
    		}
    	}

    	function addStyle(name, value) {
    		if (internalStyles[name] != value) {
    			if (value === '' || value == null) {
    				delete internalStyles[name];
    				$$invalidate(9, internalStyles);
    			} else {
    				$$invalidate(9, internalStyles[name] = value, internalStyles);
    			}
    		}
    	}

    	function removeStyle(name) {
    		if (name in internalStyles) {
    			delete internalStyles[name];
    			$$invalidate(9, internalStyles);
    		}
    	}

    	function shake(shouldShake) {
    		instance.shake(shouldShake);
    	}

    	function float(shouldFloat) {
    		$$invalidate(0, floatAbove = shouldFloat);
    	}

    	function setRequired(isRequired) {
    		$$invalidate(1, required = isRequired);
    	}

    	function getWidth() {
    		return instance.getWidth();
    	}

    	function getElement() {
    		return element;
    	}

    	function span_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	function label_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(7, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(2, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(3, className = $$new_props.class);
    		if ('style' in $$new_props) $$invalidate(4, style = $$new_props.style);
    		if ('for' in $$new_props) $$invalidate(5, forId = $$new_props.for);
    		if ('floatAbove' in $$new_props) $$invalidate(0, floatAbove = $$new_props.floatAbove);
    		if ('required' in $$new_props) $$invalidate(1, required = $$new_props.required);
    		if ('wrapped' in $$new_props) $$invalidate(6, wrapped = $$new_props.wrapped);
    		if ('$$scope' in $$new_props) $$invalidate(21, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		_a,
    		MDCFloatingLabelFoundation,
    		onMount,
    		getContext,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		useActions,
    		dispatch,
    		forwardEvents,
    		use,
    		className,
    		style,
    		forId,
    		floatAbove,
    		required,
    		wrapped,
    		element,
    		instance,
    		internalClasses,
    		internalStyles,
    		inputProps,
    		previousFloatAbove,
    		previousRequired,
    		addClass,
    		removeClass,
    		addStyle,
    		removeStyle,
    		shake,
    		float,
    		setRequired,
    		getWidth,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('_a' in $$props) _a = $$new_props._a;
    		if ('use' in $$props) $$invalidate(2, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(3, className = $$new_props.className);
    		if ('style' in $$props) $$invalidate(4, style = $$new_props.style);
    		if ('forId' in $$props) $$invalidate(5, forId = $$new_props.forId);
    		if ('floatAbove' in $$props) $$invalidate(0, floatAbove = $$new_props.floatAbove);
    		if ('required' in $$props) $$invalidate(1, required = $$new_props.required);
    		if ('wrapped' in $$props) $$invalidate(6, wrapped = $$new_props.wrapped);
    		if ('element' in $$props) $$invalidate(7, element = $$new_props.element);
    		if ('instance' in $$props) $$invalidate(18, instance = $$new_props.instance);
    		if ('internalClasses' in $$props) $$invalidate(8, internalClasses = $$new_props.internalClasses);
    		if ('internalStyles' in $$props) $$invalidate(9, internalStyles = $$new_props.internalStyles);
    		if ('inputProps' in $$props) $$invalidate(11, inputProps = $$new_props.inputProps);
    		if ('previousFloatAbove' in $$props) $$invalidate(19, previousFloatAbove = $$new_props.previousFloatAbove);
    		if ('previousRequired' in $$props) $$invalidate(20, previousRequired = $$new_props.previousRequired);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*instance, previousFloatAbove, floatAbove*/ 786433) {
    			if (instance && previousFloatAbove !== floatAbove) {
    				$$invalidate(19, previousFloatAbove = floatAbove);
    				instance.float(floatAbove);
    			}
    		}

    		if ($$self.$$.dirty & /*instance, previousRequired, required*/ 1310722) {
    			if (instance && previousRequired !== required) {
    				$$invalidate(20, previousRequired = required);
    				instance.setRequired(required);
    			}
    		}
    	};

    	return [
    		floatAbove,
    		required,
    		use,
    		className,
    		style,
    		forId,
    		wrapped,
    		element,
    		internalClasses,
    		internalStyles,
    		forwardEvents,
    		inputProps,
    		$$restProps,
    		shake,
    		float,
    		setRequired,
    		getWidth,
    		getElement,
    		instance,
    		previousFloatAbove,
    		previousRequired,
    		$$scope,
    		slots,
    		span_binding,
    		label_binding
    	];
    }

    class FloatingLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance_1$3, create_fragment$a, safe_not_equal, {
    			use: 2,
    			class: 3,
    			style: 4,
    			for: 5,
    			floatAbove: 0,
    			required: 1,
    			wrapped: 6,
    			shake: 13,
    			float: 14,
    			setRequired: 15,
    			getWidth: 16,
    			getElement: 17
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FloatingLabel",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get use() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get for() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set for(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get floatAbove() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set floatAbove(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get wrapped() {
    		throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wrapped(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shake() {
    		return this.$$.ctx[13];
    	}

    	set shake(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get float() {
    		return this.$$.ctx[14];
    	}

    	set float(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setRequired() {
    		return this.$$.ctx[15];
    	}

    	set setRequired(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getWidth() {
    		return this.$$.ctx[16];
    	}

    	set getWidth(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[17];
    	}

    	set getElement(value) {
    		throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/line-ripple/dist/LineRipple.svelte generated by Svelte v3.47.0 */
    const file$8 = "node_modules/@smui/line-ripple/dist/LineRipple.svelte";

    function create_fragment$9(ctx) {
    	let div;
    	let div_class_value;
    	let div_style_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let div_levels = [
    		{
    			class: div_class_value = classMap({
    				[/*className*/ ctx[1]]: true,
    				'mdc-line-ripple': true,
    				'mdc-line-ripple--active': /*active*/ ctx[3],
    				.../*internalClasses*/ ctx[5]
    			})
    		},
    		{
    			style: div_style_value = Object.entries(/*internalStyles*/ ctx[6]).map(func$2).concat([/*style*/ ctx[2]]).join(' ')
    		},
    		/*$$restProps*/ ctx[8]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$4(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_attributes(div, div_data);
    			add_location(div, file$8, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[13](div);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*className, active, internalClasses*/ 42 && div_class_value !== (div_class_value = classMap({
    					[/*className*/ ctx[1]]: true,
    					'mdc-line-ripple': true,
    					'mdc-line-ripple--active': /*active*/ ctx[3],
    					.../*internalClasses*/ ctx[5]
    				})) && { class: div_class_value },
    				dirty & /*internalStyles, style*/ 68 && div_style_value !== (div_style_value = Object.entries(/*internalStyles*/ ctx[6]).map(func$2).concat([/*style*/ ctx[2]]).join(' ')) && { style: div_style_value },
    				dirty & /*$$restProps*/ 256 && /*$$restProps*/ ctx[8]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[13](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$2 = ([name, value]) => `${name}: ${value};`;

    function instance_1$2($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"use","class","style","active","activate","deactivate","setRippleCenter","getElement"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LineRipple', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { style = '' } = $$props;
    	let { active = false } = $$props;
    	let element;
    	let instance;
    	let internalClasses = {};
    	let internalStyles = {};

    	onMount(() => {
    		instance = new MDCLineRippleFoundation({
    				addClass,
    				removeClass,
    				hasClass,
    				setStyle: addStyle,
    				registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
    				deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    			});

    		instance.init();

    		return () => {
    			instance.destroy();
    		};
    	});

    	function hasClass(className) {
    		return className in internalClasses
    		? internalClasses[className]
    		: getElement().classList.contains(className);
    	}

    	function addClass(className) {
    		if (!internalClasses[className]) {
    			$$invalidate(5, internalClasses[className] = true, internalClasses);
    		}
    	}

    	function removeClass(className) {
    		if (!(className in internalClasses) || internalClasses[className]) {
    			$$invalidate(5, internalClasses[className] = false, internalClasses);
    		}
    	}

    	function addStyle(name, value) {
    		if (internalStyles[name] != value) {
    			if (value === '' || value == null) {
    				delete internalStyles[name];
    				$$invalidate(6, internalStyles);
    			} else {
    				$$invalidate(6, internalStyles[name] = value, internalStyles);
    			}
    		}
    	}

    	function activate() {
    		instance.activate();
    	}

    	function deactivate() {
    		instance.deactivate();
    	}

    	function setRippleCenter(xCoordinate) {
    		instance.setRippleCenter(xCoordinate);
    	}

    	function getElement() {
    		return element;
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('style' in $$new_props) $$invalidate(2, style = $$new_props.style);
    		if ('active' in $$new_props) $$invalidate(3, active = $$new_props.active);
    	};

    	$$self.$capture_state = () => ({
    		MDCLineRippleFoundation,
    		onMount,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		style,
    		active,
    		element,
    		instance,
    		internalClasses,
    		internalStyles,
    		hasClass,
    		addClass,
    		removeClass,
    		addStyle,
    		activate,
    		deactivate,
    		setRippleCenter,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('style' in $$props) $$invalidate(2, style = $$new_props.style);
    		if ('active' in $$props) $$invalidate(3, active = $$new_props.active);
    		if ('element' in $$props) $$invalidate(4, element = $$new_props.element);
    		if ('instance' in $$props) instance = $$new_props.instance;
    		if ('internalClasses' in $$props) $$invalidate(5, internalClasses = $$new_props.internalClasses);
    		if ('internalStyles' in $$props) $$invalidate(6, internalStyles = $$new_props.internalStyles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		use,
    		className,
    		style,
    		active,
    		element,
    		internalClasses,
    		internalStyles,
    		forwardEvents,
    		$$restProps,
    		activate,
    		deactivate,
    		setRippleCenter,
    		getElement,
    		div_binding
    	];
    }

    class LineRipple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance_1$2, create_fragment$9, safe_not_equal, {
    			use: 0,
    			class: 1,
    			style: 2,
    			active: 3,
    			activate: 9,
    			deactivate: 10,
    			setRippleCenter: 11,
    			getElement: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineRipple",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get use() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get active() {
    		throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activate() {
    		return this.$$.ctx[9];
    	}

    	set activate(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get deactivate() {
    		return this.$$.ctx[10];
    	}

    	set deactivate(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setRippleCenter() {
    		return this.$$.ctx[11];
    	}

    	set setRippleCenter(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[12];
    	}

    	set getElement(value) {
    		throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/notched-outline/dist/NotchedOutline.svelte generated by Svelte v3.47.0 */
    const file$7 = "node_modules/@smui/notched-outline/dist/NotchedOutline.svelte";

    // (17:2) {#if !noLabel}
    function create_if_block$3(ctx) {
    	let div;
    	let div_style_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[14].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "mdc-notched-outline__notch");
    			attr_dev(div, "style", div_style_value = Object.entries(/*notchStyles*/ ctx[7]).map(func$1).join(' '));
    			add_location(div, file$7, 17, 4, 496);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*notchStyles*/ 128 && div_style_value !== (div_style_value = Object.entries(/*notchStyles*/ ctx[7]).map(func$1).join(' '))) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(17:2) {#if !noLabel}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let div2_class_value;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = !/*noLabel*/ ctx[3] && create_if_block$3(ctx);

    	let div2_levels = [
    		{
    			class: div2_class_value = classMap({
    				[/*className*/ ctx[1]]: true,
    				'mdc-notched-outline': true,
    				'mdc-notched-outline--notched': /*notched*/ ctx[2],
    				'mdc-notched-outline--no-label': /*noLabel*/ ctx[3],
    				.../*internalClasses*/ ctx[6]
    			})
    		},
    		/*$$restProps*/ ctx[9]
    	];

    	let div2_data = {};

    	for (let i = 0; i < div2_levels.length; i += 1) {
    		div2_data = assign$4(div2_data, div2_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "mdc-notched-outline__leading");
    			add_location(div0, file$7, 15, 2, 430);
    			attr_dev(div1, "class", "mdc-notched-outline__trailing");
    			add_location(div1, file$7, 26, 2, 699);
    			set_attributes(div2, div2_data);
    			add_location(div2, file$7, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			if (if_block) if_block.m(div2, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			/*div2_binding*/ ctx[15](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div2, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[8].call(null, div2)),
    					listen_dev(div2, "SMUIFloatingLabel:mount", /*SMUIFloatingLabel_mount_handler*/ ctx[16], false, false, false),
    					listen_dev(div2, "SMUIFloatingLabel:unmount", /*SMUIFloatingLabel_unmount_handler*/ ctx[17], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*noLabel*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*noLabel*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div2, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			set_attributes(div2, div2_data = get_spread_update(div2_levels, [
    				(!current || dirty & /*className, notched, noLabel, internalClasses*/ 78 && div2_class_value !== (div2_class_value = classMap({
    					[/*className*/ ctx[1]]: true,
    					'mdc-notched-outline': true,
    					'mdc-notched-outline--notched': /*notched*/ ctx[2],
    					'mdc-notched-outline--no-label': /*noLabel*/ ctx[3],
    					.../*internalClasses*/ ctx[6]
    				}))) && { class: div2_class_value },
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			/*div2_binding*/ ctx[15](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = ([name, value]) => `${name}: ${value};`;

    function instance_1$1($$self, $$props, $$invalidate) {
    	const omit_props_names = ["use","class","notched","noLabel","notch","closeNotch","getElement"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NotchedOutline', slots, ['default']);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { notched = false } = $$props;
    	let { noLabel = false } = $$props;
    	let element;
    	let instance;
    	let floatingLabel;
    	let internalClasses = {};
    	let notchStyles = {};

    	onMount(() => {
    		instance = new MDCNotchedOutlineFoundation({
    				addClass,
    				removeClass,
    				setNotchWidthProperty: width => addNotchStyle('width', width + 'px'),
    				removeNotchWidthProperty: () => removeNotchStyle('width')
    			});

    		instance.init();

    		return () => {
    			instance.destroy();
    		};
    	});

    	function addClass(className) {
    		if (!internalClasses[className]) {
    			$$invalidate(6, internalClasses[className] = true, internalClasses);
    		}
    	}

    	function removeClass(className) {
    		if (!(className in internalClasses) || internalClasses[className]) {
    			$$invalidate(6, internalClasses[className] = false, internalClasses);
    		}
    	}

    	function addNotchStyle(name, value) {
    		if (notchStyles[name] != value) {
    			if (value === '' || value == null) {
    				delete notchStyles[name];
    				$$invalidate(7, notchStyles);
    			} else {
    				$$invalidate(7, notchStyles[name] = value, notchStyles);
    			}
    		}
    	}

    	function removeNotchStyle(name) {
    		if (name in notchStyles) {
    			delete notchStyles[name];
    			$$invalidate(7, notchStyles);
    		}
    	}

    	function notch(notchWidth) {
    		instance.notch(notchWidth);
    	}

    	function closeNotch() {
    		instance.closeNotch();
    	}

    	function getElement() {
    		return element;
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(5, element);
    		});
    	}

    	const SMUIFloatingLabel_mount_handler = event => $$invalidate(4, floatingLabel = event.detail);
    	const SMUIFloatingLabel_unmount_handler = () => $$invalidate(4, floatingLabel = undefined);

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('notched' in $$new_props) $$invalidate(2, notched = $$new_props.notched);
    		if ('noLabel' in $$new_props) $$invalidate(3, noLabel = $$new_props.noLabel);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCNotchedOutlineFoundation,
    		onMount,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		notched,
    		noLabel,
    		element,
    		instance,
    		floatingLabel,
    		internalClasses,
    		notchStyles,
    		addClass,
    		removeClass,
    		addNotchStyle,
    		removeNotchStyle,
    		notch,
    		closeNotch,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('notched' in $$props) $$invalidate(2, notched = $$new_props.notched);
    		if ('noLabel' in $$props) $$invalidate(3, noLabel = $$new_props.noLabel);
    		if ('element' in $$props) $$invalidate(5, element = $$new_props.element);
    		if ('instance' in $$props) instance = $$new_props.instance;
    		if ('floatingLabel' in $$props) $$invalidate(4, floatingLabel = $$new_props.floatingLabel);
    		if ('internalClasses' in $$props) $$invalidate(6, internalClasses = $$new_props.internalClasses);
    		if ('notchStyles' in $$props) $$invalidate(7, notchStyles = $$new_props.notchStyles);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*floatingLabel*/ 16) {
    			if (floatingLabel) {
    				floatingLabel.addStyle('transition-duration', '0s');
    				addClass('mdc-notched-outline--upgraded');

    				requestAnimationFrame(() => {
    					if (floatingLabel) {
    						floatingLabel.removeStyle('transition-duration');
    					}
    				});
    			} else {
    				removeClass('mdc-notched-outline--upgraded');
    			}
    		}
    	};

    	return [
    		use,
    		className,
    		notched,
    		noLabel,
    		floatingLabel,
    		element,
    		internalClasses,
    		notchStyles,
    		forwardEvents,
    		$$restProps,
    		notch,
    		closeNotch,
    		getElement,
    		$$scope,
    		slots,
    		div2_binding,
    		SMUIFloatingLabel_mount_handler,
    		SMUIFloatingLabel_unmount_handler
    	];
    }

    class NotchedOutline extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance_1$1, create_fragment$8, safe_not_equal, {
    			use: 0,
    			class: 1,
    			notched: 2,
    			noLabel: 3,
    			notch: 10,
    			closeNotch: 11,
    			getElement: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotchedOutline",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get use() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notched() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notched(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLabel() {
    		throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLabel(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notch() {
    		return this.$$.ctx[10];
    	}

    	set notch(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get closeNotch() {
    		return this.$$.ctx[11];
    	}

    	set closeNotch(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[12];
    	}

    	set getElement(value) {
    		throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/common/dist/elements/Div.svelte generated by Svelte v3.47.0 */
    const file$6 = "node_modules/@smui/common/dist/elements/Div.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let div_levels = [/*$$restProps*/ ctx[3]];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$4(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$6, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[7](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[2].call(null, div))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[7](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	const omit_props_names = ["use","getElement"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Div', slots, ['default']);
    	let { use = [] } = $$props;
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let element;

    	function getElement() {
    		return element;
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(1, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('$$scope' in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		get_current_component,
    		forwardEventsBuilder,
    		useActions,
    		use,
    		forwardEvents,
    		element,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('element' in $$props) $$invalidate(1, element = $$new_props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		use,
    		element,
    		forwardEvents,
    		$$restProps,
    		getElement,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Div$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$6, create_fragment$7, safe_not_equal, { use: 0, getElement: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Div",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get use() {
    		throw new Error("<Div>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[4];
    	}

    	set getElement(value) {
    		throw new Error("<Div>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/common/dist/classadder/ClassAdder.svelte generated by Svelte v3.47.0 */

    // (1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>
    function create_default_slot$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[12],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(1:0) <svelte:component   this={component}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [smuiClass]: true,     ...smuiClassMap,   })}   {...props}   {...$$restProps}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{
    			use: [/*forwardEvents*/ ctx[7], .../*use*/ ctx[0]]
    		},
    		{
    			class: classMap({
    				[/*className*/ ctx[1]]: true,
    				[/*smuiClass*/ ctx[5]]: true,
    				.../*smuiClassMap*/ ctx[4]
    			})
    		},
    		/*props*/ ctx[6],
    		/*$$restProps*/ ctx[8]
    	];

    	var switch_value = /*component*/ ctx[2];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			$$slots: { default: [create_default_slot$2] },
    			$$scope: { ctx }
    		};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$4(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		/*switch_instance_binding*/ ctx[11](switch_instance);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*forwardEvents, use, classMap, className, smuiClass, smuiClassMap, props, $$restProps*/ 499)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*forwardEvents, use*/ 129 && {
    						use: [/*forwardEvents*/ ctx[7], .../*use*/ ctx[0]]
    					},
    					dirty & /*classMap, className, smuiClass, smuiClassMap*/ 50 && {
    						class: classMap({
    							[/*className*/ ctx[1]]: true,
    							[/*smuiClass*/ ctx[5]]: true,
    							.../*smuiClassMap*/ ctx[4]
    						})
    					},
    					dirty & /*props*/ 64 && get_spread_object(/*props*/ ctx[6]),
    					dirty & /*$$restProps*/ 256 && get_spread_object(/*$$restProps*/ ctx[8])
    				])
    			: {};

    			if (dirty & /*$$scope*/ 4096) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*component*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					/*switch_instance_binding*/ ctx[11](switch_instance);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*switch_instance_binding*/ ctx[11](null);
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const internals = {
    	component: Div$1,
    	class: '',
    	classMap: {},
    	contexts: {},
    	props: {}
    };

    function instance$5($$self, $$props, $$invalidate) {
    	const omit_props_names = ["use","class","component","getElement"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ClassAdder', slots, ['default']);
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let element;
    	const smuiClass = internals.class;
    	const smuiClassMap = {};
    	const smuiClassUnsubscribes = [];
    	const contexts = internals.contexts;
    	const props = internals.props;
    	let { component = internals.component } = $$props;

    	Object.entries(internals.classMap).forEach(([name, context]) => {
    		const store = getContext(context);

    		if (store && 'subscribe' in store) {
    			smuiClassUnsubscribes.push(store.subscribe(value => {
    				$$invalidate(4, smuiClassMap[name] = value, smuiClassMap);
    			}));
    		}
    	});

    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	for (let context in contexts) {
    		if (contexts.hasOwnProperty(context)) {
    			setContext(context, contexts[context]);
    		}
    	}

    	onDestroy(() => {
    		for (const unsubscribe of smuiClassUnsubscribes) {
    			unsubscribe();
    		}
    	});

    	function getElement() {
    		return element.getElement();
    	}

    	function switch_instance_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(3, element);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('component' in $$new_props) $$invalidate(2, component = $$new_props.component);
    		if ('$$scope' in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Div: Div$1,
    		internals,
    		onDestroy,
    		getContext,
    		setContext,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		use,
    		className,
    		element,
    		smuiClass,
    		smuiClassMap,
    		smuiClassUnsubscribes,
    		contexts,
    		props,
    		component,
    		forwardEvents,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('element' in $$props) $$invalidate(3, element = $$new_props.element);
    		if ('component' in $$props) $$invalidate(2, component = $$new_props.component);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		use,
    		className,
    		component,
    		element,
    		smuiClassMap,
    		smuiClass,
    		props,
    		forwardEvents,
    		$$restProps,
    		getElement,
    		slots,
    		switch_instance_binding,
    		$$scope
    	];
    }

    class ClassAdder extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$5, create_fragment$6, safe_not_equal, {
    			use: 0,
    			class: 1,
    			component: 2,
    			getElement: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClassAdder",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get use() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<ClassAdder>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[9];
    	}

    	set getElement(value) {
    		throw new Error("<ClassAdder>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // @ts-ignore: Internals is exported... argh.
    const defaults = Object.assign({}, internals);
    function classAdderBuilder(props) {
        return new Proxy(ClassAdder, {
            construct: function (target, args) {
                Object.assign(internals, defaults, props);
                // @ts-ignore: Need spread arg.
                return new target(...args);
            },
            get: function (target, prop) {
                Object.assign(internals, defaults, props);
                return target[prop];
            },
        });
    }

    const Div = Div$1;
    const Span = Span$1;

    var HelperLine = classAdderBuilder({
        class: 'mdc-text-field-helper-line',
        component: Div,
    });

    var Prefix = classAdderBuilder({
        class: 'mdc-text-field__affix mdc-text-field__affix--prefix',
        component: Span,
    });

    var Suffix = classAdderBuilder({
        class: 'mdc-text-field__affix mdc-text-field__affix--suffix',
        component: Span,
    });

    /* node_modules/@smui/textfield/dist/Input.svelte generated by Svelte v3.47.0 */
    const file$5 = "node_modules/@smui/textfield/dist/Input.svelte";

    function create_fragment$5(ctx) {
    	let input;
    	let input_class_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let input_levels = [
    		{
    			class: input_class_value = classMap({
    				[/*className*/ ctx[1]]: true,
    				'mdc-text-field__input': true
    			})
    		},
    		{ type: /*type*/ ctx[2] },
    		{ placeholder: /*placeholder*/ ctx[3] },
    		/*valueProp*/ ctx[4],
    		/*internalAttrs*/ ctx[6],
    		/*$$restProps*/ ctx[10]
    	];

    	let input_data = {};

    	for (let i = 0; i < input_levels.length; i += 1) {
    		input_data = assign$4(input_data, input_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input = element("input");
    			set_attributes(input, input_data);
    			add_location(input, file$5, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			if (input.autofocus) input.focus();
    			/*input_binding*/ ctx[26](input);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, input, /*use*/ ctx[0])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, input)),
    					listen_dev(input, "input", /*input_handler*/ ctx[27], false, false, false),
    					listen_dev(input, "change", /*changeHandler*/ ctx[9], false, false, false),
    					listen_dev(input, "blur", /*blur_handler*/ ctx[24], false, false, false),
    					listen_dev(input, "focus", /*focus_handler*/ ctx[25], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(input, input_data = get_spread_update(input_levels, [
    				dirty & /*className*/ 2 && input_class_value !== (input_class_value = classMap({
    					[/*className*/ ctx[1]]: true,
    					'mdc-text-field__input': true
    				})) && { class: input_class_value },
    				dirty & /*type*/ 4 && { type: /*type*/ ctx[2] },
    				dirty & /*placeholder*/ 8 && { placeholder: /*placeholder*/ ctx[3] },
    				dirty & /*valueProp*/ 16 && /*valueProp*/ ctx[4],
    				dirty & /*internalAttrs*/ 64 && /*internalAttrs*/ ctx[6],
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 1) useActions_action.update.call(null, /*use*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*input_binding*/ ctx[26](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function toNumber(value) {
    	if (value === '') {
    		const nan = new Number(Number.NaN);
    		nan.length = 0;
    		return nan;
    	}

    	return +value;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"use","class","type","placeholder","value","files","dirty","invalid","updateInvalid","emptyValueNull","emptyValueUndefined","getAttr","addAttr","removeAttr","focus","blur","getElement"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Input', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	let uninitializedValue = () => {
    		
    	};

    	function isUninitializedValue(value) {
    		return value === uninitializedValue;
    	}

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { type = 'text' } = $$props;
    	let { placeholder = ' ' } = $$props;
    	let { value = uninitializedValue } = $$props;
    	const valueUninitialized = isUninitializedValue(value);

    	if (valueUninitialized) {
    		value = '';
    	}

    	let { files = null } = $$props;
    	let { dirty = false } = $$props;
    	let { invalid = false } = $$props;
    	let { updateInvalid = true } = $$props;
    	let { emptyValueNull = value === null } = $$props;

    	if (valueUninitialized && emptyValueNull) {
    		value = null;
    	}

    	let { emptyValueUndefined = value === undefined } = $$props;

    	if (valueUninitialized && emptyValueUndefined) {
    		value = undefined;
    	}

    	let element;
    	let internalAttrs = {};
    	let valueProp = {};

    	onMount(() => {
    		if (updateInvalid) {
    			$$invalidate(14, invalid = element.matches(':invalid'));
    		}
    	});

    	function valueUpdater(e) {
    		if (type === 'file') {
    			$$invalidate(12, files = e.currentTarget.files);
    			return;
    		}

    		if (e.currentTarget.value === '' && emptyValueNull) {
    			$$invalidate(11, value = null);
    			return;
    		}

    		if (e.currentTarget.value === '' && emptyValueUndefined) {
    			$$invalidate(11, value = undefined);
    			return;
    		}

    		switch (type) {
    			case 'number':
    			case 'range':
    				$$invalidate(11, value = toNumber(e.currentTarget.value));
    				break;
    			default:
    				$$invalidate(11, value = e.currentTarget.value);
    				break;
    		}
    	}

    	function changeHandler(e) {
    		if (type === 'file' || type === 'range') {
    			valueUpdater(e);
    		}

    		$$invalidate(13, dirty = true);

    		if (updateInvalid) {
    			$$invalidate(14, invalid = element.matches(':invalid'));
    		}
    	}

    	function getAttr(name) {
    		var _a;

    		return name in internalAttrs
    		? (_a = internalAttrs[name]) !== null && _a !== void 0
    			? _a
    			: null
    		: getElement().getAttribute(name);
    	}

    	function addAttr(name, value) {
    		if (internalAttrs[name] !== value) {
    			$$invalidate(6, internalAttrs[name] = value, internalAttrs);
    		}
    	}

    	function removeAttr(name) {
    		if (!(name in internalAttrs) || internalAttrs[name] != null) {
    			$$invalidate(6, internalAttrs[name] = undefined, internalAttrs);
    		}
    	}

    	function focus() {
    		getElement().focus();
    	}

    	function blur() {
    		getElement().blur();
    	}

    	function getElement() {
    		return element;
    	}

    	function blur_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(5, element);
    		});
    	}

    	const input_handler = e => type !== 'file' && valueUpdater(e);

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(0, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(1, className = $$new_props.class);
    		if ('type' in $$new_props) $$invalidate(2, type = $$new_props.type);
    		if ('placeholder' in $$new_props) $$invalidate(3, placeholder = $$new_props.placeholder);
    		if ('value' in $$new_props) $$invalidate(11, value = $$new_props.value);
    		if ('files' in $$new_props) $$invalidate(12, files = $$new_props.files);
    		if ('dirty' in $$new_props) $$invalidate(13, dirty = $$new_props.dirty);
    		if ('invalid' in $$new_props) $$invalidate(14, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    		if ('emptyValueNull' in $$new_props) $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    		if ('emptyValueUndefined' in $$new_props) $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		useActions,
    		forwardEvents,
    		uninitializedValue,
    		isUninitializedValue,
    		use,
    		className,
    		type,
    		placeholder,
    		value,
    		valueUninitialized,
    		files,
    		dirty,
    		invalid,
    		updateInvalid,
    		emptyValueNull,
    		emptyValueUndefined,
    		element,
    		internalAttrs,
    		valueProp,
    		toNumber,
    		valueUpdater,
    		changeHandler,
    		getAttr,
    		addAttr,
    		removeAttr,
    		focus,
    		blur,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('uninitializedValue' in $$props) uninitializedValue = $$new_props.uninitializedValue;
    		if ('use' in $$props) $$invalidate(0, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(1, className = $$new_props.className);
    		if ('type' in $$props) $$invalidate(2, type = $$new_props.type);
    		if ('placeholder' in $$props) $$invalidate(3, placeholder = $$new_props.placeholder);
    		if ('value' in $$props) $$invalidate(11, value = $$new_props.value);
    		if ('files' in $$props) $$invalidate(12, files = $$new_props.files);
    		if ('dirty' in $$props) $$invalidate(13, dirty = $$new_props.dirty);
    		if ('invalid' in $$props) $$invalidate(14, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    		if ('emptyValueNull' in $$props) $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    		if ('emptyValueUndefined' in $$props) $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
    		if ('element' in $$props) $$invalidate(5, element = $$new_props.element);
    		if ('internalAttrs' in $$props) $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
    		if ('valueProp' in $$props) $$invalidate(4, valueProp = $$new_props.valueProp);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*type, valueProp, value*/ 2068) {
    			if (type === 'file') {
    				delete valueProp.value;
    				(($$invalidate(4, valueProp), $$invalidate(2, type)), $$invalidate(11, value));
    			} else {
    				$$invalidate(4, valueProp.value = value == null ? '' : value, valueProp);
    			}
    		}
    	};

    	return [
    		use,
    		className,
    		type,
    		placeholder,
    		valueProp,
    		element,
    		internalAttrs,
    		forwardEvents,
    		valueUpdater,
    		changeHandler,
    		$$restProps,
    		value,
    		files,
    		dirty,
    		invalid,
    		updateInvalid,
    		emptyValueNull,
    		emptyValueUndefined,
    		getAttr,
    		addAttr,
    		removeAttr,
    		focus,
    		blur,
    		getElement,
    		blur_handler,
    		focus_handler,
    		input_binding,
    		input_handler
    	];
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$4, create_fragment$5, safe_not_equal, {
    			use: 0,
    			class: 1,
    			type: 2,
    			placeholder: 3,
    			value: 11,
    			files: 12,
    			dirty: 13,
    			invalid: 14,
    			updateInvalid: 15,
    			emptyValueNull: 16,
    			emptyValueUndefined: 17,
    			getAttr: 18,
    			addAttr: 19,
    			removeAttr: 20,
    			focus: 21,
    			blur: 22,
    			getElement: 23
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Input",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get use() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get files() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set files(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get emptyValueNull() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set emptyValueNull(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get emptyValueUndefined() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set emptyValueUndefined(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getAttr() {
    		return this.$$.ctx[18];
    	}

    	set getAttr(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addAttr() {
    		return this.$$.ctx[19];
    	}

    	set addAttr(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get removeAttr() {
    		return this.$$.ctx[20];
    	}

    	set removeAttr(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[21];
    	}

    	set focus(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blur() {
    		return this.$$.ctx[22];
    	}

    	set blur(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[23];
    	}

    	set getElement(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/textfield/dist/Textarea.svelte generated by Svelte v3.47.0 */
    const file$4 = "node_modules/@smui/textfield/dist/Textarea.svelte";

    function create_fragment$4(ctx) {
    	let textarea;
    	let textarea_class_value;
    	let textarea_style_value;
    	let useActions_action;
    	let mounted;
    	let dispose;

    	let textarea_levels = [
    		{
    			class: textarea_class_value = classMap({
    				[/*className*/ ctx[2]]: true,
    				'mdc-text-field__input': true
    			})
    		},
    		{
    			style: textarea_style_value = `${/*resizable*/ ctx[4] ? '' : 'resize: none; '}${/*style*/ ctx[3]}`
    		},
    		/*internalAttrs*/ ctx[6],
    		/*$$restProps*/ ctx[9]
    	];

    	let textarea_data = {};

    	for (let i = 0; i < textarea_levels.length; i += 1) {
    		textarea_data = assign$4(textarea_data, textarea_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			set_attributes(textarea, textarea_data);
    			add_location(textarea, file$4, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			if (textarea.autofocus) textarea.focus();
    			/*textarea_binding*/ ctx[21](textarea);
    			set_input_value(textarea, /*value*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(useActions_action = useActions.call(null, textarea, /*use*/ ctx[1])),
    					action_destroyer(/*forwardEvents*/ ctx[7].call(null, textarea)),
    					listen_dev(textarea, "change", /*changeHandler*/ ctx[8], false, false, false),
    					listen_dev(textarea, "blur", /*blur_handler*/ ctx[19], false, false, false),
    					listen_dev(textarea, "focus", /*focus_handler*/ ctx[20], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[22])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
    				dirty & /*className*/ 4 && textarea_class_value !== (textarea_class_value = classMap({
    					[/*className*/ ctx[2]]: true,
    					'mdc-text-field__input': true
    				})) && { class: textarea_class_value },
    				dirty & /*resizable, style*/ 24 && textarea_style_value !== (textarea_style_value = `${/*resizable*/ ctx[4] ? '' : 'resize: none; '}${/*style*/ ctx[3]}`) && { style: textarea_style_value },
    				dirty & /*internalAttrs*/ 64 && /*internalAttrs*/ ctx[6],
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
    			]));

    			if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/ 2) useActions_action.update.call(null, /*use*/ ctx[1]);

    			if (dirty & /*value*/ 1) {
    				set_input_value(textarea, /*value*/ ctx[0]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			/*textarea_binding*/ ctx[21](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"use","class","style","value","dirty","invalid","updateInvalid","resizable","getAttr","addAttr","removeAttr","focus","blur","getElement"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Textarea', slots, []);
    	const forwardEvents = forwardEventsBuilder(get_current_component());
    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { style = '' } = $$props;
    	let { value = '' } = $$props;
    	let { dirty = false } = $$props;
    	let { invalid = false } = $$props;
    	let { updateInvalid = true } = $$props;
    	let { resizable = true } = $$props;
    	let element;
    	let internalAttrs = {};

    	onMount(() => {
    		if (updateInvalid) {
    			$$invalidate(11, invalid = element.matches(':invalid'));
    		}
    	});

    	function changeHandler() {
    		$$invalidate(10, dirty = true);

    		if (updateInvalid) {
    			$$invalidate(11, invalid = element.matches(':invalid'));
    		}
    	}

    	function getAttr(name) {
    		var _a;

    		return name in internalAttrs
    		? (_a = internalAttrs[name]) !== null && _a !== void 0
    			? _a
    			: null
    		: getElement().getAttribute(name);
    	}

    	function addAttr(name, value) {
    		if (internalAttrs[name] !== value) {
    			$$invalidate(6, internalAttrs[name] = value, internalAttrs);
    		}
    	}

    	function removeAttr(name) {
    		if (!(name in internalAttrs) || internalAttrs[name] != null) {
    			$$invalidate(6, internalAttrs[name] = undefined, internalAttrs);
    		}
    	}

    	function focus() {
    		getElement().focus();
    	}

    	function blur() {
    		getElement().blur();
    	}

    	function getElement() {
    		return element;
    	}

    	function blur_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function focus_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(5, element);
    		});
    	}

    	function textarea_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(1, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ('style' in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('dirty' in $$new_props) $$invalidate(10, dirty = $$new_props.dirty);
    		if ('invalid' in $$new_props) $$invalidate(11, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    		if ('resizable' in $$new_props) $$invalidate(4, resizable = $$new_props.resizable);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		useActions,
    		forwardEvents,
    		use,
    		className,
    		style,
    		value,
    		dirty,
    		invalid,
    		updateInvalid,
    		resizable,
    		element,
    		internalAttrs,
    		changeHandler,
    		getAttr,
    		addAttr,
    		removeAttr,
    		focus,
    		blur,
    		getElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('use' in $$props) $$invalidate(1, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(2, className = $$new_props.className);
    		if ('style' in $$props) $$invalidate(3, style = $$new_props.style);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('dirty' in $$props) $$invalidate(10, dirty = $$new_props.dirty);
    		if ('invalid' in $$props) $$invalidate(11, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    		if ('resizable' in $$props) $$invalidate(4, resizable = $$new_props.resizable);
    		if ('element' in $$props) $$invalidate(5, element = $$new_props.element);
    		if ('internalAttrs' in $$props) $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		value,
    		use,
    		className,
    		style,
    		resizable,
    		element,
    		internalAttrs,
    		forwardEvents,
    		changeHandler,
    		$$restProps,
    		dirty,
    		invalid,
    		updateInvalid,
    		getAttr,
    		addAttr,
    		removeAttr,
    		focus,
    		blur,
    		getElement,
    		blur_handler,
    		focus_handler,
    		textarea_binding,
    		textarea_input_handler
    	];
    }

    class Textarea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$3, create_fragment$4, safe_not_equal, {
    			use: 1,
    			class: 2,
    			style: 3,
    			value: 0,
    			dirty: 10,
    			invalid: 11,
    			updateInvalid: 12,
    			resizable: 4,
    			getAttr: 13,
    			addAttr: 14,
    			removeAttr: 15,
    			focus: 16,
    			blur: 17,
    			getElement: 18
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textarea",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get use() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resizable() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resizable(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getAttr() {
    		return this.$$.ctx[13];
    	}

    	set getAttr(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get addAttr() {
    		return this.$$.ctx[14];
    	}

    	set addAttr(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get removeAttr() {
    		return this.$$.ctx[15];
    	}

    	set removeAttr(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[16];
    	}

    	set focus(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blur() {
    		return this.$$.ctx[17];
    	}

    	set blur(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[18];
    	}

    	set getElement(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@smui/textfield/dist/Textfield.svelte generated by Svelte v3.47.0 */

    const { Error: Error_1$1 } = globals;
    const file$3 = "node_modules/@smui/textfield/dist/Textfield.svelte";
    const get_helper_slot_changes = dirty => ({});
    const get_helper_slot_context = ctx => ({});
    const get_ripple_slot_changes = dirty => ({});
    const get_ripple_slot_context = ctx => ({});
    const get_trailingIcon_slot_changes_1 = dirty => ({});
    const get_trailingIcon_slot_context_1 = ctx => ({});
    const get_leadingIcon_slot_changes_1 = dirty => ({});
    const get_leadingIcon_slot_context_1 = ctx => ({});
    const get_label_slot_changes_2 = dirty => ({});
    const get_label_slot_context_2 = ctx => ({});
    const get_trailingIcon_slot_changes = dirty => ({});
    const get_trailingIcon_slot_context = ctx => ({});
    const get_suffix_slot_changes = dirty => ({});
    const get_suffix_slot_context = ctx => ({});
    const get_prefix_slot_changes = dirty => ({});
    const get_prefix_slot_context = ctx => ({});
    const get_internalCounter_slot_changes = dirty => ({});
    const get_internalCounter_slot_context = ctx => ({});
    const get_leadingIcon_slot_changes = dirty => ({});
    const get_leadingIcon_slot_context = ctx => ({});
    const get_label_slot_changes_1 = dirty => ({});
    const get_label_slot_context_1 = ctx => ({});
    const get_label_slot_changes = dirty => ({});
    const get_label_slot_context = ctx => ({});

    // (163:0) {:else}
    function create_else_block_1(ctx) {
    	let div;
    	let t0;
    	let contextfragment0;
    	let t1;
    	let t2;
    	let contextfragment1;
    	let t3;
    	let div_class_value;
    	let div_style_value;
    	let Ripple_action;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	const label_slot_template = /*#slots*/ ctx[51].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[90], get_label_slot_context_2);

    	contextfragment0 = new ContextFragment({
    			props: {
    				key: "SMUI:textfield:icon:leading",
    				value: true,
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*#slots*/ ctx[51].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[90], null);

    	contextfragment1 = new ContextFragment({
    			props: {
    				key: "SMUI:textfield:icon:leading",
    				value: false,
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const ripple_slot_template = /*#slots*/ ctx[51].ripple;
    	const ripple_slot = create_slot(ripple_slot_template, ctx, /*$$scope*/ ctx[90], get_ripple_slot_context);

    	let div_levels = [
    		{
    			class: div_class_value = classMap({
    				[/*className*/ ctx[9]]: true,
    				'mdc-text-field': true,
    				'mdc-text-field--disabled': /*disabled*/ ctx[12],
    				'mdc-text-field--textarea': /*textarea*/ ctx[14],
    				'mdc-text-field--filled': /*variant*/ ctx[15] === 'filled',
    				'mdc-text-field--outlined': /*variant*/ ctx[15] === 'outlined',
    				'smui-text-field--standard': /*variant*/ ctx[15] === 'standard' && !/*textarea*/ ctx[14],
    				'mdc-text-field--no-label': /*noLabel*/ ctx[16] || !/*$$slots*/ ctx[42].label,
    				'mdc-text-field--with-leading-icon': /*$$slots*/ ctx[42].leadingIcon,
    				'mdc-text-field--with-trailing-icon': /*$$slots*/ ctx[42].trailingIcon,
    				'mdc-text-field--invalid': /*invalid*/ ctx[1],
    				.../*internalClasses*/ ctx[25]
    			})
    		},
    		{
    			style: div_style_value = Object.entries(/*internalStyles*/ ctx[26]).map(func_1).concat([/*style*/ ctx[10]]).join(' ')
    		},
    		exclude(/*$$restProps*/ ctx[41], ['input$', 'label$', 'ripple$', 'outline$', 'helperLine$'])
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$4(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (label_slot) label_slot.c();
    			t0 = space();
    			create_component(contextfragment0.$$.fragment);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			create_component(contextfragment1.$$.fragment);
    			t3 = space();
    			if (ripple_slot) ripple_slot.c();
    			set_attributes(div, div_data);
    			add_location(div, file$3, 163, 2, 5417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (label_slot) {
    				label_slot.m(div, null);
    			}

    			append_dev(div, t0);
    			mount_component(contextfragment0, div, null);
    			append_dev(div, t1);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t2);
    			mount_component(contextfragment1, div, null);
    			append_dev(div, t3);

    			if (ripple_slot) {
    				ripple_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[80](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(Ripple_action = Ripple.call(null, div, {
    						ripple: /*ripple*/ ctx[11],
    						unbounded: false,
    						addClass: /*addClass*/ ctx[38],
    						removeClass: /*removeClass*/ ctx[39],
    						addStyle: /*addStyle*/ ctx[40]
    					})),
    					action_destroyer(useActions_action = useActions.call(null, div, /*use*/ ctx[8])),
    					action_destroyer(/*forwardEvents*/ ctx[34].call(null, div)),
    					listen_dev(div, "SMUITextfieldLeadingIcon:mount", /*SMUITextfieldLeadingIcon_mount_handler_1*/ ctx[81], false, false, false),
    					listen_dev(div, "SMUITextfieldLeadingIcon:unmount", /*SMUITextfieldLeadingIcon_unmount_handler_1*/ ctx[82], false, false, false),
    					listen_dev(div, "SMUITextfieldTrailingIcon:mount", /*SMUITextfieldTrailingIcon_mount_handler_1*/ ctx[83], false, false, false),
    					listen_dev(div, "SMUITextfieldTrailingIcon:unmount", /*SMUITextfieldTrailingIcon_unmount_handler_1*/ ctx[84], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[90], dirty, get_label_slot_changes_2),
    						get_label_slot_context_2
    					);
    				}
    			}

    			const contextfragment0_changes = {};

    			if (dirty[2] & /*$$scope*/ 268435456) {
    				contextfragment0_changes.$$scope = { dirty, ctx };
    			}

    			contextfragment0.$set(contextfragment0_changes);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[90], dirty, null),
    						null
    					);
    				}
    			}

    			const contextfragment1_changes = {};

    			if (dirty[2] & /*$$scope*/ 268435456) {
    				contextfragment1_changes.$$scope = { dirty, ctx };
    			}

    			contextfragment1.$set(contextfragment1_changes);

    			if (ripple_slot) {
    				if (ripple_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						ripple_slot,
    						ripple_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(ripple_slot_template, /*$$scope*/ ctx[90], dirty, get_ripple_slot_changes),
    						get_ripple_slot_context
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty[0] & /*className, disabled, textarea, variant, noLabel, invalid, internalClasses*/ 33673730 | dirty[1] & /*$$slots*/ 2048 && div_class_value !== (div_class_value = classMap({
    					[/*className*/ ctx[9]]: true,
    					'mdc-text-field': true,
    					'mdc-text-field--disabled': /*disabled*/ ctx[12],
    					'mdc-text-field--textarea': /*textarea*/ ctx[14],
    					'mdc-text-field--filled': /*variant*/ ctx[15] === 'filled',
    					'mdc-text-field--outlined': /*variant*/ ctx[15] === 'outlined',
    					'smui-text-field--standard': /*variant*/ ctx[15] === 'standard' && !/*textarea*/ ctx[14],
    					'mdc-text-field--no-label': /*noLabel*/ ctx[16] || !/*$$slots*/ ctx[42].label,
    					'mdc-text-field--with-leading-icon': /*$$slots*/ ctx[42].leadingIcon,
    					'mdc-text-field--with-trailing-icon': /*$$slots*/ ctx[42].trailingIcon,
    					'mdc-text-field--invalid': /*invalid*/ ctx[1],
    					.../*internalClasses*/ ctx[25]
    				}))) && { class: div_class_value },
    				(!current || dirty[0] & /*internalStyles, style*/ 67109888 && div_style_value !== (div_style_value = Object.entries(/*internalStyles*/ ctx[26]).map(func_1).concat([/*style*/ ctx[10]]).join(' '))) && { style: div_style_value },
    				dirty[1] & /*$$restProps*/ 1024 && exclude(/*$$restProps*/ ctx[41], ['input$', 'label$', 'ripple$', 'outline$', 'helperLine$'])
    			]));

    			if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & /*ripple*/ 2048) Ripple_action.update.call(null, {
    				ripple: /*ripple*/ ctx[11],
    				unbounded: false,
    				addClass: /*addClass*/ ctx[38],
    				removeClass: /*removeClass*/ ctx[39],
    				addStyle: /*addStyle*/ ctx[40]
    			});

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 256) useActions_action.update.call(null, /*use*/ ctx[8]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			transition_in(contextfragment0.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(contextfragment1.$$.fragment, local);
    			transition_in(ripple_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			transition_out(contextfragment0.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(contextfragment1.$$.fragment, local);
    			transition_out(ripple_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (label_slot) label_slot.d(detaching);
    			destroy_component(contextfragment0);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(contextfragment1);
    			if (ripple_slot) ripple_slot.d(detaching);
    			/*div_binding*/ ctx[80](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(163:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (1:0) {#if valued}
    function create_if_block_1$2(ctx) {
    	let label_1;
    	let t0;
    	let t1;
    	let contextfragment0;
    	let t2;
    	let t3;
    	let current_block_type_index;
    	let if_block2;
    	let t4;
    	let contextfragment1;
    	let t5;
    	let label_1_class_value;
    	let label_1_style_value;
    	let Ripple_action;
    	let useActions_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*textarea*/ ctx[14] && /*variant*/ ctx[15] !== 'outlined' && create_if_block_8(ctx);
    	let if_block1 = (/*textarea*/ ctx[14] || /*variant*/ ctx[15] === 'outlined') && create_if_block_6(ctx);

    	contextfragment0 = new ContextFragment({
    			props: {
    				key: "SMUI:textfield:icon:leading",
    				value: true,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*#slots*/ ctx[51].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[90], null);
    	const if_block_creators = [create_if_block_3$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*textarea*/ ctx[14] && typeof /*value*/ ctx[0] === 'string') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	contextfragment1 = new ContextFragment({
    			props: {
    				key: "SMUI:textfield:icon:leading",
    				value: false,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block3 = !/*textarea*/ ctx[14] && /*variant*/ ctx[15] !== 'outlined' && /*ripple*/ ctx[11] && create_if_block_2$1(ctx);

    	let label_1_levels = [
    		{
    			class: label_1_class_value = classMap({
    				[/*className*/ ctx[9]]: true,
    				'mdc-text-field': true,
    				'mdc-text-field--disabled': /*disabled*/ ctx[12],
    				'mdc-text-field--textarea': /*textarea*/ ctx[14],
    				'mdc-text-field--filled': /*variant*/ ctx[15] === 'filled',
    				'mdc-text-field--outlined': /*variant*/ ctx[15] === 'outlined',
    				'smui-text-field--standard': /*variant*/ ctx[15] === 'standard' && !/*textarea*/ ctx[14],
    				'mdc-text-field--no-label': /*noLabel*/ ctx[16] || /*label*/ ctx[17] == null && !/*$$slots*/ ctx[42].label,
    				'mdc-text-field--label-floating': /*focused*/ ctx[28] || /*value*/ ctx[0] != null && /*value*/ ctx[0] !== '',
    				'mdc-text-field--with-leading-icon': /*isUninitializedValue*/ ctx[35](/*withLeadingIcon*/ ctx[22])
    				? /*$$slots*/ ctx[42].leadingIcon
    				: /*withLeadingIcon*/ ctx[22],
    				'mdc-text-field--with-trailing-icon': /*isUninitializedValue*/ ctx[35](/*withTrailingIcon*/ ctx[23])
    				? /*$$slots*/ ctx[42].trailingIcon
    				: /*withTrailingIcon*/ ctx[23],
    				'mdc-text-field--with-internal-counter': /*textarea*/ ctx[14] && /*$$slots*/ ctx[42].internalCounter,
    				'mdc-text-field--invalid': /*invalid*/ ctx[1],
    				.../*internalClasses*/ ctx[25]
    			})
    		},
    		{
    			style: label_1_style_value = Object.entries(/*internalStyles*/ ctx[26]).map(func).concat([/*style*/ ctx[10]]).join(' ')
    		},
    		{
    			for: /* suppress a11y warning, since this is wrapped */ undefined
    		},
    		exclude(/*$$restProps*/ ctx[41], ['input$', 'label$', 'ripple$', 'outline$', 'helperLine$'])
    	];

    	let label_1_data = {};

    	for (let i = 0; i < label_1_levels.length; i += 1) {
    		label_1_data = assign$4(label_1_data, label_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			label_1 = element("label");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(contextfragment0.$$.fragment);
    			t2 = space();
    			if (default_slot) default_slot.c();
    			t3 = space();
    			if_block2.c();
    			t4 = space();
    			create_component(contextfragment1.$$.fragment);
    			t5 = space();
    			if (if_block3) if_block3.c();
    			set_attributes(label_1, label_1_data);
    			add_location(label_1, file$3, 1, 2, 15);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label_1, anchor);
    			if (if_block0) if_block0.m(label_1, null);
    			append_dev(label_1, t0);
    			if (if_block1) if_block1.m(label_1, null);
    			append_dev(label_1, t1);
    			mount_component(contextfragment0, label_1, null);
    			append_dev(label_1, t2);

    			if (default_slot) {
    				default_slot.m(label_1, null);
    			}

    			append_dev(label_1, t3);
    			if_blocks[current_block_type_index].m(label_1, null);
    			append_dev(label_1, t4);
    			mount_component(contextfragment1, label_1, null);
    			append_dev(label_1, t5);
    			if (if_block3) if_block3.m(label_1, null);
    			/*label_1_binding*/ ctx[73](label_1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(Ripple_action = Ripple.call(null, label_1, {
    						ripple: !/*textarea*/ ctx[14] && /*variant*/ ctx[15] === 'filled',
    						unbounded: false,
    						addClass: /*addClass*/ ctx[38],
    						removeClass: /*removeClass*/ ctx[39],
    						addStyle: /*addStyle*/ ctx[40],
    						eventTarget: /*inputElement*/ ctx[33],
    						activeTarget: /*inputElement*/ ctx[33],
    						initPromise: /*initPromise*/ ctx[37]
    					})),
    					action_destroyer(useActions_action = useActions.call(null, label_1, /*use*/ ctx[8])),
    					action_destroyer(/*forwardEvents*/ ctx[34].call(null, label_1)),
    					listen_dev(label_1, "SMUITextfieldLeadingIcon:mount", /*SMUITextfieldLeadingIcon_mount_handler*/ ctx[74], false, false, false),
    					listen_dev(label_1, "SMUITextfieldLeadingIcon:unmount", /*SMUITextfieldLeadingIcon_unmount_handler*/ ctx[75], false, false, false),
    					listen_dev(label_1, "SMUITextfieldTrailingIcon:mount", /*SMUITextfieldTrailingIcon_mount_handler*/ ctx[76], false, false, false),
    					listen_dev(label_1, "SMUITextfieldTrailingIcon:unmount", /*SMUITextfieldTrailingIcon_unmount_handler*/ ctx[77], false, false, false),
    					listen_dev(label_1, "SMUITextfieldCharacterCounter:mount", /*SMUITextfieldCharacterCounter_mount_handler*/ ctx[78], false, false, false),
    					listen_dev(label_1, "SMUITextfieldCharacterCounter:unmount", /*SMUITextfieldCharacterCounter_unmount_handler*/ ctx[79], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!/*textarea*/ ctx[14] && /*variant*/ ctx[15] !== 'outlined') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*textarea, variant*/ 49152) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(label_1, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*textarea*/ ctx[14] || /*variant*/ ctx[15] === 'outlined') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*textarea, variant*/ 49152) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(label_1, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const contextfragment0_changes = {};

    			if (dirty[2] & /*$$scope*/ 268435456) {
    				contextfragment0_changes.$$scope = { dirty, ctx };
    			}

    			contextfragment0.$set(contextfragment0_changes);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[90], dirty, null),
    						null
    					);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(label_1, t4);
    			}

    			const contextfragment1_changes = {};

    			if (dirty[2] & /*$$scope*/ 268435456) {
    				contextfragment1_changes.$$scope = { dirty, ctx };
    			}

    			contextfragment1.$set(contextfragment1_changes);

    			if (!/*textarea*/ ctx[14] && /*variant*/ ctx[15] !== 'outlined' && /*ripple*/ ctx[11]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*textarea, variant, ripple*/ 51200) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$1(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(label_1, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
    				(!current || dirty[0] & /*className, disabled, textarea, variant, noLabel, label, focused, value, withLeadingIcon, withTrailingIcon, invalid, internalClasses*/ 314823171 | dirty[1] & /*$$slots*/ 2048 && label_1_class_value !== (label_1_class_value = classMap({
    					[/*className*/ ctx[9]]: true,
    					'mdc-text-field': true,
    					'mdc-text-field--disabled': /*disabled*/ ctx[12],
    					'mdc-text-field--textarea': /*textarea*/ ctx[14],
    					'mdc-text-field--filled': /*variant*/ ctx[15] === 'filled',
    					'mdc-text-field--outlined': /*variant*/ ctx[15] === 'outlined',
    					'smui-text-field--standard': /*variant*/ ctx[15] === 'standard' && !/*textarea*/ ctx[14],
    					'mdc-text-field--no-label': /*noLabel*/ ctx[16] || /*label*/ ctx[17] == null && !/*$$slots*/ ctx[42].label,
    					'mdc-text-field--label-floating': /*focused*/ ctx[28] || /*value*/ ctx[0] != null && /*value*/ ctx[0] !== '',
    					'mdc-text-field--with-leading-icon': /*isUninitializedValue*/ ctx[35](/*withLeadingIcon*/ ctx[22])
    					? /*$$slots*/ ctx[42].leadingIcon
    					: /*withLeadingIcon*/ ctx[22],
    					'mdc-text-field--with-trailing-icon': /*isUninitializedValue*/ ctx[35](/*withTrailingIcon*/ ctx[23])
    					? /*$$slots*/ ctx[42].trailingIcon
    					: /*withTrailingIcon*/ ctx[23],
    					'mdc-text-field--with-internal-counter': /*textarea*/ ctx[14] && /*$$slots*/ ctx[42].internalCounter,
    					'mdc-text-field--invalid': /*invalid*/ ctx[1],
    					.../*internalClasses*/ ctx[25]
    				}))) && { class: label_1_class_value },
    				(!current || dirty[0] & /*internalStyles, style*/ 67109888 && label_1_style_value !== (label_1_style_value = Object.entries(/*internalStyles*/ ctx[26]).map(func).concat([/*style*/ ctx[10]]).join(' '))) && { style: label_1_style_value },
    				{
    					for: /* suppress a11y warning, since this is wrapped */ undefined
    				},
    				dirty[1] & /*$$restProps*/ 1024 && exclude(/*$$restProps*/ ctx[41], ['input$', 'label$', 'ripple$', 'outline$', 'helperLine$'])
    			]));

    			if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & /*textarea, variant*/ 49152 | dirty[1] & /*inputElement*/ 4) Ripple_action.update.call(null, {
    				ripple: !/*textarea*/ ctx[14] && /*variant*/ ctx[15] === 'filled',
    				unbounded: false,
    				addClass: /*addClass*/ ctx[38],
    				removeClass: /*removeClass*/ ctx[39],
    				addStyle: /*addStyle*/ ctx[40],
    				eventTarget: /*inputElement*/ ctx[33],
    				activeTarget: /*inputElement*/ ctx[33],
    				initPromise: /*initPromise*/ ctx[37]
    			});

    			if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/ 256) useActions_action.update.call(null, /*use*/ ctx[8]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(contextfragment0.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(if_block2);
    			transition_in(contextfragment1.$$.fragment, local);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(contextfragment0.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(if_block2);
    			transition_out(contextfragment1.$$.fragment, local);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label_1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(contextfragment0);
    			if (default_slot) default_slot.d(detaching);
    			if_blocks[current_block_type_index].d();
    			destroy_component(contextfragment1);
    			if (if_block3) if_block3.d();
    			/*label_1_binding*/ ctx[73](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(1:0) {#if valued}",
    		ctx
    	});

    	return block;
    }

    // (207:4) <ContextFragment key="SMUI:textfield:icon:leading" value={true}>
    function create_default_slot_9(ctx) {
    	let current;
    	const leadingIcon_slot_template = /*#slots*/ ctx[51].leadingIcon;
    	const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, /*$$scope*/ ctx[90], get_leadingIcon_slot_context_1);

    	const block = {
    		c: function create() {
    			if (leadingIcon_slot) leadingIcon_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (leadingIcon_slot) {
    				leadingIcon_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (leadingIcon_slot) {
    				if (leadingIcon_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						leadingIcon_slot,
    						leadingIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(leadingIcon_slot_template, /*$$scope*/ ctx[90], dirty, get_leadingIcon_slot_changes_1),
    						get_leadingIcon_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leadingIcon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leadingIcon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (leadingIcon_slot) leadingIcon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(207:4) <ContextFragment key=\\\"SMUI:textfield:icon:leading\\\" value={true}>",
    		ctx
    	});

    	return block;
    }

    // (211:4) <ContextFragment key="SMUI:textfield:icon:leading" value={false}>
    function create_default_slot_8(ctx) {
    	let current;
    	const trailingIcon_slot_template = /*#slots*/ ctx[51].trailingIcon;
    	const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, /*$$scope*/ ctx[90], get_trailingIcon_slot_context_1);

    	const block = {
    		c: function create() {
    			if (trailingIcon_slot) trailingIcon_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (trailingIcon_slot) {
    				trailingIcon_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (trailingIcon_slot) {
    				if (trailingIcon_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						trailingIcon_slot,
    						trailingIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(trailingIcon_slot_template, /*$$scope*/ ctx[90], dirty, get_trailingIcon_slot_changes_1),
    						get_trailingIcon_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(trailingIcon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(trailingIcon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (trailingIcon_slot) trailingIcon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(211:4) <ContextFragment key=\\\"SMUI:textfield:icon:leading\\\" value={false}>",
    		ctx
    	});

    	return block;
    }

    // (62:4) {#if !textarea && variant !== 'outlined'}
    function create_if_block_8(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*variant*/ ctx[15] === 'filled' && create_if_block_10(ctx);
    	let if_block1 = !/*noLabel*/ ctx[16] && (/*label*/ ctx[17] != null || /*$$slots*/ ctx[42].label) && create_if_block_9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*variant*/ ctx[15] === 'filled') {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_10(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*noLabel*/ ctx[16] && (/*label*/ ctx[17] != null || /*$$slots*/ ctx[42].label)) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*noLabel, label*/ 196608 | dirty[1] & /*$$slots*/ 2048) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_9(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(62:4) {#if !textarea && variant !== 'outlined'}",
    		ctx
    	});

    	return block;
    }

    // (63:6) {#if variant === 'filled'}
    function create_if_block_10(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "mdc-text-field__ripple");
    			add_location(span, file$3, 63, 8, 2241);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(63:6) {#if variant === 'filled'}",
    		ctx
    	});

    	return block;
    }

    // (66:6) {#if !noLabel && (label != null || $$slots.label)}
    function create_if_block_9(ctx) {
    	let floatinglabel;
    	let current;

    	const floatinglabel_spread_levels = [
    		{
    			floatAbove: /*focused*/ ctx[28] || /*value*/ ctx[0] != null && /*value*/ ctx[0] !== ''
    		},
    		{ required: /*required*/ ctx[13] },
    		{ wrapped: true },
    		prefixFilter(/*$$restProps*/ ctx[41], 'label$')
    	];

    	let floatinglabel_props = {
    		$$slots: { default: [create_default_slot_7] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    		floatinglabel_props = assign$4(floatinglabel_props, floatinglabel_spread_levels[i]);
    	}

    	floatinglabel = new FloatingLabel({
    			props: floatinglabel_props,
    			$$inline: true
    		});

    	/*floatinglabel_binding*/ ctx[52](floatinglabel);

    	const block = {
    		c: function create() {
    			create_component(floatinglabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(floatinglabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const floatinglabel_changes = (dirty[0] & /*focused, value, required*/ 268443649 | dirty[1] & /*$$restProps*/ 1024)
    			? get_spread_update(floatinglabel_spread_levels, [
    					dirty[0] & /*focused, value*/ 268435457 && {
    						floatAbove: /*focused*/ ctx[28] || /*value*/ ctx[0] != null && /*value*/ ctx[0] !== ''
    					},
    					dirty[0] & /*required*/ 8192 && { required: /*required*/ ctx[13] },
    					floatinglabel_spread_levels[2],
    					dirty[1] & /*$$restProps*/ 1024 && get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'label$'))
    				])
    			: {};

    			if (dirty[0] & /*label*/ 131072 | dirty[2] & /*$$scope*/ 268435456) {
    				floatinglabel_changes.$$scope = { dirty, ctx };
    			}

    			floatinglabel.$set(floatinglabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(floatinglabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(floatinglabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*floatinglabel_binding*/ ctx[52](null);
    			destroy_component(floatinglabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(66:6) {#if !noLabel && (label != null || $$slots.label)}",
    		ctx
    	});

    	return block;
    }

    // (67:8) <FloatingLabel           bind:this={floatingLabel}           floatAbove={focused || (value != null && value !== '')}           {required}           wrapped           {...prefixFilter($$restProps, 'label$')}           >
    function create_default_slot_7(ctx) {
    	let t_value = (/*label*/ ctx[17] == null ? '' : /*label*/ ctx[17]) + "";
    	let t;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[51].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[90], get_label_slot_context);

    	const block = {
    		c: function create() {
    			t = text(t_value);
    			if (label_slot) label_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (label_slot) {
    				label_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*label*/ 131072) && t_value !== (t_value = (/*label*/ ctx[17] == null ? '' : /*label*/ ctx[17]) + "")) set_data_dev(t, t_value);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[90], dirty, get_label_slot_changes),
    						get_label_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(67:8) <FloatingLabel           bind:this={floatingLabel}           floatAbove={focused || (value != null && value !== '')}           {required}           wrapped           {...prefixFilter($$restProps, 'label$')}           >",
    		ctx
    	});

    	return block;
    }

    // (77:4) {#if textarea || variant === 'outlined'}
    function create_if_block_6(ctx) {
    	let notchedoutline;
    	let current;

    	const notchedoutline_spread_levels = [
    		{
    			noLabel: /*noLabel*/ ctx[16] || /*label*/ ctx[17] == null && !/*$$slots*/ ctx[42].label
    		},
    		prefixFilter(/*$$restProps*/ ctx[41], 'outline$')
    	];

    	let notchedoutline_props = {
    		$$slots: { default: [create_default_slot_5] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    		notchedoutline_props = assign$4(notchedoutline_props, notchedoutline_spread_levels[i]);
    	}

    	notchedoutline = new NotchedOutline({
    			props: notchedoutline_props,
    			$$inline: true
    		});

    	/*notchedoutline_binding*/ ctx[54](notchedoutline);

    	const block = {
    		c: function create() {
    			create_component(notchedoutline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notchedoutline, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const notchedoutline_changes = (dirty[0] & /*noLabel, label*/ 196608 | dirty[1] & /*$$slots, $$restProps*/ 3072)
    			? get_spread_update(notchedoutline_spread_levels, [
    					dirty[0] & /*noLabel, label*/ 196608 | dirty[1] & /*$$slots*/ 2048 && {
    						noLabel: /*noLabel*/ ctx[16] || /*label*/ ctx[17] == null && !/*$$slots*/ ctx[42].label
    					},
    					dirty[1] & /*$$restProps*/ 1024 && get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'outline$'))
    				])
    			: {};

    			if (dirty[0] & /*focused, value, required, floatingLabel, label, noLabel*/ 268640289 | dirty[1] & /*$$restProps, $$slots*/ 3072 | dirty[2] & /*$$scope*/ 268435456) {
    				notchedoutline_changes.$$scope = { dirty, ctx };
    			}

    			notchedoutline.$set(notchedoutline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notchedoutline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notchedoutline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*notchedoutline_binding*/ ctx[54](null);
    			destroy_component(notchedoutline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(77:4) {#if textarea || variant === 'outlined'}",
    		ctx
    	});

    	return block;
    }

    // (83:8) {#if !noLabel && (label != null || $$slots.label)}
    function create_if_block_7(ctx) {
    	let floatinglabel;
    	let current;

    	const floatinglabel_spread_levels = [
    		{
    			floatAbove: /*focused*/ ctx[28] || /*value*/ ctx[0] != null && /*value*/ ctx[0] !== ''
    		},
    		{ required: /*required*/ ctx[13] },
    		{ wrapped: true },
    		prefixFilter(/*$$restProps*/ ctx[41], 'label$')
    	];

    	let floatinglabel_props = {
    		$$slots: { default: [create_default_slot_6] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    		floatinglabel_props = assign$4(floatinglabel_props, floatinglabel_spread_levels[i]);
    	}

    	floatinglabel = new FloatingLabel({
    			props: floatinglabel_props,
    			$$inline: true
    		});

    	/*floatinglabel_binding_1*/ ctx[53](floatinglabel);

    	const block = {
    		c: function create() {
    			create_component(floatinglabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(floatinglabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const floatinglabel_changes = (dirty[0] & /*focused, value, required*/ 268443649 | dirty[1] & /*$$restProps*/ 1024)
    			? get_spread_update(floatinglabel_spread_levels, [
    					dirty[0] & /*focused, value*/ 268435457 && {
    						floatAbove: /*focused*/ ctx[28] || /*value*/ ctx[0] != null && /*value*/ ctx[0] !== ''
    					},
    					dirty[0] & /*required*/ 8192 && { required: /*required*/ ctx[13] },
    					floatinglabel_spread_levels[2],
    					dirty[1] & /*$$restProps*/ 1024 && get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'label$'))
    				])
    			: {};

    			if (dirty[0] & /*label*/ 131072 | dirty[2] & /*$$scope*/ 268435456) {
    				floatinglabel_changes.$$scope = { dirty, ctx };
    			}

    			floatinglabel.$set(floatinglabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(floatinglabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(floatinglabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*floatinglabel_binding_1*/ ctx[53](null);
    			destroy_component(floatinglabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(83:8) {#if !noLabel && (label != null || $$slots.label)}",
    		ctx
    	});

    	return block;
    }

    // (84:10) <FloatingLabel             bind:this={floatingLabel}             floatAbove={focused || (value != null && value !== '')}             {required}             wrapped             {...prefixFilter($$restProps, 'label$')}             >
    function create_default_slot_6(ctx) {
    	let t_value = (/*label*/ ctx[17] == null ? '' : /*label*/ ctx[17]) + "";
    	let t;
    	let current;
    	const label_slot_template = /*#slots*/ ctx[51].label;
    	const label_slot = create_slot(label_slot_template, ctx, /*$$scope*/ ctx[90], get_label_slot_context_1);

    	const block = {
    		c: function create() {
    			t = text(t_value);
    			if (label_slot) label_slot.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);

    			if (label_slot) {
    				label_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*label*/ 131072) && t_value !== (t_value = (/*label*/ ctx[17] == null ? '' : /*label*/ ctx[17]) + "")) set_data_dev(t, t_value);

    			if (label_slot) {
    				if (label_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						label_slot,
    						label_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(label_slot_template, /*$$scope*/ ctx[90], dirty, get_label_slot_changes_1),
    						get_label_slot_context_1
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(label_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(label_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (label_slot) label_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(84:10) <FloatingLabel             bind:this={floatingLabel}             floatAbove={focused || (value != null && value !== '')}             {required}             wrapped             {...prefixFilter($$restProps, 'label$')}             >",
    		ctx
    	});

    	return block;
    }

    // (78:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >
    function create_default_slot_5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*noLabel*/ ctx[16] && (/*label*/ ctx[17] != null || /*$$slots*/ ctx[42].label) && create_if_block_7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*noLabel*/ ctx[16] && (/*label*/ ctx[17] != null || /*$$slots*/ ctx[42].label)) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*noLabel, label*/ 196608 | dirty[1] & /*$$slots*/ 2048) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(78:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
    		ctx
    	});

    	return block;
    }

    // (95:4) <ContextFragment key="SMUI:textfield:icon:leading" value={true}>
    function create_default_slot_4(ctx) {
    	let current;
    	const leadingIcon_slot_template = /*#slots*/ ctx[51].leadingIcon;
    	const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, /*$$scope*/ ctx[90], get_leadingIcon_slot_context);

    	const block = {
    		c: function create() {
    			if (leadingIcon_slot) leadingIcon_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (leadingIcon_slot) {
    				leadingIcon_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (leadingIcon_slot) {
    				if (leadingIcon_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						leadingIcon_slot,
    						leadingIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(leadingIcon_slot_template, /*$$scope*/ ctx[90], dirty, get_leadingIcon_slot_changes),
    						get_leadingIcon_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(leadingIcon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(leadingIcon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (leadingIcon_slot) leadingIcon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(95:4) <ContextFragment key=\\\"SMUI:textfield:icon:leading\\\" value={true}>",
    		ctx
    	});

    	return block;
    }

    // (124:4) {:else}
    function create_else_block$1(ctx) {
    	let t0;
    	let t1;
    	let input_1;
    	let updating_value;
    	let updating_files;
    	let updating_dirty;
    	let updating_invalid;
    	let t2;
    	let t3;
    	let current;
    	const prefix_slot_template = /*#slots*/ ctx[51].prefix;
    	const prefix_slot = create_slot(prefix_slot_template, ctx, /*$$scope*/ ctx[90], get_prefix_slot_context);
    	let if_block0 = /*prefix*/ ctx[20] != null && create_if_block_5(ctx);

    	const input_1_spread_levels = [
    		{ type: /*type*/ ctx[18] },
    		{ disabled: /*disabled*/ ctx[12] },
    		{ required: /*required*/ ctx[13] },
    		{ updateInvalid: /*updateInvalid*/ ctx[19] },
    		{ "aria-controls": /*helperId*/ ctx[27] },
    		{ "aria-describedby": /*helperId*/ ctx[27] },
    		/*noLabel*/ ctx[16] && /*label*/ ctx[17] != null
    		? { placeholder: /*label*/ ctx[17] }
    		: {},
    		prefixFilter(/*$$restProps*/ ctx[41], 'input$')
    	];

    	function input_1_value_binding(value) {
    		/*input_1_value_binding*/ ctx[64](value);
    	}

    	function input_1_files_binding(value) {
    		/*input_1_files_binding*/ ctx[65](value);
    	}

    	function input_1_dirty_binding(value) {
    		/*input_1_dirty_binding*/ ctx[66](value);
    	}

    	function input_1_invalid_binding(value) {
    		/*input_1_invalid_binding*/ ctx[67](value);
    	}

    	let input_1_props = {};

    	for (let i = 0; i < input_1_spread_levels.length; i += 1) {
    		input_1_props = assign$4(input_1_props, input_1_spread_levels[i]);
    	}

    	if (/*value*/ ctx[0] !== void 0) {
    		input_1_props.value = /*value*/ ctx[0];
    	}

    	if (/*files*/ ctx[3] !== void 0) {
    		input_1_props.files = /*files*/ ctx[3];
    	}

    	if (/*dirty*/ ctx[4] !== void 0) {
    		input_1_props.dirty = /*dirty*/ ctx[4];
    	}

    	if (/*invalid*/ ctx[1] !== void 0) {
    		input_1_props.invalid = /*invalid*/ ctx[1];
    	}

    	input_1 = new Input({ props: input_1_props, $$inline: true });
    	/*input_1_binding*/ ctx[63](input_1);
    	binding_callbacks.push(() => bind(input_1, 'value', input_1_value_binding));
    	binding_callbacks.push(() => bind(input_1, 'files', input_1_files_binding));
    	binding_callbacks.push(() => bind(input_1, 'dirty', input_1_dirty_binding));
    	binding_callbacks.push(() => bind(input_1, 'invalid', input_1_invalid_binding));
    	input_1.$on("blur", /*blur_handler_2*/ ctx[68]);
    	input_1.$on("focus", /*focus_handler_2*/ ctx[69]);
    	input_1.$on("blur", /*blur_handler_3*/ ctx[70]);
    	input_1.$on("focus", /*focus_handler_3*/ ctx[71]);
    	let if_block1 = /*suffix*/ ctx[21] != null && create_if_block_4(ctx);
    	const suffix_slot_template = /*#slots*/ ctx[51].suffix;
    	const suffix_slot = create_slot(suffix_slot_template, ctx, /*$$scope*/ ctx[90], get_suffix_slot_context);

    	const block = {
    		c: function create() {
    			if (prefix_slot) prefix_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			create_component(input_1.$$.fragment);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (suffix_slot) suffix_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (prefix_slot) {
    				prefix_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(input_1, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);

    			if (suffix_slot) {
    				suffix_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (prefix_slot) {
    				if (prefix_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						prefix_slot,
    						prefix_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(prefix_slot_template, /*$$scope*/ ctx[90], dirty, get_prefix_slot_changes),
    						get_prefix_slot_context
    					);
    				}
    			}

    			if (/*prefix*/ ctx[20] != null) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*prefix*/ 1048576) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const input_1_changes = (dirty[0] & /*type, disabled, required, updateInvalid, helperId, noLabel, label*/ 135213056 | dirty[1] & /*$$restProps*/ 1024)
    			? get_spread_update(input_1_spread_levels, [
    					dirty[0] & /*type*/ 262144 && { type: /*type*/ ctx[18] },
    					dirty[0] & /*disabled*/ 4096 && { disabled: /*disabled*/ ctx[12] },
    					dirty[0] & /*required*/ 8192 && { required: /*required*/ ctx[13] },
    					dirty[0] & /*updateInvalid*/ 524288 && { updateInvalid: /*updateInvalid*/ ctx[19] },
    					dirty[0] & /*helperId*/ 134217728 && { "aria-controls": /*helperId*/ ctx[27] },
    					dirty[0] & /*helperId*/ 134217728 && { "aria-describedby": /*helperId*/ ctx[27] },
    					dirty[0] & /*noLabel, label*/ 196608 && get_spread_object(/*noLabel*/ ctx[16] && /*label*/ ctx[17] != null
    					? { placeholder: /*label*/ ctx[17] }
    					: {}),
    					dirty[1] & /*$$restProps*/ 1024 && get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'input$'))
    				])
    			: {};

    			if (!updating_value && dirty[0] & /*value*/ 1) {
    				updating_value = true;
    				input_1_changes.value = /*value*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_files && dirty[0] & /*files*/ 8) {
    				updating_files = true;
    				input_1_changes.files = /*files*/ ctx[3];
    				add_flush_callback(() => updating_files = false);
    			}

    			if (!updating_dirty && dirty[0] & /*dirty*/ 16) {
    				updating_dirty = true;
    				input_1_changes.dirty = /*dirty*/ ctx[4];
    				add_flush_callback(() => updating_dirty = false);
    			}

    			if (!updating_invalid && dirty[0] & /*invalid*/ 2) {
    				updating_invalid = true;
    				input_1_changes.invalid = /*invalid*/ ctx[1];
    				add_flush_callback(() => updating_invalid = false);
    			}

    			input_1.$set(input_1_changes);

    			if (/*suffix*/ ctx[21] != null) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*suffix*/ 2097152) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (suffix_slot) {
    				if (suffix_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						suffix_slot,
    						suffix_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(suffix_slot_template, /*$$scope*/ ctx[90], dirty, get_suffix_slot_changes),
    						get_suffix_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prefix_slot, local);
    			transition_in(if_block0);
    			transition_in(input_1.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(suffix_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prefix_slot, local);
    			transition_out(if_block0);
    			transition_out(input_1.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(suffix_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (prefix_slot) prefix_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			/*input_1_binding*/ ctx[63](null);
    			destroy_component(input_1, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (suffix_slot) suffix_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(124:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (99:4) {#if textarea && typeof value === 'string'}
    function create_if_block_3$1(ctx) {
    	let span;
    	let textarea_1;
    	let updating_value;
    	let updating_dirty;
    	let updating_invalid;
    	let t;
    	let span_class_value;
    	let current;

    	const textarea_1_spread_levels = [
    		{ disabled: /*disabled*/ ctx[12] },
    		{ required: /*required*/ ctx[13] },
    		{ updateInvalid: /*updateInvalid*/ ctx[19] },
    		{ "aria-controls": /*helperId*/ ctx[27] },
    		{ "aria-describedby": /*helperId*/ ctx[27] },
    		prefixFilter(/*$$restProps*/ ctx[41], 'input$')
    	];

    	function textarea_1_value_binding(value) {
    		/*textarea_1_value_binding*/ ctx[56](value);
    	}

    	function textarea_1_dirty_binding(value) {
    		/*textarea_1_dirty_binding*/ ctx[57](value);
    	}

    	function textarea_1_invalid_binding(value) {
    		/*textarea_1_invalid_binding*/ ctx[58](value);
    	}

    	let textarea_1_props = {};

    	for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
    		textarea_1_props = assign$4(textarea_1_props, textarea_1_spread_levels[i]);
    	}

    	if (/*value*/ ctx[0] !== void 0) {
    		textarea_1_props.value = /*value*/ ctx[0];
    	}

    	if (/*dirty*/ ctx[4] !== void 0) {
    		textarea_1_props.dirty = /*dirty*/ ctx[4];
    	}

    	if (/*invalid*/ ctx[1] !== void 0) {
    		textarea_1_props.invalid = /*invalid*/ ctx[1];
    	}

    	textarea_1 = new Textarea({ props: textarea_1_props, $$inline: true });
    	/*textarea_1_binding*/ ctx[55](textarea_1);
    	binding_callbacks.push(() => bind(textarea_1, 'value', textarea_1_value_binding));
    	binding_callbacks.push(() => bind(textarea_1, 'dirty', textarea_1_dirty_binding));
    	binding_callbacks.push(() => bind(textarea_1, 'invalid', textarea_1_invalid_binding));
    	textarea_1.$on("blur", /*blur_handler*/ ctx[59]);
    	textarea_1.$on("focus", /*focus_handler*/ ctx[60]);
    	textarea_1.$on("blur", /*blur_handler_1*/ ctx[61]);
    	textarea_1.$on("focus", /*focus_handler_1*/ ctx[62]);
    	const internalCounter_slot_template = /*#slots*/ ctx[51].internalCounter;
    	const internalCounter_slot = create_slot(internalCounter_slot_template, ctx, /*$$scope*/ ctx[90], get_internalCounter_slot_context);

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(textarea_1.$$.fragment);
    			t = space();
    			if (internalCounter_slot) internalCounter_slot.c();

    			attr_dev(span, "class", span_class_value = classMap({
    				'mdc-text-field__resizer': !('input$resizable' in /*$$restProps*/ ctx[41]) || /*$$restProps*/ ctx[41].input$resizable
    			}));

    			add_location(span, file$3, 99, 6, 3514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(textarea_1, span, null);
    			append_dev(span, t);

    			if (internalCounter_slot) {
    				internalCounter_slot.m(span, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textarea_1_changes = (dirty[0] & /*disabled, required, updateInvalid, helperId*/ 134754304 | dirty[1] & /*$$restProps*/ 1024)
    			? get_spread_update(textarea_1_spread_levels, [
    					dirty[0] & /*disabled*/ 4096 && { disabled: /*disabled*/ ctx[12] },
    					dirty[0] & /*required*/ 8192 && { required: /*required*/ ctx[13] },
    					dirty[0] & /*updateInvalid*/ 524288 && { updateInvalid: /*updateInvalid*/ ctx[19] },
    					dirty[0] & /*helperId*/ 134217728 && { "aria-controls": /*helperId*/ ctx[27] },
    					dirty[0] & /*helperId*/ 134217728 && { "aria-describedby": /*helperId*/ ctx[27] },
    					dirty[1] & /*$$restProps*/ 1024 && get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'input$'))
    				])
    			: {};

    			if (!updating_value && dirty[0] & /*value*/ 1) {
    				updating_value = true;
    				textarea_1_changes.value = /*value*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_dirty && dirty[0] & /*dirty*/ 16) {
    				updating_dirty = true;
    				textarea_1_changes.dirty = /*dirty*/ ctx[4];
    				add_flush_callback(() => updating_dirty = false);
    			}

    			if (!updating_invalid && dirty[0] & /*invalid*/ 2) {
    				updating_invalid = true;
    				textarea_1_changes.invalid = /*invalid*/ ctx[1];
    				add_flush_callback(() => updating_invalid = false);
    			}

    			textarea_1.$set(textarea_1_changes);

    			if (internalCounter_slot) {
    				if (internalCounter_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						internalCounter_slot,
    						internalCounter_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(internalCounter_slot_template, /*$$scope*/ ctx[90], dirty, get_internalCounter_slot_changes),
    						get_internalCounter_slot_context
    					);
    				}
    			}

    			if (!current || dirty[1] & /*$$restProps*/ 1024 && span_class_value !== (span_class_value = classMap({
    				'mdc-text-field__resizer': !('input$resizable' in /*$$restProps*/ ctx[41]) || /*$$restProps*/ ctx[41].input$resizable
    			}))) {
    				attr_dev(span, "class", span_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textarea_1.$$.fragment, local);
    			transition_in(internalCounter_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textarea_1.$$.fragment, local);
    			transition_out(internalCounter_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			/*textarea_1_binding*/ ctx[55](null);
    			destroy_component(textarea_1);
    			if (internalCounter_slot) internalCounter_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(99:4) {#if textarea && typeof value === 'string'}",
    		ctx
    	});

    	return block;
    }

    // (126:6) {#if prefix != null}
    function create_if_block_5(ctx) {
    	let prefix_1;
    	let current;

    	prefix_1 = new Prefix({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(prefix_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(prefix_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const prefix_1_changes = {};

    			if (dirty[0] & /*prefix*/ 1048576 | dirty[2] & /*$$scope*/ 268435456) {
    				prefix_1_changes.$$scope = { dirty, ctx };
    			}

    			prefix_1.$set(prefix_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(prefix_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(prefix_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(prefix_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(126:6) {#if prefix != null}",
    		ctx
    	});

    	return block;
    }

    // (127:8) <Prefix>
    function create_default_slot_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*prefix*/ ctx[20]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*prefix*/ 1048576) set_data_dev(t, /*prefix*/ ctx[20]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(127:8) <Prefix>",
    		ctx
    	});

    	return block;
    }

    // (148:6) {#if suffix != null}
    function create_if_block_4(ctx) {
    	let suffix_1;
    	let current;

    	suffix_1 = new Suffix({
    			props: {
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(suffix_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(suffix_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const suffix_1_changes = {};

    			if (dirty[0] & /*suffix*/ 2097152 | dirty[2] & /*$$scope*/ 268435456) {
    				suffix_1_changes.$$scope = { dirty, ctx };
    			}

    			suffix_1.$set(suffix_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(suffix_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(suffix_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(suffix_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(148:6) {#if suffix != null}",
    		ctx
    	});

    	return block;
    }

    // (149:8) <Suffix>
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*suffix*/ ctx[21]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*suffix*/ 2097152) set_data_dev(t, /*suffix*/ ctx[21]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(149:8) <Suffix>",
    		ctx
    	});

    	return block;
    }

    // (153:4) <ContextFragment key="SMUI:textfield:icon:leading" value={false}>
    function create_default_slot_1(ctx) {
    	let current;
    	const trailingIcon_slot_template = /*#slots*/ ctx[51].trailingIcon;
    	const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, /*$$scope*/ ctx[90], get_trailingIcon_slot_context);

    	const block = {
    		c: function create() {
    			if (trailingIcon_slot) trailingIcon_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (trailingIcon_slot) {
    				trailingIcon_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (trailingIcon_slot) {
    				if (trailingIcon_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						trailingIcon_slot,
    						trailingIcon_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(trailingIcon_slot_template, /*$$scope*/ ctx[90], dirty, get_trailingIcon_slot_changes),
    						get_trailingIcon_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(trailingIcon_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(trailingIcon_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (trailingIcon_slot) trailingIcon_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(153:4) <ContextFragment key=\\\"SMUI:textfield:icon:leading\\\" value={false}>",
    		ctx
    	});

    	return block;
    }

    // (156:4) {#if !textarea && variant !== 'outlined' && ripple}
    function create_if_block_2$1(ctx) {
    	let lineripple;
    	let current;
    	const lineripple_spread_levels = [prefixFilter(/*$$restProps*/ ctx[41], 'ripple$')];
    	let lineripple_props = {};

    	for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    		lineripple_props = assign$4(lineripple_props, lineripple_spread_levels[i]);
    	}

    	lineripple = new LineRipple({ props: lineripple_props, $$inline: true });
    	/*lineripple_binding*/ ctx[72](lineripple);

    	const block = {
    		c: function create() {
    			create_component(lineripple.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(lineripple, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const lineripple_changes = (dirty[1] & /*$$restProps*/ 1024)
    			? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'ripple$'))])
    			: {};

    			lineripple.$set(lineripple_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lineripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lineripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			/*lineripple_binding*/ ctx[72](null);
    			destroy_component(lineripple, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(156:4) {#if !textarea && variant !== 'outlined' && ripple}",
    		ctx
    	});

    	return block;
    }

    // (217:0) {#if $$slots.helper}
    function create_if_block$2(ctx) {
    	let helperline;
    	let current;
    	const helperline_spread_levels = [prefixFilter(/*$$restProps*/ ctx[41], 'helperLine$')];

    	let helperline_props = {
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};

    	for (let i = 0; i < helperline_spread_levels.length; i += 1) {
    		helperline_props = assign$4(helperline_props, helperline_spread_levels[i]);
    	}

    	helperline = new HelperLine({ props: helperline_props, $$inline: true });
    	helperline.$on("SMUITextfieldHelperText:id", /*SMUITextfieldHelperText_id_handler*/ ctx[85]);
    	helperline.$on("SMUITextfieldHelperText:mount", /*SMUITextfieldHelperText_mount_handler*/ ctx[86]);
    	helperline.$on("SMUITextfieldHelperText:unmount", /*SMUITextfieldHelperText_unmount_handler*/ ctx[87]);
    	helperline.$on("SMUITextfieldCharacterCounter:mount", /*SMUITextfieldCharacterCounter_mount_handler_1*/ ctx[88]);
    	helperline.$on("SMUITextfieldCharacterCounter:unmount", /*SMUITextfieldCharacterCounter_unmount_handler_1*/ ctx[89]);

    	const block = {
    		c: function create() {
    			create_component(helperline.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(helperline, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const helperline_changes = (dirty[1] & /*$$restProps*/ 1024)
    			? get_spread_update(helperline_spread_levels, [get_spread_object(prefixFilter(/*$$restProps*/ ctx[41], 'helperLine$'))])
    			: {};

    			if (dirty[2] & /*$$scope*/ 268435456) {
    				helperline_changes.$$scope = { dirty, ctx };
    			}

    			helperline.$set(helperline_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(helperline.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(helperline.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(helperline, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(217:0) {#if $$slots.helper}",
    		ctx
    	});

    	return block;
    }

    // (218:2) <HelperLine     on:SMUITextfieldHelperText:id={(event) => (helperId = event.detail)}     on:SMUITextfieldHelperText:mount={(event) => (helperText = event.detail)}     on:SMUITextfieldHelperText:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     on:SMUITextfieldCharacterCounter:mount={(event) =>       (characterCounter = event.detail)}     on:SMUITextfieldCharacterCounter:unmount={() =>       (characterCounter = undefined)}     {...prefixFilter($$restProps, 'helperLine$')}     >
    function create_default_slot$1(ctx) {
    	let current;
    	const helper_slot_template = /*#slots*/ ctx[51].helper;
    	const helper_slot = create_slot(helper_slot_template, ctx, /*$$scope*/ ctx[90], get_helper_slot_context);

    	const block = {
    		c: function create() {
    			if (helper_slot) helper_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (helper_slot) {
    				helper_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (helper_slot) {
    				if (helper_slot.p && (!current || dirty[2] & /*$$scope*/ 268435456)) {
    					update_slot_base(
    						helper_slot,
    						helper_slot_template,
    						ctx,
    						/*$$scope*/ ctx[90],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[90])
    						: get_slot_changes(helper_slot_template, /*$$scope*/ ctx[90], dirty, get_helper_slot_changes),
    						get_helper_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(helper_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(helper_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (helper_slot) helper_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(218:2) <HelperLine     on:SMUITextfieldHelperText:id={(event) => (helperId = event.detail)}     on:SMUITextfieldHelperText:mount={(event) => (helperText = event.detail)}     on:SMUITextfieldHelperText:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     on:SMUITextfieldCharacterCounter:mount={(event) =>       (characterCounter = event.detail)}     on:SMUITextfieldCharacterCounter:unmount={() =>       (characterCounter = undefined)}     {...prefixFilter($$restProps, 'helperLine$')}     >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$2, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*valued*/ ctx[36]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*$$slots*/ ctx[42].helper && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block0.p(ctx, dirty);

    			if (/*$$slots*/ ctx[42].helper) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[1] & /*$$slots*/ 2048) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = ([name, value]) => `${name}: ${value};`;
    const func_1 = ([name, value]) => `${name}: ${value};`;

    function instance_1($$self, $$props, $$invalidate) {
    	let inputElement;

    	const omit_props_names = [
    		"use","class","style","ripple","disabled","required","textarea","variant","noLabel","label","type","value","files","invalid","updateInvalid","dirty","prefix","suffix","validateOnValueChange","useNativeValidation","withLeadingIcon","withTrailingIcon","input","floatingLabel","lineRipple","notchedOutline","focus","blur","layout","getElement"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;

    	validate_slots('Textfield', slots, [
    		'label','leadingIcon','default','internalCounter','prefix','suffix','trailingIcon','ripple','helper'
    	]);

    	const $$slots = compute_slots(slots);
    	const { applyPassive } = events;
    	const forwardEvents = forwardEventsBuilder(get_current_component());

    	let uninitializedValue = () => {
    		
    	};

    	function isUninitializedValue(value) {
    		return value === uninitializedValue;
    	}

    	let { use = [] } = $$props;
    	let { class: className = '' } = $$props;
    	let { style = '' } = $$props;
    	let { ripple = true } = $$props;
    	let { disabled = false } = $$props;
    	let { required = false } = $$props;
    	let { textarea = false } = $$props;
    	let { variant = textarea ? 'outlined' : 'standard' } = $$props;
    	let { noLabel = false } = $$props;
    	let { label = undefined } = $$props;
    	let { type = 'text' } = $$props;

    	let { value = $$restProps.input$emptyValueUndefined
    	? undefined
    	: uninitializedValue } = $$props;

    	let { files = uninitializedValue } = $$props;
    	const valued = !isUninitializedValue(value) || !isUninitializedValue(files);

    	if (isUninitializedValue(value)) {
    		value = undefined;
    	}

    	if (isUninitializedValue(files)) {
    		files = null;
    	}

    	let { invalid = uninitializedValue } = $$props;
    	let { updateInvalid = isUninitializedValue(invalid) } = $$props;

    	if (isUninitializedValue(invalid)) {
    		invalid = false;
    	}

    	let { dirty = false } = $$props;
    	let { prefix = undefined } = $$props;
    	let { suffix = undefined } = $$props;
    	let { validateOnValueChange = updateInvalid } = $$props;
    	let { useNativeValidation = updateInvalid } = $$props;
    	let { withLeadingIcon = uninitializedValue } = $$props;
    	let { withTrailingIcon = uninitializedValue } = $$props;
    	let { input = undefined } = $$props;
    	let { floatingLabel = undefined } = $$props;
    	let { lineRipple = undefined } = $$props;
    	let { notchedOutline = undefined } = $$props;
    	let element;
    	let instance;
    	let internalClasses = {};
    	let internalStyles = {};
    	let helperId = undefined;
    	let focused = false;
    	let addLayoutListener = getContext('SMUI:addLayoutListener');
    	let removeLayoutListener;
    	let initPromiseResolve;
    	let initPromise = new Promise(resolve => initPromiseResolve = resolve);

    	// These are instances, not accessors.
    	let leadingIcon = undefined;

    	let trailingIcon = undefined;
    	let helperText = undefined;
    	let characterCounter = undefined;

    	// React to changes of value from outside component.
    	let previousValue = value;

    	if (addLayoutListener) {
    		removeLayoutListener = addLayoutListener(layout);
    	}

    	onMount(() => {
    		$$invalidate(49, instance = new MDCTextFieldFoundation({
    				// getRootAdapterMethods_
    				addClass,
    				removeClass,
    				hasClass,
    				registerTextFieldInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
    				deregisterTextFieldInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler),
    				registerValidationAttributeChangeHandler: handler => {
    					const getAttributesList = mutationsList => {
    						return mutationsList.map(mutation => mutation.attributeName).filter(attributeName => attributeName);
    					};

    					const observer = new MutationObserver(mutationsList => {
    							if (useNativeValidation) {
    								handler(getAttributesList(mutationsList));
    							}
    						});

    					const config = { attributes: true };

    					if (input) {
    						observer.observe(input.getElement(), config);
    					}

    					return observer;
    				},
    				deregisterValidationAttributeChangeHandler: observer => {
    					observer.disconnect();
    				},
    				// getInputAdapterMethods_
    				getNativeInput: () => {
    					var _a;

    					return (_a = input === null || input === void 0
    					? void 0
    					: input.getElement()) !== null && _a !== void 0
    					? _a
    					: null;
    				},
    				setInputAttr: (name, value) => {
    					input === null || input === void 0
    					? void 0
    					: input.addAttr(name, value);
    				},
    				removeInputAttr: name => {
    					input === null || input === void 0
    					? void 0
    					: input.removeAttr(name);
    				},
    				isFocused: () => document.activeElement === (input === null || input === void 0
    				? void 0
    				: input.getElement()),
    				registerInputInteractionHandler: (evtType, handler) => {
    					input === null || input === void 0
    					? void 0
    					: input.getElement().addEventListener(evtType, handler, applyPassive());
    				},
    				deregisterInputInteractionHandler: (evtType, handler) => {
    					input === null || input === void 0
    					? void 0
    					: input.getElement().removeEventListener(evtType, handler, applyPassive());
    				},
    				// getLabelAdapterMethods_
    				floatLabel: shouldFloat => floatingLabel && floatingLabel.float(shouldFloat),
    				getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
    				hasLabel: () => !!floatingLabel,
    				shakeLabel: shouldShake => floatingLabel && floatingLabel.shake(shouldShake),
    				setLabelRequired: isRequired => floatingLabel && floatingLabel.setRequired(isRequired),
    				// getLineRippleAdapterMethods_
    				activateLineRipple: () => lineRipple && lineRipple.activate(),
    				deactivateLineRipple: () => lineRipple && lineRipple.deactivate(),
    				setLineRippleTransformOrigin: normalizedX => lineRipple && lineRipple.setRippleCenter(normalizedX),
    				// getOutlineAdapterMethods_
    				closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
    				hasOutline: () => !!notchedOutline,
    				notchOutline: labelWidth => notchedOutline && notchedOutline.notch(labelWidth)
    			},
    		{
    				get helperText() {
    					return helperText;
    				},
    				get characterCounter() {
    					return characterCounter;
    				},
    				get leadingIcon() {
    					return leadingIcon;
    				},
    				get trailingIcon() {
    					return trailingIcon;
    				}
    			}));

    		if (valued) {
    			if (input == null) {
    				throw new Error('SMUI Textfield initialized without Input component.');
    			}

    			instance.init();
    		} else {
    			tick().then(() => {
    				if (input == null) {
    					throw new Error('SMUI Textfield initialized without Input component.');
    				}

    				instance.init();
    			});
    		}

    		initPromiseResolve();

    		return () => {
    			instance.destroy();
    		};
    	});

    	onDestroy(() => {
    		if (removeLayoutListener) {
    			removeLayoutListener();
    		}
    	});

    	function hasClass(className) {
    		var _a;

    		return className in internalClasses
    		? (_a = internalClasses[className]) !== null && _a !== void 0
    			? _a
    			: null
    		: getElement().classList.contains(className);
    	}

    	function addClass(className) {
    		if (!internalClasses[className]) {
    			$$invalidate(25, internalClasses[className] = true, internalClasses);
    		}
    	}

    	function removeClass(className) {
    		if (!(className in internalClasses) || internalClasses[className]) {
    			$$invalidate(25, internalClasses[className] = false, internalClasses);
    		}
    	}

    	function addStyle(name, value) {
    		if (internalStyles[name] != value) {
    			if (value === '' || value == null) {
    				delete internalStyles[name];
    				$$invalidate(26, internalStyles);
    			} else {
    				$$invalidate(26, internalStyles[name] = value, internalStyles);
    			}
    		}
    	}

    	function focus() {
    		input === null || input === void 0
    		? void 0
    		: input.focus();
    	}

    	function blur() {
    		input === null || input === void 0
    		? void 0
    		: input.blur();
    	}

    	function layout() {
    		if (instance) {
    			const openNotch = instance.shouldFloat;
    			instance.notchOutline(openNotch);
    		}
    	}

    	function getElement() {
    		return element;
    	}

    	function floatinglabel_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			floatingLabel = $$value;
    			$$invalidate(5, floatingLabel);
    		});
    	}

    	function floatinglabel_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			floatingLabel = $$value;
    			$$invalidate(5, floatingLabel);
    		});
    	}

    	function notchedoutline_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			notchedOutline = $$value;
    			$$invalidate(7, notchedOutline);
    		});
    	}

    	function textarea_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(2, input);
    		});
    	}

    	function textarea_1_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	function textarea_1_dirty_binding(value) {
    		dirty = value;
    		$$invalidate(4, dirty);
    	}

    	function textarea_1_invalid_binding(value) {
    		invalid = value;
    		(($$invalidate(1, invalid), $$invalidate(49, instance)), $$invalidate(19, updateInvalid));
    	}

    	const blur_handler = () => $$invalidate(28, focused = false);
    	const focus_handler = () => $$invalidate(28, focused = true);
    	const blur_handler_1 = event => dispatch(element, 'blur', event);
    	const focus_handler_1 = event => dispatch(element, 'focus', event);

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(2, input);
    		});
    	}

    	function input_1_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(0, value);
    	}

    	function input_1_files_binding(value) {
    		files = value;
    		$$invalidate(3, files);
    	}

    	function input_1_dirty_binding(value) {
    		dirty = value;
    		$$invalidate(4, dirty);
    	}

    	function input_1_invalid_binding(value) {
    		invalid = value;
    		(($$invalidate(1, invalid), $$invalidate(49, instance)), $$invalidate(19, updateInvalid));
    	}

    	const blur_handler_2 = () => $$invalidate(28, focused = false);
    	const focus_handler_2 = () => $$invalidate(28, focused = true);
    	const blur_handler_3 = event => dispatch(element, 'blur', event);
    	const focus_handler_3 = event => dispatch(element, 'focus', event);

    	function lineripple_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			lineRipple = $$value;
    			$$invalidate(6, lineRipple);
    		});
    	}

    	function label_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(24, element);
    		});
    	}

    	const SMUITextfieldLeadingIcon_mount_handler = event => $$invalidate(29, leadingIcon = event.detail);
    	const SMUITextfieldLeadingIcon_unmount_handler = () => $$invalidate(29, leadingIcon = undefined);
    	const SMUITextfieldTrailingIcon_mount_handler = event => $$invalidate(30, trailingIcon = event.detail);
    	const SMUITextfieldTrailingIcon_unmount_handler = () => $$invalidate(30, trailingIcon = undefined);
    	const SMUITextfieldCharacterCounter_mount_handler = event => $$invalidate(32, characterCounter = event.detail);
    	const SMUITextfieldCharacterCounter_unmount_handler = () => $$invalidate(32, characterCounter = undefined);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(24, element);
    		});
    	}

    	const SMUITextfieldLeadingIcon_mount_handler_1 = event => $$invalidate(29, leadingIcon = event.detail);
    	const SMUITextfieldLeadingIcon_unmount_handler_1 = () => $$invalidate(29, leadingIcon = undefined);
    	const SMUITextfieldTrailingIcon_mount_handler_1 = event => $$invalidate(30, trailingIcon = event.detail);
    	const SMUITextfieldTrailingIcon_unmount_handler_1 = () => $$invalidate(30, trailingIcon = undefined);
    	const SMUITextfieldHelperText_id_handler = event => $$invalidate(27, helperId = event.detail);
    	const SMUITextfieldHelperText_mount_handler = event => $$invalidate(31, helperText = event.detail);

    	const SMUITextfieldHelperText_unmount_handler = () => {
    		$$invalidate(27, helperId = undefined);
    		$$invalidate(31, helperText = undefined);
    	};

    	const SMUITextfieldCharacterCounter_mount_handler_1 = event => $$invalidate(32, characterCounter = event.detail);
    	const SMUITextfieldCharacterCounter_unmount_handler_1 = () => $$invalidate(32, characterCounter = undefined);

    	$$self.$$set = $$new_props => {
    		$$props = assign$4(assign$4({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(41, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('use' in $$new_props) $$invalidate(8, use = $$new_props.use);
    		if ('class' in $$new_props) $$invalidate(9, className = $$new_props.class);
    		if ('style' in $$new_props) $$invalidate(10, style = $$new_props.style);
    		if ('ripple' in $$new_props) $$invalidate(11, ripple = $$new_props.ripple);
    		if ('disabled' in $$new_props) $$invalidate(12, disabled = $$new_props.disabled);
    		if ('required' in $$new_props) $$invalidate(13, required = $$new_props.required);
    		if ('textarea' in $$new_props) $$invalidate(14, textarea = $$new_props.textarea);
    		if ('variant' in $$new_props) $$invalidate(15, variant = $$new_props.variant);
    		if ('noLabel' in $$new_props) $$invalidate(16, noLabel = $$new_props.noLabel);
    		if ('label' in $$new_props) $$invalidate(17, label = $$new_props.label);
    		if ('type' in $$new_props) $$invalidate(18, type = $$new_props.type);
    		if ('value' in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ('files' in $$new_props) $$invalidate(3, files = $$new_props.files);
    		if ('invalid' in $$new_props) $$invalidate(1, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$new_props) $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    		if ('dirty' in $$new_props) $$invalidate(4, dirty = $$new_props.dirty);
    		if ('prefix' in $$new_props) $$invalidate(20, prefix = $$new_props.prefix);
    		if ('suffix' in $$new_props) $$invalidate(21, suffix = $$new_props.suffix);
    		if ('validateOnValueChange' in $$new_props) $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    		if ('useNativeValidation' in $$new_props) $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    		if ('withLeadingIcon' in $$new_props) $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    		if ('withTrailingIcon' in $$new_props) $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    		if ('input' in $$new_props) $$invalidate(2, input = $$new_props.input);
    		if ('floatingLabel' in $$new_props) $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    		if ('lineRipple' in $$new_props) $$invalidate(6, lineRipple = $$new_props.lineRipple);
    		if ('notchedOutline' in $$new_props) $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    		if ('$$scope' in $$new_props) $$invalidate(90, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		MDCTextFieldFoundation,
    		events,
    		onMount,
    		onDestroy,
    		getContext,
    		tick,
    		get_current_component,
    		forwardEventsBuilder,
    		classMap,
    		exclude,
    		prefixFilter,
    		useActions,
    		dispatch,
    		ContextFragment,
    		Ripple,
    		FloatingLabel,
    		LineRipple,
    		NotchedOutline,
    		HelperLine,
    		Prefix,
    		Suffix,
    		Input,
    		Textarea,
    		applyPassive,
    		forwardEvents,
    		uninitializedValue,
    		isUninitializedValue,
    		use,
    		className,
    		style,
    		ripple,
    		disabled,
    		required,
    		textarea,
    		variant,
    		noLabel,
    		label,
    		type,
    		value,
    		files,
    		valued,
    		invalid,
    		updateInvalid,
    		dirty,
    		prefix,
    		suffix,
    		validateOnValueChange,
    		useNativeValidation,
    		withLeadingIcon,
    		withTrailingIcon,
    		input,
    		floatingLabel,
    		lineRipple,
    		notchedOutline,
    		element,
    		instance,
    		internalClasses,
    		internalStyles,
    		helperId,
    		focused,
    		addLayoutListener,
    		removeLayoutListener,
    		initPromiseResolve,
    		initPromise,
    		leadingIcon,
    		trailingIcon,
    		helperText,
    		characterCounter,
    		previousValue,
    		hasClass,
    		addClass,
    		removeClass,
    		addStyle,
    		focus,
    		blur,
    		layout,
    		getElement,
    		inputElement
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('uninitializedValue' in $$props) uninitializedValue = $$new_props.uninitializedValue;
    		if ('use' in $$props) $$invalidate(8, use = $$new_props.use);
    		if ('className' in $$props) $$invalidate(9, className = $$new_props.className);
    		if ('style' in $$props) $$invalidate(10, style = $$new_props.style);
    		if ('ripple' in $$props) $$invalidate(11, ripple = $$new_props.ripple);
    		if ('disabled' in $$props) $$invalidate(12, disabled = $$new_props.disabled);
    		if ('required' in $$props) $$invalidate(13, required = $$new_props.required);
    		if ('textarea' in $$props) $$invalidate(14, textarea = $$new_props.textarea);
    		if ('variant' in $$props) $$invalidate(15, variant = $$new_props.variant);
    		if ('noLabel' in $$props) $$invalidate(16, noLabel = $$new_props.noLabel);
    		if ('label' in $$props) $$invalidate(17, label = $$new_props.label);
    		if ('type' in $$props) $$invalidate(18, type = $$new_props.type);
    		if ('value' in $$props) $$invalidate(0, value = $$new_props.value);
    		if ('files' in $$props) $$invalidate(3, files = $$new_props.files);
    		if ('invalid' in $$props) $$invalidate(1, invalid = $$new_props.invalid);
    		if ('updateInvalid' in $$props) $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    		if ('dirty' in $$props) $$invalidate(4, dirty = $$new_props.dirty);
    		if ('prefix' in $$props) $$invalidate(20, prefix = $$new_props.prefix);
    		if ('suffix' in $$props) $$invalidate(21, suffix = $$new_props.suffix);
    		if ('validateOnValueChange' in $$props) $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    		if ('useNativeValidation' in $$props) $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    		if ('withLeadingIcon' in $$props) $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    		if ('withTrailingIcon' in $$props) $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    		if ('input' in $$props) $$invalidate(2, input = $$new_props.input);
    		if ('floatingLabel' in $$props) $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    		if ('lineRipple' in $$props) $$invalidate(6, lineRipple = $$new_props.lineRipple);
    		if ('notchedOutline' in $$props) $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    		if ('element' in $$props) $$invalidate(24, element = $$new_props.element);
    		if ('instance' in $$props) $$invalidate(49, instance = $$new_props.instance);
    		if ('internalClasses' in $$props) $$invalidate(25, internalClasses = $$new_props.internalClasses);
    		if ('internalStyles' in $$props) $$invalidate(26, internalStyles = $$new_props.internalStyles);
    		if ('helperId' in $$props) $$invalidate(27, helperId = $$new_props.helperId);
    		if ('focused' in $$props) $$invalidate(28, focused = $$new_props.focused);
    		if ('addLayoutListener' in $$props) addLayoutListener = $$new_props.addLayoutListener;
    		if ('removeLayoutListener' in $$props) removeLayoutListener = $$new_props.removeLayoutListener;
    		if ('initPromiseResolve' in $$props) initPromiseResolve = $$new_props.initPromiseResolve;
    		if ('initPromise' in $$props) $$invalidate(37, initPromise = $$new_props.initPromise);
    		if ('leadingIcon' in $$props) $$invalidate(29, leadingIcon = $$new_props.leadingIcon);
    		if ('trailingIcon' in $$props) $$invalidate(30, trailingIcon = $$new_props.trailingIcon);
    		if ('helperText' in $$props) $$invalidate(31, helperText = $$new_props.helperText);
    		if ('characterCounter' in $$props) $$invalidate(32, characterCounter = $$new_props.characterCounter);
    		if ('previousValue' in $$props) $$invalidate(50, previousValue = $$new_props.previousValue);
    		if ('inputElement' in $$props) $$invalidate(33, inputElement = $$new_props.inputElement);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*input*/ 4) {
    			$$invalidate(33, inputElement = input && input.getElement());
    		}

    		if ($$self.$$.dirty[0] & /*invalid, updateInvalid*/ 524290 | $$self.$$.dirty[1] & /*instance*/ 262144) {
    			if (instance && instance.isValid() !== !invalid) {
    				if (updateInvalid) {
    					$$invalidate(1, invalid = !instance.isValid());
    				} else {
    					instance.setValid(!invalid);
    				}
    			}
    		}

    		if ($$self.$$.dirty[1] & /*instance, validateOnValueChange*/ 266240) {
    			if (instance && instance.getValidateOnValueChange() !== validateOnValueChange) {
    				instance.setValidateOnValueChange(isUninitializedValue(validateOnValueChange)
    				? false
    				: validateOnValueChange);
    			}
    		}

    		if ($$self.$$.dirty[1] & /*instance, useNativeValidation*/ 270336) {
    			if (instance) {
    				instance.setUseNativeValidation(isUninitializedValue(useNativeValidation)
    				? true
    				: useNativeValidation);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*disabled*/ 4096 | $$self.$$.dirty[1] & /*instance*/ 262144) {
    			if (instance) {
    				instance.setDisabled(disabled);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*value*/ 1 | $$self.$$.dirty[1] & /*instance, previousValue*/ 786432) {
    			if (instance && valued && previousValue !== value) {
    				$$invalidate(50, previousValue = value);

    				// Check the data is flowing down.
    				const stringValue = `${value}`;

    				if (instance.getValue() !== stringValue) {
    					instance.setValue(stringValue);
    				}
    			}
    		}
    	};

    	return [
    		value,
    		invalid,
    		input,
    		files,
    		dirty,
    		floatingLabel,
    		lineRipple,
    		notchedOutline,
    		use,
    		className,
    		style,
    		ripple,
    		disabled,
    		required,
    		textarea,
    		variant,
    		noLabel,
    		label,
    		type,
    		updateInvalid,
    		prefix,
    		suffix,
    		withLeadingIcon,
    		withTrailingIcon,
    		element,
    		internalClasses,
    		internalStyles,
    		helperId,
    		focused,
    		leadingIcon,
    		trailingIcon,
    		helperText,
    		characterCounter,
    		inputElement,
    		forwardEvents,
    		isUninitializedValue,
    		valued,
    		initPromise,
    		addClass,
    		removeClass,
    		addStyle,
    		$$restProps,
    		$$slots,
    		validateOnValueChange,
    		useNativeValidation,
    		focus,
    		blur,
    		layout,
    		getElement,
    		instance,
    		previousValue,
    		slots,
    		floatinglabel_binding,
    		floatinglabel_binding_1,
    		notchedoutline_binding,
    		textarea_1_binding,
    		textarea_1_value_binding,
    		textarea_1_dirty_binding,
    		textarea_1_invalid_binding,
    		blur_handler,
    		focus_handler,
    		blur_handler_1,
    		focus_handler_1,
    		input_1_binding,
    		input_1_value_binding,
    		input_1_files_binding,
    		input_1_dirty_binding,
    		input_1_invalid_binding,
    		blur_handler_2,
    		focus_handler_2,
    		blur_handler_3,
    		focus_handler_3,
    		lineripple_binding,
    		label_1_binding,
    		SMUITextfieldLeadingIcon_mount_handler,
    		SMUITextfieldLeadingIcon_unmount_handler,
    		SMUITextfieldTrailingIcon_mount_handler,
    		SMUITextfieldTrailingIcon_unmount_handler,
    		SMUITextfieldCharacterCounter_mount_handler,
    		SMUITextfieldCharacterCounter_unmount_handler,
    		div_binding,
    		SMUITextfieldLeadingIcon_mount_handler_1,
    		SMUITextfieldLeadingIcon_unmount_handler_1,
    		SMUITextfieldTrailingIcon_mount_handler_1,
    		SMUITextfieldTrailingIcon_unmount_handler_1,
    		SMUITextfieldHelperText_id_handler,
    		SMUITextfieldHelperText_mount_handler,
    		SMUITextfieldHelperText_unmount_handler,
    		SMUITextfieldCharacterCounter_mount_handler_1,
    		SMUITextfieldCharacterCounter_unmount_handler_1,
    		$$scope
    	];
    }

    class Textfield extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance_1,
    			create_fragment$3,
    			safe_not_equal,
    			{
    				use: 8,
    				class: 9,
    				style: 10,
    				ripple: 11,
    				disabled: 12,
    				required: 13,
    				textarea: 14,
    				variant: 15,
    				noLabel: 16,
    				label: 17,
    				type: 18,
    				value: 0,
    				files: 3,
    				invalid: 1,
    				updateInvalid: 19,
    				dirty: 4,
    				prefix: 20,
    				suffix: 21,
    				validateOnValueChange: 43,
    				useNativeValidation: 44,
    				withLeadingIcon: 22,
    				withTrailingIcon: 23,
    				input: 2,
    				floatingLabel: 5,
    				lineRipple: 6,
    				notchedOutline: 7,
    				focus: 45,
    				blur: 46,
    				layout: 47,
    				getElement: 48
    			},
    			null,
    			[-1, -1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textfield",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get use() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set use(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ripple() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ripple(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textarea() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textarea(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLabel() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLabel(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get files() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set files(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get updateInvalid() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set updateInvalid(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dirty() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dirty(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get suffix() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set suffix(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get validateOnValueChange() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set validateOnValueChange(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useNativeValidation() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useNativeValidation(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withLeadingIcon() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withLeadingIcon(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get withTrailingIcon() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set withTrailingIcon(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get floatingLabel() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set floatingLabel(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lineRipple() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lineRipple(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notchedOutline() {
    		throw new Error_1$1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notchedOutline(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focus() {
    		return this.$$.ctx[45];
    	}

    	set focus(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blur() {
    		return this.$$.ctx[46];
    	}

    	set blur(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		return this.$$.ctx[47];
    	}

    	set layout(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getElement() {
    		return this.$$.ctx[48];
    	}

    	set getElement(value) {
    		throw new Error_1$1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Login.svelte generated by Svelte v3.47.0 */
    const file$2 = "src/components/Login.svelte";

    function add_css$1(target) {
    	append_styles(target, "svelte-1b930v1", ".custom-input.svelte-1b930v1{align-self:center;flex:1;font-style:normal}button.svelte-1b930v1{right:0;border:none;border-radius:0.3em;background-color:rgb(var(--primary));color:rgb(var(--background));padding:0.5em;box-shadow:0 0 18px -4px rgb(var(--primary));cursor:pointer;margin:0.3em 1em;color:rgb(var(--body));border-radius:10px;width:200px;box-shadow:0px 4px 12px rgba(var(--shadow), 0.3)}button.login.svelte-1b930v1{background-color:rgba(var(--primary), 0.2);font-weight:bolder;margin-top:2.5em}button.cancel.svelte-1b930v1{background:rgb(var(--background))}.auth-error.svelte-1b930v1{background-color:rgb(var(--danger));border-radius:0.3em;width:65%;padding:0.6em 0;text-align:center}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9naW4uc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRGRSxhQUFhLGVBQUMsQ0FBQSxBQUNaLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQ1AsVUFBVSxDQUFFLE1BQU0sQUFDcEIsQ0FBQSxBQUVBLE1BQU0sZUFBQyxDQUFBLEFBQ0wsS0FBSyxDQUFFLENBQUMsQ0FDUixNQUFNLENBQUUsSUFBSSxDQUNaLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLGdCQUFnQixDQUFFLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUNyQyxLQUFLLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLENBQzdCLE9BQU8sQ0FBRSxLQUFLLENBQ2QsVUFBVSxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLENBQUMsQ0FDN0MsTUFBTSxDQUFFLE9BQU8sQ0FDZixNQUFNLENBQUUsS0FBSyxDQUFDLEdBQUcsQ0FDakIsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixhQUFhLENBQUUsSUFBSSxDQUNuQixLQUFLLENBQUUsS0FBSyxDQUNaLFVBQVUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDbkQsQ0FBQSxBQUVBLE1BQU0sTUFBTSxlQUFDLENBQUEsQUFDWCxnQkFBZ0IsQ0FBRSxLQUFLLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDM0MsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsVUFBVSxDQUFFLEtBQUssQUFDbkIsQ0FBQSxBQUNBLE1BQU0sT0FBTyxlQUFDLENBQUEsQUFDWixVQUFVLENBQUUsSUFBSSxJQUFJLFlBQVksQ0FBQyxDQUFDLEFBQ3BDLENBQUEsQUFFQSxXQUFXLGVBQUMsQ0FBQSxBQUNWLGdCQUFnQixDQUFFLElBQUksSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUNwQyxhQUFhLENBQUUsS0FBSyxDQUNwQixLQUFLLENBQUUsR0FBRyxDQUNWLE9BQU8sQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUNoQixVQUFVLENBQUUsTUFBTSxBQUNwQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkxvZ2luLnN2ZWx0ZSJdfQ== */");
    }

    // (45:2) {#if authError}
    function create_if_block_1$1(ctx) {
    	let div;
    	let raw_value = /*authError*/ ctx[3].replaceAll("\n", "<br />") + "";
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "auth-error svelte-1b930v1");
    			add_location(div, file$2, 45, 4, 1299);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*authError*/ 8) && raw_value !== (raw_value = /*authError*/ ctx[3].replaceAll("\n", "<br />") + "")) div.innerHTML = raw_value;		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(45:2) {#if authError}",
    		ctx
    	});

    	return block;
    }

    // (52:2) {:else}
    function create_else_block(ctx) {
    	let div0;
    	let textfield0;
    	let updating_value;
    	let t;
    	let div1;
    	let textfield1;
    	let updating_value_1;
    	let current;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[9](value);
    	}

    	let textfield0_props = {
    		type: "text",
    		disabled: !!/*logged_username*/ ctx[0],
    		label: /*$_*/ ctx[4]("login.username-placeholder")
    	};

    	if (/*username*/ ctx[1] !== void 0) {
    		textfield0_props.value = /*username*/ ctx[1];
    	}

    	textfield0 = new Textfield({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, 'value', textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[10](value);
    	}

    	let textfield1_props = {
    		type: "password",
    		disabled: !!/*logged_username*/ ctx[0],
    		label: /*$_*/ ctx[4]("login.password-placeholder")
    	};

    	if (/*password*/ ctx[2] !== void 0) {
    		textfield1_props.value = /*password*/ ctx[2];
    	}

    	textfield1 = new Textfield({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, 'value', textfield1_value_binding));

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(textfield0.$$.fragment);
    			t = space();
    			div1 = element("div");
    			create_component(textfield1.$$.fragment);
    			attr_dev(div0, "class", "custom-input svelte-1b930v1");
    			add_location(div0, file$2, 52, 4, 1504);
    			attr_dev(div1, "class", "custom-input svelte-1b930v1");
    			add_location(div1, file$2, 60, 4, 1708);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(textfield0, div0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(textfield1, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};
    			if (dirty & /*logged_username*/ 1) textfield0_changes.disabled = !!/*logged_username*/ ctx[0];
    			if (dirty & /*$_*/ 16) textfield0_changes.label = /*$_*/ ctx[4]("login.username-placeholder");

    			if (!updating_value && dirty & /*username*/ 2) {
    				updating_value = true;
    				textfield0_changes.value = /*username*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};
    			if (dirty & /*logged_username*/ 1) textfield1_changes.disabled = !!/*logged_username*/ ctx[0];
    			if (dirty & /*$_*/ 16) textfield1_changes.label = /*$_*/ ctx[4]("login.password-placeholder");

    			if (!updating_value_1 && dirty & /*password*/ 4) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*password*/ ctx[2];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(textfield0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    			destroy_component(textfield1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(52:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (50:2) {#if logged_username}
    function create_if_block$1(ctx) {
    	let div;
    	let t0_value = /*$_*/ ctx[4]("login.username") + "";
    	let t0;
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(/*logged_username*/ ctx[0]);
    			add_location(div, file$2, 50, 4, 1438);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$_*/ 16 && t0_value !== (t0_value = /*$_*/ ctx[4]("login.username") + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*logged_username*/ 1) set_data_dev(t2, /*logged_username*/ ctx[0]);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(50:2) {#if logged_username}",
    		ctx
    	});

    	return block;
    }

    // (37:0) <Modal onEscCb={cancel}>
    function create_default_slot(ctx) {
    	let logo;
    	let t0;
    	let h4;
    	let t1_value = /*$_*/ ctx[4]("login.title") + "";
    	let t1;
    	let t2;
    	let div;
    	let t3_value = /*$_*/ ctx[4]("login.description") + "";
    	let t3;
    	let t4;
    	let t5;
    	let current_block_type_index;
    	let if_block1;
    	let t6;
    	let button0;

    	let t7_value = (/*logged_username*/ ctx[0]
    	? /*$_*/ ctx[4]("login.logout")
    	: /*$_*/ ctx[4]("login.login")) + "";

    	let t7;
    	let t8;
    	let button1;
    	let t9_value = /*$_*/ ctx[4]("login.cancel") + "";
    	let t9;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new Logo({ props: { size: "4em" }, $$inline: true });
    	let if_block0 = /*authError*/ ctx[3] && create_if_block_1$1(ctx);
    	const if_block_creators = [create_if_block$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*logged_username*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(logo.$$.fragment);
    			t0 = space();
    			h4 = element("h4");
    			t1 = text(t1_value);
    			t2 = space();
    			div = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if_block1.c();
    			t6 = space();
    			button0 = element("button");
    			t7 = text(t7_value);
    			t8 = space();
    			button1 = element("button");
    			t9 = text(t9_value);
    			set_style(h4, "width", "85%");
    			set_style(h4, "text-align", "center");
    			add_location(h4, file$2, 38, 2, 1101);
    			set_style(div, "width", "85%");
    			set_style(div, "padding", "1em");
    			set_style(div, "text-align", "center");
    			add_location(div, file$2, 41, 2, 1179);
    			attr_dev(button0, "class", "login svelte-1b930v1");
    			add_location(button0, file$2, 70, 2, 1923);
    			attr_dev(button1, "class", "cancel svelte-1b930v1");
    			add_location(button1, file$2, 75, 2, 2099);
    		},
    		m: function mount(target, anchor) {
    			mount_component(logo, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t3);
    			insert_dev(target, t4, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, button0, anchor);
    			append_dev(button0, t7);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, button1, anchor);
    			append_dev(button1, t9);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[11], false, false, false),
    					listen_dev(button1, "click", /*cancel*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$_*/ 16) && t1_value !== (t1_value = /*$_*/ ctx[4]("login.title") + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*$_*/ 16) && t3_value !== (t3_value = /*$_*/ ctx[4]("login.description") + "")) set_data_dev(t3, t3_value);

    			if (/*authError*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*authError*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t5.parentNode, t5);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(t6.parentNode, t6);
    			}

    			if ((!current || dirty & /*logged_username, $_*/ 17) && t7_value !== (t7_value = (/*logged_username*/ ctx[0]
    			? /*$_*/ ctx[4]("login.logout")
    			: /*$_*/ ctx[4]("login.login")) + "")) set_data_dev(t7, t7_value);

    			if ((!current || dirty & /*$_*/ 16) && t9_value !== (t9_value = /*$_*/ ctx[4]("login.cancel") + "")) set_data_dev(t9, t9_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(logo, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t4);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t5);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(37:0) <Modal onEscCb={cancel}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let modal;
    	let current;

    	modal = new Modal({
    			props: {
    				onEscCb: /*cancel*/ ctx[5],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(modal.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const modal_changes = {};

    			if (dirty & /*$$scope, $_, logged_username, password, username, authError*/ 16415) {
    				modal_changes.$$scope = { dirty, ctx };
    			}

    			modal.$set(modal_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $_;
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(4, $_ = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, []);
    	let { logged_username = undefined } = $$props;
    	let { auth_controller } = $$props;
    	let username = "";
    	let password = "";
    	let authError = "";
    	const dispatch = createEventDispatcher();
    	const cancel = () => dispatch("cancel");

    	const handleLogout = () => {
    		// eslint-disable-next-line
    		auth_controller.logout();

    		$$invalidate(2, password = ""); // clear the password
    	};

    	const errorCb = error_msg => {
    		$$invalidate(3, authError = error_msg);
    		$$invalidate(1, username = "");
    		$$invalidate(2, password = "");
    	};

    	const handleLogin = () => {
    		// eslint-disable-next-line
    		auth_controller.login(username, password, errorCb);

    		$$invalidate(2, password = password.replaceAll(/./g, "*")); // overwrite the password
    	};

    	const writable_props = ['logged_username', 'auth_controller'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		username = value;
    		($$invalidate(1, username), $$invalidate(0, logged_username));
    	}

    	function textfield1_value_binding(value) {
    		password = value;
    		($$invalidate(2, password), $$invalidate(0, logged_username));
    	}

    	const click_handler = () => logged_username ? handleLogout() : handleLogin();

    	$$self.$$set = $$props => {
    		if ('logged_username' in $$props) $$invalidate(0, logged_username = $$props.logged_username);
    		if ('auth_controller' in $$props) $$invalidate(8, auth_controller = $$props.auth_controller);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Textfield,
    		fade,
    		Modal,
    		Logo,
    		_: Y,
    		logged_username,
    		auth_controller,
    		username,
    		password,
    		authError,
    		dispatch,
    		cancel,
    		handleLogout,
    		errorCb,
    		handleLogin,
    		$_
    	});

    	$$self.$inject_state = $$props => {
    		if ('logged_username' in $$props) $$invalidate(0, logged_username = $$props.logged_username);
    		if ('auth_controller' in $$props) $$invalidate(8, auth_controller = $$props.auth_controller);
    		if ('username' in $$props) $$invalidate(1, username = $$props.username);
    		if ('password' in $$props) $$invalidate(2, password = $$props.password);
    		if ('authError' in $$props) $$invalidate(3, authError = $$props.authError);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*logged_username*/ 1) {
    			if (logged_username) {
    				$$invalidate(1, username = logged_username);
    				$$invalidate(2, password = "**************");
    			}
    		}

    		if ($$self.$$.dirty & /*username, password*/ 6) {
    			if (username || password) $$invalidate(3, authError = "");
    		}
    	};

    	return [
    		logged_username,
    		username,
    		password,
    		authError,
    		$_,
    		cancel,
    		handleLogout,
    		handleLogin,
    		auth_controller,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		click_handler
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$2, create_fragment$2, safe_not_equal, { logged_username: 0, auth_controller: 8 }, add_css$1);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*auth_controller*/ ctx[8] === undefined && !('auth_controller' in props)) {
    			console.warn("<Login> was created without expected prop 'auth_controller'");
    		}
    	}

    	get logged_username() {
    		throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set logged_username(value) {
    		throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get auth_controller() {
    		throw new Error("<Login>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set auth_controller(value) {
    		throw new Error("<Login>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const mimeCodec = 'video/mp4; codecs="avc1.64001F, mp4a.40.2"';
    const isMseSupported = "MediaSource" in window &&
        "addSourceBuffer" in window.MediaSource.prototype &&
        "appendBuffer" in window.SourceBuffer.prototype &&
        "onupdateend" in window.SourceBuffer.prototype &&
        MediaSource.isTypeSupported(mimeCodec);

    const version = "7f3fb4f-dirty";

    /* src/assets/HideChat.svelte generated by Svelte v3.47.0 */

    const file$1 = "src/assets/HideChat.svelte";

    function create_fragment$1(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			attr_dev(path, "d", "M2 0C0.895386 0 0 0.895416 0 2V33C0 34.1046 0.895386 35 2 35H35V0H2ZM10 7.94202L13.942 4L26.9399 16.998L26.938 17L26.9399 17.002L13.942 30L10 26.058L19.058 17L10 7.94202Z");
    			attr_dev(path, "fill", /*color*/ ctx[0]);
    			add_location(path, file$1, 9, 2, 247);
    			attr_dev(svg, "width", /*width*/ ctx[1]);
    			attr_dev(svg, "height", /*height*/ ctx[2]);
    			attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$1, 8, 0, 177);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 1) {
    				attr_dev(path, "fill", /*color*/ ctx[0]);
    			}

    			if (dirty & /*width*/ 2) {
    				attr_dev(svg, "width", /*width*/ ctx[1]);
    			}

    			if (dirty & /*height*/ 4) {
    				attr_dev(svg, "height", /*height*/ ctx[2]);
    			}

    			if (dirty & /*viewBox*/ 8) {
    				attr_dev(svg, "viewBox", /*viewBox*/ ctx[3]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HideChat', slots, []);
    	let { color = "currentColor" } = $$props;
    	let { size = "2.5em" } = $$props;
    	let { width = size } = $$props;
    	let { height = size } = $$props;
    	let { viewBox = "0 0 35 35" } = $$props;
    	const writable_props = ['color', 'size', 'width', 'height', 'viewBox'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HideChat> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	$$self.$capture_state = () => ({ color, size, width, height, viewBox });

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('size' in $$props) $$invalidate(4, size = $$props.size);
    		if ('width' in $$props) $$invalidate(1, width = $$props.width);
    		if ('height' in $$props) $$invalidate(2, height = $$props.height);
    		if ('viewBox' in $$props) $$invalidate(3, viewBox = $$props.viewBox);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, width, height, viewBox, size];
    }

    class HideChat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$1, create_fragment$1, safe_not_equal, {
    			color: 0,
    			size: 4,
    			width: 1,
    			height: 2,
    			viewBox: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HideChat",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get color() {
    		throw new Error("<HideChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<HideChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<HideChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<HideChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<HideChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<HideChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<HideChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<HideChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get viewBox() {
    		throw new Error("<HideChat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set viewBox(value) {
    		throw new Error("<HideChat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var primary$1="0, 224, 188";var secondary$1="250, 122, 80";var danger$1="249, 219, 223";var shadow$1="100, 100, 100";var body$1="40, 40, 40";var background$1="250, 250, 250";var Light = {primary:primary$1,"primary-dimmed":"131, 205, 193",secondary:secondary$1,danger:danger$1,shadow:shadow$1,body:body$1,background:background$1,"chat-background":"linear-gradient(0deg,rgba(var(--background), 0.8) 0%,rgba(var(--background), 0.1) 100%)","download-button-font":"0, 163, 137","download-button-background":"255, 255, 255"};

    var light = /*#__PURE__*/Object.freeze({
        __proto__: null,
        primary: primary$1,
        secondary: secondary$1,
        danger: danger$1,
        shadow: shadow$1,
        body: body$1,
        background: background$1,
        'default': Light
    });

    function __variableDynamicImportRuntime0__(path) {
      switch (path) {
        case './themes/dark.json': return Promise.resolve().then(function () { return dark$1; });
        case './themes/light.json': return Promise.resolve().then(function () { return light; });
        default: return new Promise(function(resolve, reject) {
          (typeof queueMicrotask === 'function' ? queueMicrotask : setTimeout)(
            reject.bind(null, new Error("Unknown variable dynamic import: " + path))
          );
        })
       }
     }
    const getTheme = async (name) => {
        try {
            const Theme = (await __variableDynamicImportRuntime0__(`./themes/${name}.json`));
            return Theme.default;
        }
        catch {
            return Light;
        }
    };

    /* src/App.svelte generated by Svelte v3.47.0 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;
    const file = "src/App.svelte";

    function add_css(target) {
    	append_styles(target, "svelte-1zv8xk", ".svelte-1zv8xk{color:rgb(var(--body));font-family:var(--font)}.svelte-1zv8xk:golbal(body){background-color:rgb(var(--background))}a:hover{color:rgb(var(--primary))}input:focus{outline:rgba(var(--primary), 0.8) auto 1px}.center-text{display:flex;align-items:center;justify-content:center;border-radius:1em}.full-screen{position:absolute;height:100vh;width:100vw;bottom:0px;left:0px;border-radius:0px !important;z-index:101}.app-container.svelte-1zv8xk{flex-direction:row;display:flex;height:100vh;width:100vw}.hide-chat.svelte-1zv8xk{color:rgba(var(--body), 0.7);align-self:center;border:none;background:none;cursor:pointer;position:relative;padding:0;margin-left:1em}.video.svelte-1zv8xk{flex:7 1;display:flex;flex-direction:column;justify-content:space-between;border-radius:2em}.chat.svelte-1zv8xk{flex:3 1;flex-direction:column;justify-content:space-between;background:var(--chat-background)}.loading.svelte-1zv8xk{background-color:rgb(var(--background));z-index:103}@media only screen and (max-width: 600px){.app-container.svelte-1zv8xk{display:flex;flex-direction:column}.hide-chat.svelte-1zv8xk{display:none}.hide-phone{display:none !important}.video.svelte-1zv8xk{flex-grow:1;border-left:none;border-radius:0px}}@media only screen and (min-width: 600px){.chat.svelte-1zv8xk{max-width:100%;padding:0.5em 0em 0.5em 0.5em;margin:0.5em 0;border-radius:1em;box-shadow:0px 4px 4px rgba(var(--shadow), 0.4);margin-right:0.5em}}.full-screen-chat.svelte-1zv8xk{position:fixed;width:25em;z-index:103;align-self:end;right:8em;bottom:5em}.full-screen-hide.svelte-1zv8xk{display:none}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXBwLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnYUUsY0FBRSxDQUFBLEFBQ0EsS0FBSyxDQUFFLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUN2QixXQUFXLENBQUUsSUFBSSxNQUFNLENBQUMsQUFDMUIsQ0FBQSxjQUVBLFFBQVEsSUFBSSxDQUFDLEFBQUMsQ0FBQSxBQUNaLGdCQUFnQixDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxBQUMxQyxDQUFBLEFBRVEsT0FBTyxBQUFFLENBQUEsQUFDZixLQUFLLENBQUUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEFBQzVCLENBQUEsQUFFUSxXQUFXLEFBQUUsQ0FBQSxBQUNuQixPQUFPLENBQUUsS0FBSyxJQUFJLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQUFDN0MsQ0FBQSxBQUVRLFlBQVksQUFBRSxDQUFBLEFBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsYUFBYSxDQUFFLEdBQUcsQUFDcEIsQ0FBQSxBQUVRLFlBQVksQUFBRSxDQUFBLEFBQ3BCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLE1BQU0sQ0FBRSxLQUFLLENBQ2IsS0FBSyxDQUFFLEtBQUssQ0FDWixNQUFNLENBQUUsR0FBRyxDQUNYLElBQUksQ0FBRSxHQUFHLENBQ1QsYUFBYSxDQUFFLEdBQUcsQ0FBQyxVQUFVLENBQzdCLE9BQU8sQ0FBRSxHQUFHLEFBQ2QsQ0FBQSxBQUVBLGNBQWMsY0FBQyxDQUFBLEFBQ2IsY0FBYyxDQUFFLEdBQUcsQ0FDbkIsT0FBTyxDQUFFLElBQUksQ0FDYixNQUFNLENBQUUsS0FBSyxDQUNiLEtBQUssQ0FBRSxLQUFLLEFBQ2QsQ0FBQSxBQUVBLFVBQVUsY0FBQyxDQUFBLEFBQ1QsS0FBSyxDQUFFLEtBQUssSUFBSSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUM3QixVQUFVLENBQUUsTUFBTSxDQUNsQixNQUFNLENBQUUsSUFBSSxDQUNaLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLE1BQU0sQ0FBRSxPQUFPLENBQ2YsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLENBQUMsQ0FDVixXQUFXLENBQUUsR0FBRyxBQUNsQixDQUFBLEFBRUEsTUFBTSxjQUFDLENBQUEsQUFDTCxJQUFJLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDVCxPQUFPLENBQUUsSUFBSSxDQUNiLGNBQWMsQ0FBRSxNQUFNLENBQ3RCLGVBQWUsQ0FBRSxhQUFhLENBQzlCLGFBQWEsQ0FBRSxHQUFHLEFBQ3BCLENBQUEsQUFFQSxLQUFLLGNBQUMsQ0FBQSxBQUNKLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUNULGNBQWMsQ0FBRSxNQUFNLENBQ3RCLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFVBQVUsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEFBQ3BDLENBQUEsQUFFQSxRQUFRLGNBQUMsQ0FBQSxBQUNQLGdCQUFnQixDQUFFLElBQUksSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUN4QyxPQUFPLENBQUUsR0FBRyxBQUNkLENBQUEsQUFFQSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUN4QyxjQUFjLGNBQUMsQ0FBQSxBQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsY0FBYyxDQUFFLE1BQU0sQUFDeEIsQ0FBQSxBQUVBLFVBQVUsY0FBQyxDQUFBLEFBQ1QsT0FBTyxDQUFFLElBQUksQUFDZixDQUFBLEFBRVEsV0FBVyxBQUFFLENBQUEsQUFDbkIsT0FBTyxDQUFFLElBQUksQ0FBQyxVQUFVLEFBQzFCLENBQUEsQUFFQSxNQUFNLGNBQUMsQ0FBQSxBQUNMLFNBQVMsQ0FBRSxDQUFDLENBQ1osV0FBVyxDQUFFLElBQUksQ0FDakIsYUFBYSxDQUFFLEdBQUcsQUFDcEIsQ0FBQSxBQUNGLENBQUEsQUFFQSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQSxBQUN4QyxLQUFLLGNBQUMsQ0FBQSxBQUNKLFNBQVMsQ0FBRSxJQUFJLENBQ2YsT0FBTyxDQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FDOUIsTUFBTSxDQUFFLEtBQUssQ0FBQyxDQUFDLENBQ2YsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUNoRCxZQUFZLENBQUUsS0FBSyxBQUNyQixDQUFBLEFBQ0YsQ0FBQSxBQUVBLGlCQUFpQixjQUFDLENBQUEsQUFDaEIsUUFBUSxDQUFFLEtBQUssQ0FDZixLQUFLLENBQUUsSUFBSSxDQUNYLE9BQU8sQ0FBRSxHQUFHLENBQ1osVUFBVSxDQUFFLEdBQUcsQ0FDZixLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLEFBQ2IsQ0FBQSxBQUVBLGlCQUFpQixjQUFDLENBQUEsQUFDaEIsT0FBTyxDQUFFLElBQUksQUFDZixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkFwcC5zdmVsdGUiXX0= */");
    }

    // (304:2) {#if login_modal}
    function create_if_block_3(ctx) {
    	let login;
    	let updating_auth_controller;
    	let current;

    	function login_auth_controller_binding(value) {
    		/*login_auth_controller_binding*/ ctx[63](value);
    	}

    	let login_props = {
    		logged_username: (/*logged_username*/ ctx[1] && /*logged_username*/ ctx[1]) !== "anonymous"
    		? /*logged_username*/ ctx[1]
    		: undefined
    	};

    	if (/*auth_controller*/ ctx[6] !== void 0) {
    		login_props.auth_controller = /*auth_controller*/ ctx[6];
    	}

    	login = new Login({ props: login_props, $$inline: true });
    	binding_callbacks.push(() => bind(login, 'auth_controller', login_auth_controller_binding));
    	login.$on("cancel", /*cancel_handler*/ ctx[64]);

    	const block = {
    		c: function create() {
    			create_component(login.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(login, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const login_changes = {};

    			if (dirty[0] & /*logged_username*/ 2) login_changes.logged_username = (/*logged_username*/ ctx[1] && /*logged_username*/ ctx[1]) !== "anonymous"
    			? /*logged_username*/ ctx[1]
    			: undefined;

    			if (!updating_auth_controller && dirty[0] & /*auth_controller*/ 64) {
    				updating_auth_controller = true;
    				login_changes.auth_controller = /*auth_controller*/ ctx[6];
    				add_flush_callback(() => updating_auth_controller = false);
    			}

    			login.$set(login_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(login.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(login.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(login, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(304:2) {#if login_modal}",
    		ctx
    	});

    	return block;
    }

    // (314:2) {#if !videoMixerReady || !websocketReady || !$isLocaleLoaded}
    function create_if_block_2(ctx) {
    	let div;
    	let loading;
    	let current;
    	loading = new Loading({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(loading.$$.fragment);
    			attr_dev(div, "class", "center-text loading full-screen svelte-1zv8xk");
    			add_location(div, file, 314, 4, 9949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(loading, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(loading);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(314:2) {#if !videoMixerReady || !websocketReady || !$isLocaleLoaded}",
    		ctx
    	});

    	return block;
    }

    // (320:2) {#if !asr && asrModal}
    function create_if_block_1(ctx) {
    	let microphoneaccess;
    	let updating_asrModal;
    	let current;

    	function microphoneaccess_asrModal_binding(value) {
    		/*microphoneaccess_asrModal_binding*/ ctx[65](value);
    	}

    	let microphoneaccess_props = {};

    	if (/*asrModal*/ ctx[19] !== void 0) {
    		microphoneaccess_props.asrModal = /*asrModal*/ ctx[19];
    	}

    	microphoneaccess = new MicrophoneAccess({
    			props: microphoneaccess_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(microphoneaccess, 'asrModal', microphoneaccess_asrModal_binding));

    	const block = {
    		c: function create() {
    			create_component(microphoneaccess.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(microphoneaccess, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const microphoneaccess_changes = {};

    			if (!updating_asrModal && dirty[0] & /*asrModal*/ 524288) {
    				updating_asrModal = true;
    				microphoneaccess_changes.asrModal = /*asrModal*/ ctx[19];
    				add_flush_callback(() => updating_asrModal = false);
    			}

    			microphoneaccess.$set(microphoneaccess_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(microphoneaccess.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(microphoneaccess.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(microphoneaccess, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(320:2) {#if !asr && asrModal}",
    		ctx
    	});

    	return block;
    }

    // (324:2) {#if $error}
    function create_if_block(ctx) {
    	let div;
    	let error_1;
    	let current;
    	error_1 = new Error$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(error_1.$$.fragment);
    			attr_dev(div, "class", "loading svelte-1zv8xk");
    			add_location(div, file, 324, 4, 10125);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(error_1, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(error_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(324:2) {#if $error}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let globalstyle;
    	let t0;
    	let authenticationcontroller;
    	let updating_logged_username;
    	let updating_access_token;
    	let updating__user_id;
    	let t1;
    	let div2;
    	let div0;
    	let switch_instance;
    	let updating_idleVideoSrc;
    	let updating_sessionCount;
    	let updating_name;
    	let updating_opmode;
    	let updating_skipTalkingVideo;
    	let updating_on_video_synth_error;
    	let updating_on_video_received;
    	let updating_on_enter;
    	let updating_on_cache_check;
    	let t2;
    	let button;
    	let hidechat;
    	let t3;
    	let div1;
    	let chat;
    	let updating_asr;
    	let updating_name_1;
    	let updating_server_avatar;
    	let updating_header_avatar;
    	let updating_user_avatar;
    	let updating_opmode_1;
    	let updating_language;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let current;
    	globalstyle = new GlobalStyle({ $$inline: true });

    	function authenticationcontroller_logged_username_binding(value) {
    		/*authenticationcontroller_logged_username_binding*/ ctx[38](value);
    	}

    	function authenticationcontroller_access_token_binding(value) {
    		/*authenticationcontroller_access_token_binding*/ ctx[39](value);
    	}

    	function authenticationcontroller__user_id_binding(value) {
    		/*authenticationcontroller__user_id_binding*/ ctx[40](value);
    	}

    	let authenticationcontroller_props = {};

    	if (/*logged_username*/ ctx[1] !== void 0) {
    		authenticationcontroller_props.logged_username = /*logged_username*/ ctx[1];
    	}

    	if (/*access_token*/ ctx[3] !== void 0) {
    		authenticationcontroller_props.access_token = /*access_token*/ ctx[3];
    	}

    	if (/*_user_id*/ ctx[4] !== void 0) {
    		authenticationcontroller_props._user_id = /*_user_id*/ ctx[4];
    	}

    	authenticationcontroller = new AuthenticationController({
    			props: authenticationcontroller_props,
    			$$inline: true
    		});

    	/*authenticationcontroller_binding*/ ctx[37](authenticationcontroller);
    	binding_callbacks.push(() => bind(authenticationcontroller, 'logged_username', authenticationcontroller_logged_username_binding));
    	binding_callbacks.push(() => bind(authenticationcontroller, 'access_token', authenticationcontroller_access_token_binding));
    	binding_callbacks.push(() => bind(authenticationcontroller, '_user_id', authenticationcontroller__user_id_binding));

    	function switch_instance_idleVideoSrc_binding(value) {
    		/*switch_instance_idleVideoSrc_binding*/ ctx[41](value);
    	}

    	function switch_instance_sessionCount_binding(value) {
    		/*switch_instance_sessionCount_binding*/ ctx[42](value);
    	}

    	function switch_instance_name_binding(value) {
    		/*switch_instance_name_binding*/ ctx[43](value);
    	}

    	function switch_instance_opmode_binding(value) {
    		/*switch_instance_opmode_binding*/ ctx[44](value);
    	}

    	function switch_instance_skipTalkingVideo_binding(value) {
    		/*switch_instance_skipTalkingVideo_binding*/ ctx[45](value);
    	}

    	function switch_instance_on_video_synth_error_binding(value) {
    		/*switch_instance_on_video_synth_error_binding*/ ctx[46](value);
    	}

    	function switch_instance_on_video_received_binding(value) {
    		/*switch_instance_on_video_received_binding*/ ctx[47](value);
    	}

    	function switch_instance_on_enter_binding(value) {
    		/*switch_instance_on_enter_binding*/ ctx[48](value);
    	}

    	function switch_instance_on_cache_check_binding(value) {
    		/*switch_instance_on_cache_check_binding*/ ctx[49](value);
    	}

    	var switch_value = /*VideoMixer*/ ctx[24];

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			show_count: /*opmode*/ ctx[0] === "opsp" && /*is_admin*/ ctx[2]
    		};

    		if (/*idleVideoSrc*/ ctx[12] !== void 0) {
    			switch_instance_props.idleVideoSrc = /*idleVideoSrc*/ ctx[12];
    		}

    		if (/*sessionCount*/ ctx[22] !== void 0) {
    			switch_instance_props.sessionCount = /*sessionCount*/ ctx[22];
    		}

    		if (/*name*/ ctx[8] !== void 0) {
    			switch_instance_props.name = /*name*/ ctx[8];
    		}

    		if (/*opmode*/ ctx[0] !== void 0) {
    			switch_instance_props.opmode = /*opmode*/ ctx[0];
    		}

    		if (/*skipTalkingVideo*/ ctx[16] !== void 0) {
    			switch_instance_props.skipTalkingVideo = /*skipTalkingVideo*/ ctx[16];
    		}

    		if (/*on_video_synth_error*/ ctx[17] !== void 0) {
    			switch_instance_props.on_video_synth_error = /*on_video_synth_error*/ ctx[17];
    		}

    		if (/*on_video_received*/ ctx[13] !== void 0) {
    			switch_instance_props.on_video_received = /*on_video_received*/ ctx[13];
    		}

    		if (/*on_enter*/ ctx[14] !== void 0) {
    			switch_instance_props.on_enter = /*on_enter*/ ctx[14];
    		}

    		if (/*on_cache_check*/ ctx[15] !== void 0) {
    			switch_instance_props.on_cache_check = /*on_cache_check*/ ctx[15];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, 'idleVideoSrc', switch_instance_idleVideoSrc_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'sessionCount', switch_instance_sessionCount_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'name', switch_instance_name_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'opmode', switch_instance_opmode_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'skipTalkingVideo', switch_instance_skipTalkingVideo_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'on_video_synth_error', switch_instance_on_video_synth_error_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'on_video_received', switch_instance_on_video_received_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'on_enter', switch_instance_on_enter_binding));
    		binding_callbacks.push(() => bind(switch_instance, 'on_cache_check', switch_instance_on_cache_check_binding));
    		switch_instance.$on("ready", /*ready_handler*/ ctx[50]);
    		switch_instance.$on("talking_end", /*talking_end_handler*/ ctx[51]);
    		switch_instance.$on("pause", /*showPendingHook*/ ctx[30]);
    		switch_instance.$on("displayChatMessage", /*HandleDisplayChatMessage*/ ctx[34]);
    		switch_instance.$on("skip", /*processSkip*/ ctx[33]);
    		switch_instance.$on("replay", /*replay_handler*/ ctx[52]);
    		switch_instance.$on("avatarClick", /*avatarClick_handler*/ ctx[53]);
    	}

    	hidechat = new HideChat({ $$inline: true });

    	function chat_asr_binding(value) {
    		/*chat_asr_binding*/ ctx[54](value);
    	}

    	function chat_name_binding(value) {
    		/*chat_name_binding*/ ctx[55](value);
    	}

    	function chat_server_avatar_binding(value) {
    		/*chat_server_avatar_binding*/ ctx[56](value);
    	}

    	function chat_header_avatar_binding(value) {
    		/*chat_header_avatar_binding*/ ctx[57](value);
    	}

    	function chat_user_avatar_binding(value) {
    		/*chat_user_avatar_binding*/ ctx[58](value);
    	}

    	function chat_opmode_binding(value) {
    		/*chat_opmode_binding*/ ctx[59](value);
    	}

    	function chat_language_binding(value) {
    		/*chat_language_binding*/ ctx[60](value);
    	}

    	let chat_props = {};

    	if (/*asr*/ ctx[18] !== void 0) {
    		chat_props.asr = /*asr*/ ctx[18];
    	}

    	if (/*name*/ ctx[8] !== void 0) {
    		chat_props.name = /*name*/ ctx[8];
    	}

    	if (/*server_avatar*/ ctx[9] !== void 0) {
    		chat_props.server_avatar = /*server_avatar*/ ctx[9];
    	}

    	if (/*header_avatar*/ ctx[11] !== void 0) {
    		chat_props.header_avatar = /*header_avatar*/ ctx[11];
    	}

    	if (/*user_avatar*/ ctx[10] !== void 0) {
    		chat_props.user_avatar = /*user_avatar*/ ctx[10];
    	}

    	if (/*opmode*/ ctx[0] !== void 0) {
    		chat_props.opmode = /*opmode*/ ctx[0];
    	}

    	if (/*language*/ ctx[5] !== void 0) {
    		chat_props.language = /*language*/ ctx[5];
    	}

    	chat = new Chat({ props: chat_props, $$inline: true });
    	binding_callbacks.push(() => bind(chat, 'asr', chat_asr_binding));
    	binding_callbacks.push(() => bind(chat, 'name', chat_name_binding));
    	binding_callbacks.push(() => bind(chat, 'server_avatar', chat_server_avatar_binding));
    	binding_callbacks.push(() => bind(chat, 'header_avatar', chat_header_avatar_binding));
    	binding_callbacks.push(() => bind(chat, 'user_avatar', chat_user_avatar_binding));
    	binding_callbacks.push(() => bind(chat, 'opmode', chat_opmode_binding));
    	binding_callbacks.push(() => bind(chat, 'language', chat_language_binding));
    	chat.$on("userInput", /*handleUserInput*/ ctx[32]);
    	chat.$on("play", /*handleVideoFromChat*/ ctx[31]);
    	chat.$on("asr", /*asr_handler*/ ctx[61]);
    	chat.$on("skip", /*processSkip*/ ctx[33]);
    	chat.$on("replay", /*replay_handler_1*/ ctx[62]);
    	chat.$on("processUserInput", /*handleUserInput*/ ctx[32]);
    	let if_block0 = /*login_modal*/ ctx[7] && create_if_block_3(ctx);
    	let if_block1 = (!/*videoMixerReady*/ ctx[21] || !/*websocketReady*/ ctx[20] || !/*$isLocaleLoaded*/ ctx[28]) && create_if_block_2(ctx);
    	let if_block2 = !/*asr*/ ctx[18] && /*asrModal*/ ctx[19] && create_if_block_1(ctx);
    	let if_block3 = /*$error*/ ctx[25] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			create_component(globalstyle.$$.fragment);
    			t0 = space();
    			create_component(authenticationcontroller.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			div0 = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t2 = space();
    			button = element("button");
    			create_component(hidechat.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(chat.$$.fragment);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div0, "class", "video svelte-1zv8xk");
    			add_location(div0, file, 259, 2, 8319);
    			attr_dev(button, "class", "hide-chat svelte-1zv8xk");
    			toggle_class(button, "full-screen-hide", /*$isFullScreen*/ ctx[27]);
    			add_location(button, file, 282, 2, 9039);
    			attr_dev(div1, "class", "svelte-1zv8xk");
    			toggle_class(div1, "chat", !/*$isFullScreen*/ ctx[27]);
    			toggle_class(div1, "full-screen-chat", /*$isFullScreen*/ ctx[27]);
    			add_location(div1, file, 286, 2, 9137);
    			attr_dev(div2, "class", "app-container svelte-1zv8xk");
    			attr_dev(div2, "style", /*theme*/ ctx[23]);
    			add_location(div2, file, 258, 0, 8275);
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(globalstyle, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(authenticationcontroller, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);

    			if (switch_instance) {
    				mount_component(switch_instance, div0, null);
    			}

    			append_dev(div2, t2);
    			append_dev(div2, button);
    			mount_component(hidechat, button, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(chat, div1, null);
    			append_dev(div2, t4);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t5);
    			if (if_block1) if_block1.m(div2, null);
    			append_dev(div2, t6);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div2, t7);
    			if (if_block3) if_block3.m(div2, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const authenticationcontroller_changes = {};

    			if (!updating_logged_username && dirty[0] & /*logged_username*/ 2) {
    				updating_logged_username = true;
    				authenticationcontroller_changes.logged_username = /*logged_username*/ ctx[1];
    				add_flush_callback(() => updating_logged_username = false);
    			}

    			if (!updating_access_token && dirty[0] & /*access_token*/ 8) {
    				updating_access_token = true;
    				authenticationcontroller_changes.access_token = /*access_token*/ ctx[3];
    				add_flush_callback(() => updating_access_token = false);
    			}

    			if (!updating__user_id && dirty[0] & /*_user_id*/ 16) {
    				updating__user_id = true;
    				authenticationcontroller_changes._user_id = /*_user_id*/ ctx[4];
    				add_flush_callback(() => updating__user_id = false);
    			}

    			authenticationcontroller.$set(authenticationcontroller_changes);
    			const switch_instance_changes = {};
    			if (dirty[0] & /*opmode, is_admin*/ 5) switch_instance_changes.show_count = /*opmode*/ ctx[0] === "opsp" && /*is_admin*/ ctx[2];

    			if (!updating_idleVideoSrc && dirty[0] & /*idleVideoSrc*/ 4096) {
    				updating_idleVideoSrc = true;
    				switch_instance_changes.idleVideoSrc = /*idleVideoSrc*/ ctx[12];
    				add_flush_callback(() => updating_idleVideoSrc = false);
    			}

    			if (!updating_sessionCount && dirty[0] & /*sessionCount*/ 4194304) {
    				updating_sessionCount = true;
    				switch_instance_changes.sessionCount = /*sessionCount*/ ctx[22];
    				add_flush_callback(() => updating_sessionCount = false);
    			}

    			if (!updating_name && dirty[0] & /*name*/ 256) {
    				updating_name = true;
    				switch_instance_changes.name = /*name*/ ctx[8];
    				add_flush_callback(() => updating_name = false);
    			}

    			if (!updating_opmode && dirty[0] & /*opmode*/ 1) {
    				updating_opmode = true;
    				switch_instance_changes.opmode = /*opmode*/ ctx[0];
    				add_flush_callback(() => updating_opmode = false);
    			}

    			if (!updating_skipTalkingVideo && dirty[0] & /*skipTalkingVideo*/ 65536) {
    				updating_skipTalkingVideo = true;
    				switch_instance_changes.skipTalkingVideo = /*skipTalkingVideo*/ ctx[16];
    				add_flush_callback(() => updating_skipTalkingVideo = false);
    			}

    			if (!updating_on_video_synth_error && dirty[0] & /*on_video_synth_error*/ 131072) {
    				updating_on_video_synth_error = true;
    				switch_instance_changes.on_video_synth_error = /*on_video_synth_error*/ ctx[17];
    				add_flush_callback(() => updating_on_video_synth_error = false);
    			}

    			if (!updating_on_video_received && dirty[0] & /*on_video_received*/ 8192) {
    				updating_on_video_received = true;
    				switch_instance_changes.on_video_received = /*on_video_received*/ ctx[13];
    				add_flush_callback(() => updating_on_video_received = false);
    			}

    			if (!updating_on_enter && dirty[0] & /*on_enter*/ 16384) {
    				updating_on_enter = true;
    				switch_instance_changes.on_enter = /*on_enter*/ ctx[14];
    				add_flush_callback(() => updating_on_enter = false);
    			}

    			if (!updating_on_cache_check && dirty[0] & /*on_cache_check*/ 32768) {
    				updating_on_cache_check = true;
    				switch_instance_changes.on_cache_check = /*on_cache_check*/ ctx[15];
    				add_flush_callback(() => updating_on_cache_check = false);
    			}

    			if (switch_value !== (switch_value = /*VideoMixer*/ ctx[24])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, 'idleVideoSrc', switch_instance_idleVideoSrc_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'sessionCount', switch_instance_sessionCount_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'name', switch_instance_name_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'opmode', switch_instance_opmode_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'skipTalkingVideo', switch_instance_skipTalkingVideo_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'on_video_synth_error', switch_instance_on_video_synth_error_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'on_video_received', switch_instance_on_video_received_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'on_enter', switch_instance_on_enter_binding));
    					binding_callbacks.push(() => bind(switch_instance, 'on_cache_check', switch_instance_on_cache_check_binding));
    					switch_instance.$on("ready", /*ready_handler*/ ctx[50]);
    					switch_instance.$on("talking_end", /*talking_end_handler*/ ctx[51]);
    					switch_instance.$on("pause", /*showPendingHook*/ ctx[30]);
    					switch_instance.$on("displayChatMessage", /*HandleDisplayChatMessage*/ ctx[34]);
    					switch_instance.$on("skip", /*processSkip*/ ctx[33]);
    					switch_instance.$on("replay", /*replay_handler*/ ctx[52]);
    					switch_instance.$on("avatarClick", /*avatarClick_handler*/ ctx[53]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div0, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			if (dirty[0] & /*$isFullScreen*/ 134217728) {
    				toggle_class(button, "full-screen-hide", /*$isFullScreen*/ ctx[27]);
    			}

    			const chat_changes = {};

    			if (!updating_asr && dirty[0] & /*asr*/ 262144) {
    				updating_asr = true;
    				chat_changes.asr = /*asr*/ ctx[18];
    				add_flush_callback(() => updating_asr = false);
    			}

    			if (!updating_name_1 && dirty[0] & /*name*/ 256) {
    				updating_name_1 = true;
    				chat_changes.name = /*name*/ ctx[8];
    				add_flush_callback(() => updating_name_1 = false);
    			}

    			if (!updating_server_avatar && dirty[0] & /*server_avatar*/ 512) {
    				updating_server_avatar = true;
    				chat_changes.server_avatar = /*server_avatar*/ ctx[9];
    				add_flush_callback(() => updating_server_avatar = false);
    			}

    			if (!updating_header_avatar && dirty[0] & /*header_avatar*/ 2048) {
    				updating_header_avatar = true;
    				chat_changes.header_avatar = /*header_avatar*/ ctx[11];
    				add_flush_callback(() => updating_header_avatar = false);
    			}

    			if (!updating_user_avatar && dirty[0] & /*user_avatar*/ 1024) {
    				updating_user_avatar = true;
    				chat_changes.user_avatar = /*user_avatar*/ ctx[10];
    				add_flush_callback(() => updating_user_avatar = false);
    			}

    			if (!updating_opmode_1 && dirty[0] & /*opmode*/ 1) {
    				updating_opmode_1 = true;
    				chat_changes.opmode = /*opmode*/ ctx[0];
    				add_flush_callback(() => updating_opmode_1 = false);
    			}

    			if (!updating_language && dirty[0] & /*language*/ 32) {
    				updating_language = true;
    				chat_changes.language = /*language*/ ctx[5];
    				add_flush_callback(() => updating_language = false);
    			}

    			chat.$set(chat_changes);

    			if (dirty[0] & /*$isFullScreen*/ 134217728) {
    				toggle_class(div1, "chat", !/*$isFullScreen*/ ctx[27]);
    			}

    			if (dirty[0] & /*$isFullScreen*/ 134217728) {
    				toggle_class(div1, "full-screen-chat", /*$isFullScreen*/ ctx[27]);
    			}

    			if (/*login_modal*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*login_modal*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div2, t5);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*videoMixerReady*/ ctx[21] || !/*websocketReady*/ ctx[20] || !/*$isLocaleLoaded*/ ctx[28]) {
    				if (if_block1) {
    					if (dirty[0] & /*videoMixerReady, websocketReady, $isLocaleLoaded*/ 271581184) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div2, t6);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*asr*/ ctx[18] && /*asrModal*/ ctx[19]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*asr, asrModal*/ 786432) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, t7);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$error*/ ctx[25]) {
    				if (if_block3) {
    					if (dirty[0] & /*$error*/ 33554432) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div2, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*theme*/ 8388608) {
    				attr_dev(div2, "style", /*theme*/ ctx[23]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(globalstyle.$$.fragment, local);
    			transition_in(authenticationcontroller.$$.fragment, local);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(hidechat.$$.fragment, local);
    			transition_in(chat.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(globalstyle.$$.fragment, local);
    			transition_out(authenticationcontroller.$$.fragment, local);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(hidechat.$$.fragment, local);
    			transition_out(chat.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(globalstyle, detaching);
    			if (detaching) detach_dev(t0);
    			/*authenticationcontroller_binding*/ ctx[37](null);
    			destroy_component(authenticationcontroller, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			if (switch_instance) destroy_component(switch_instance);
    			destroy_component(hidechat);
    			destroy_component(chat);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const DEFAULT_LANG = "en-US";

    function instance($$self, $$props, $$invalidate) {
    	let $chatScrollDown;
    	let $disableChatInput;
    	let $_;
    	let $private_chat_store;
    	let $body_data;
    	let $error;
    	let $theme_store;
    	let $timerShouldBeHidden;
    	let $talkingVideoSrc;
    	let $timerShouldReset;
    	let $isFullScreen;
    	let $isLocaleLoaded;
    	validate_store(chatScrollDown, 'chatScrollDown');
    	component_subscribe($$self, chatScrollDown, $$value => $$invalidate(68, $chatScrollDown = $$value));
    	validate_store(disableChatInput, 'disableChatInput');
    	component_subscribe($$self, disableChatInput, $$value => $$invalidate(69, $disableChatInput = $$value));
    	validate_store(Y, '_');
    	component_subscribe($$self, Y, $$value => $$invalidate(70, $_ = $$value));
    	validate_store(private_chat_store, 'private_chat_store');
    	component_subscribe($$self, private_chat_store, $$value => $$invalidate(71, $private_chat_store = $$value));
    	validate_store(body_data, 'body_data');
    	component_subscribe($$self, body_data, $$value => $$invalidate(72, $body_data = $$value));
    	validate_store(error$2, 'error');
    	component_subscribe($$self, error$2, $$value => $$invalidate(25, $error = $$value));
    	validate_store(theme_store, 'theme_store');
    	component_subscribe($$self, theme_store, $$value => $$invalidate(73, $theme_store = $$value));
    	validate_store(timerShouldBeHidden, 'timerShouldBeHidden');
    	component_subscribe($$self, timerShouldBeHidden, $$value => $$invalidate(26, $timerShouldBeHidden = $$value));
    	validate_store(talkingVideoSrc, 'talkingVideoSrc');
    	component_subscribe($$self, talkingVideoSrc, $$value => $$invalidate(74, $talkingVideoSrc = $$value));
    	validate_store(timerShouldReset, 'timerShouldReset');
    	component_subscribe($$self, timerShouldReset, $$value => $$invalidate(75, $timerShouldReset = $$value));
    	validate_store(isFullScreen, 'isFullScreen');
    	component_subscribe($$self, isFullScreen, $$value => $$invalidate(27, $isFullScreen = $$value));
    	validate_store(isLocaleLoaded, 'isLocaleLoaded');
    	component_subscribe($$self, isLocaleLoaded, $$value => $$invalidate(28, $isLocaleLoaded = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let { body_DOMStringMap } = $$props;
    	load_body_data(body_DOMStringMap);
    	checkIfIsEmbed(body_DOMStringMap);

    	// need to type this
    	const display_version = version;

    	console.info({ version: display_version });
    	void D.set(DEFAULT_LANG);
    	const API_ENDPOINT = $body_data.api_base + "/";
    	let opmode = "ttt";
    	let language = undefined;

    	// Authentication and Login
    	let auth_controller;

    	let logged_username = undefined;
    	let login_modal = false;
    	let is_admin = false;
    	let access_token;
    	let _user_id;

    	// Chat
    	// if we are admin of opsp, server_avatar will be "", and user avatar will be ourselves
    	let name = "Digital Noone";

    	let peerStatus = $_("peer-status.online");
    	let server_avatar = "";
    	let user_avatar = "";
    	let header_avatar = "";
    	let head_avatar = "";
    	let idleVideoSrc;
    	let pendingHook = undefined;

    	const maybeRequestNextVideo = () => {
    		// If the video that just ended is the last one,
    		// we can request the backend for another video.
    		// If backend has no queued videos, it will ignore this message
    		if ($talkingVideoSrc === lastTalkingVideoReceived) {
    			requestNextVideo();
    		}
    	};

    	const showPendingHook = () => {
    		if (pendingHook) {
    			pendingHook();
    			pendingHook = undefined;
    		}

    		set_store_value(timerShouldBeHidden, $timerShouldBeHidden = false, $timerShouldBeHidden);
    		set_store_value(timerShouldReset, $timerShouldReset = true, $timerShouldReset);
    		set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	};

    	// functions from the video mixer
    	let on_video_received;

    	let on_enter;
    	let on_cache_check;
    	let skipTalkingVideo;
    	let on_video_synth_error;
    	let asr = false;
    	let asrModal = false;

    	// Websocket
    	let websocketReady = false;

    	// Video
    	let videoMixerReady = false;

    	// let idleVideoSrc: Writable<string>;
    	// let currentVideoSrc: Writable<string>;
    	let sessionCount = 0;

    	// This is called when a message coming from the backend
    	// contains a video url
    	const setVideo = (url, replay = false) => {
    		// If video is the same, we need to force a replay
    		url === $talkingVideoSrc && set_store_value(talkingVideoSrc, $talkingVideoSrc = "", $talkingVideoSrc);

    		set_store_value(talkingVideoSrc, $talkingVideoSrc = url, $talkingVideoSrc);
    		void on_video_received(replay);
    	};

    	const handleVideoFromChat = e => {
    		const videoSrc = e.detail;
    		setVideo(videoSrc, true);
    	};

    	const handleUserInput = msg => {
    		userInput(msg);
    		on_enter();
    	};

    	const processSkip = () => {
    		showPendingHook();
    		skipTalkingVideo();
    		maybeRequestNextVideo();
    		set_store_value(timerShouldBeHidden, $timerShouldBeHidden = false, $timerShouldBeHidden);
    	};

    	let theme = "";

    	//MSE compatibility check vars
    	let VideoMixer;

    	const vm_version = isMseSupported ? body_DOMStringMap.vm_version : "1";

    	switch (vm_version) {
    		case "2":
    			VideoMixer = VideoMixer2;
    			break;
    		default:
    			VideoMixer = VideoMixer1;
    			break;
    	}

    	const HandleDisplayChatMessage = event => {
    		displayMessage(event);
    		set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    	};

    	onMount(async () => {
    		// We setup with default English
    		await setupI18n(DEFAULT_LANG);

    		// We already fetched the theme.json, convert to css variables
    		set_store_value(theme_store, $theme_store = await getTheme($body_data.theme || ""), $theme_store);

    		set_store_value(theme_store, $theme_store.font = $body_data.font, $theme_store);
    		$$invalidate(23, theme = Object.entries($theme_store).map(([k, v]) => `--${k}:${v}`).join(";"));
    		let head;

    		try {
    			const response = await fetch(`${API_ENDPOINT}api/v1/head/${org_id}/${head_id}`);
    			head = await response.json();
    		} catch(err) {
    			const e = err;

    			if (e?.response?.data?.detail) {
    				set_store_value(error$2, $error = `Error:\n ${e.response.data.detail}`, $error);
    			} else {
    				set_store_value(error$2, $error = `${JSON.stringify(e)}`, $error);
    			}

    			return;
    		}

    		if (!head) {
    			set_store_value(error$2, $error = "Error: head does not exist", $error);
    			return;
    		}

    		$$invalidate(8, name = head.name);
    		$$invalidate(0, opmode = head.operation_mode);
    		$$invalidate(5, language = head.language);

    		//  This way the priority is html > head config > default
    		set_store_value(body_data, $body_data.language = language || DEFAULT_LANG, $body_data);

    		await setupI18n(language);

    		// ping the videos list and get one of them
    		let videos_results;

    		try {
    			const response = fetch(`${API_ENDPOINT}api/v1/videos/${org_id}/${head_id}`);
    			videos_results = await (await response).json();
    		} catch(err) {
    			const e = err;

    			if (e?.response?.data?.detail) {
    				error$2.set(`Error:\n ${e.response.data.detail}`);
    			} else {
    				error$2.set(`${JSON.stringify(e)}`);
    			}

    			return;
    		}

    		// TODO: if no videos in array, error
    		const video_id = videos_results[0].video_id;

    		const idleS3Url = await fetch(`${API_ENDPOINT}api/v1/idle/${org_id}/${head_id}/${video_id}`).then(res => res.json());
    		$$invalidate(12, idleVideoSrc = idleS3Url);

    		try {
    			const response = await fetch(`${API_ENDPOINT}api/v1/avatar/${org_id}/${head_id}/${video_id}`);
    			$$invalidate(36, head_avatar = await response.json());
    		} catch(err) {
    			const e = err;

    			if (e?.response?.data?.detail) {
    				error$2.set(`Error:\n ${e.response.data.detail}`);
    			} else {
    				error$2.set(`${JSON.stringify(e)}`);
    			}

    			return;
    		}

    		if (opmode == "gc") {
    			//clear the chat
    			set_store_value(private_chat_store, $private_chat_store = [], $private_chat_store);
    		}

    		let asrTimer;

    		mountWebSocket(
    			logged_username,
    			access_token,
    			_user_id,
    			org_id,
    			head_id,
    			setVideo,
    			() => {
    				$$invalidate(20, websocketReady = true);

    				asrTimer = setTimeout(
    					() => {
    						$$invalidate(19, asrModal = true);
    					},
    					1000
    				);

    				requestMicAccess().then(micAccess => {
    					$$invalidate(18, asr = micAccess);
    				}).catch(() => {
    					if (asrTimer) {
    						clearTimeout(asrTimer);
    					}

    					$$invalidate(19, asrModal = false);
    				});
    			},
    			user_count => {
    				$$invalidate(22, sessionCount = user_count);
    			},
    			status => {
    				peerStatus = !status && opmode === "opsp"
    				? $_("peer-status.away")
    				: $_("peer-status.online");
    			},
    			addHookFunc => {
    				pendingHook = addHookFunc;
    			},
    			() => {
    				vm_version === "2" && set_store_value(disableChatInput, $disableChatInput = true, $disableChatInput);
    			},
    			on_cache_check,
    			() => {
    				on_video_synth_error();
    				set_store_value(chatScrollDown, $chatScrollDown = true, $chatScrollDown);
    			}
    		);
    	});

    	const writable_props = ['body_DOMStringMap'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function authenticationcontroller_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			auth_controller = $$value;
    			$$invalidate(6, auth_controller);
    		});
    	}

    	function authenticationcontroller_logged_username_binding(value) {
    		logged_username = value;
    		$$invalidate(1, logged_username);
    	}

    	function authenticationcontroller_access_token_binding(value) {
    		access_token = value;
    		$$invalidate(3, access_token);
    	}

    	function authenticationcontroller__user_id_binding(value) {
    		_user_id = value;
    		$$invalidate(4, _user_id);
    	}

    	function switch_instance_idleVideoSrc_binding(value) {
    		idleVideoSrc = value;
    		$$invalidate(12, idleVideoSrc);
    	}

    	function switch_instance_sessionCount_binding(value) {
    		sessionCount = value;
    		$$invalidate(22, sessionCount);
    	}

    	function switch_instance_name_binding(value) {
    		name = value;
    		$$invalidate(8, name);
    	}

    	function switch_instance_opmode_binding(value) {
    		opmode = value;
    		$$invalidate(0, opmode);
    	}

    	function switch_instance_skipTalkingVideo_binding(value) {
    		skipTalkingVideo = value;
    		$$invalidate(16, skipTalkingVideo);
    	}

    	function switch_instance_on_video_synth_error_binding(value) {
    		on_video_synth_error = value;
    		$$invalidate(17, on_video_synth_error);
    	}

    	function switch_instance_on_video_received_binding(value) {
    		on_video_received = value;
    		$$invalidate(13, on_video_received);
    	}

    	function switch_instance_on_enter_binding(value) {
    		on_enter = value;
    		$$invalidate(14, on_enter);
    	}

    	function switch_instance_on_cache_check_binding(value) {
    		on_cache_check = value;
    		$$invalidate(15, on_cache_check);
    	}

    	const ready_handler = () => $$invalidate(21, videoMixerReady = true);
    	const talking_end_handler = () => (showPendingHook(), maybeRequestNextVideo());
    	const replay_handler = () => (on_video_received(true), set_store_value(timerShouldBeHidden, $timerShouldBeHidden = true, $timerShouldBeHidden));
    	const avatarClick_handler = () => $$invalidate(7, login_modal = true);

    	function chat_asr_binding(value) {
    		asr = value;
    		$$invalidate(18, asr);
    	}

    	function chat_name_binding(value) {
    		name = value;
    		$$invalidate(8, name);
    	}

    	function chat_server_avatar_binding(value) {
    		server_avatar = value;
    		(((($$invalidate(9, server_avatar), $$invalidate(0, opmode)), $$invalidate(2, is_admin)), $$invalidate(36, head_avatar)), $$invalidate(1, logged_username));
    	}

    	function chat_header_avatar_binding(value) {
    		header_avatar = value;
    		(((($$invalidate(11, header_avatar), $$invalidate(0, opmode)), $$invalidate(2, is_admin)), $$invalidate(36, head_avatar)), $$invalidate(1, logged_username));
    	}

    	function chat_user_avatar_binding(value) {
    		user_avatar = value;
    		(((($$invalidate(10, user_avatar), $$invalidate(0, opmode)), $$invalidate(2, is_admin)), $$invalidate(36, head_avatar)), $$invalidate(1, logged_username));
    	}

    	function chat_opmode_binding(value) {
    		opmode = value;
    		$$invalidate(0, opmode);
    	}

    	function chat_language_binding(value) {
    		language = value;
    		$$invalidate(5, language);
    	}

    	const asr_handler = () => sttFromMic();
    	const replay_handler_1 = () => (on_video_received(true), set_store_value(timerShouldBeHidden, $timerShouldBeHidden = true, $timerShouldBeHidden));

    	function login_auth_controller_binding(value) {
    		auth_controller = value;
    		$$invalidate(6, auth_controller);
    	}

    	const cancel_handler = () => $$invalidate(7, login_modal = false);

    	function microphoneaccess_asrModal_binding(value) {
    		asrModal = value;
    		$$invalidate(19, asrModal);
    	}

    	$$self.$$set = $$props => {
    		if ('body_DOMStringMap' in $$props) $$invalidate(35, body_DOMStringMap = $$props.body_DOMStringMap);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		locale: D,
    		GlobalStyle,
    		Chat,
    		Loading,
    		MicrophoneAccess,
    		VideoMixer1,
    		VideoMixer2,
    		Error: Error$1,
    		AuthenticationController,
    		Login,
    		private_chat_store,
    		error: error$2,
    		mountWebSocket,
    		restartWebSocket,
    		userInput,
    		displayMessage,
    		requestNextVideo,
    		lastTalkingVideoReceived,
    		talkingVideoSrc,
    		disableChatInput,
    		body_data,
    		load_body_data,
    		theme_store,
    		chatScrollDown,
    		timerShouldBeHidden,
    		timerShouldReset,
    		checkIfIsEmbed,
    		isFullScreen,
    		org_id,
    		head_id,
    		requestMicAccess,
    		sttFromMic,
    		_: Y,
    		isLocaleLoaded,
    		setupI18n,
    		isMseSupported,
    		version,
    		HideChat,
    		getTheme,
    		body_DOMStringMap,
    		display_version,
    		DEFAULT_LANG,
    		API_ENDPOINT,
    		opmode,
    		language,
    		auth_controller,
    		logged_username,
    		login_modal,
    		is_admin,
    		access_token,
    		_user_id,
    		name,
    		peerStatus,
    		server_avatar,
    		user_avatar,
    		header_avatar,
    		head_avatar,
    		idleVideoSrc,
    		pendingHook,
    		maybeRequestNextVideo,
    		showPendingHook,
    		on_video_received,
    		on_enter,
    		on_cache_check,
    		skipTalkingVideo,
    		on_video_synth_error,
    		asr,
    		asrModal,
    		websocketReady,
    		videoMixerReady,
    		sessionCount,
    		setVideo,
    		handleVideoFromChat,
    		handleUserInput,
    		processSkip,
    		theme,
    		VideoMixer,
    		vm_version,
    		HandleDisplayChatMessage,
    		$chatScrollDown,
    		$disableChatInput,
    		$_,
    		$private_chat_store,
    		$body_data,
    		$error,
    		$theme_store,
    		$timerShouldBeHidden,
    		$talkingVideoSrc,
    		$timerShouldReset,
    		$isFullScreen,
    		$isLocaleLoaded
    	});

    	$$self.$inject_state = $$props => {
    		if ('body_DOMStringMap' in $$props) $$invalidate(35, body_DOMStringMap = $$props.body_DOMStringMap);
    		if ('opmode' in $$props) $$invalidate(0, opmode = $$props.opmode);
    		if ('language' in $$props) $$invalidate(5, language = $$props.language);
    		if ('auth_controller' in $$props) $$invalidate(6, auth_controller = $$props.auth_controller);
    		if ('logged_username' in $$props) $$invalidate(1, logged_username = $$props.logged_username);
    		if ('login_modal' in $$props) $$invalidate(7, login_modal = $$props.login_modal);
    		if ('is_admin' in $$props) $$invalidate(2, is_admin = $$props.is_admin);
    		if ('access_token' in $$props) $$invalidate(3, access_token = $$props.access_token);
    		if ('_user_id' in $$props) $$invalidate(4, _user_id = $$props._user_id);
    		if ('name' in $$props) $$invalidate(8, name = $$props.name);
    		if ('peerStatus' in $$props) peerStatus = $$props.peerStatus;
    		if ('server_avatar' in $$props) $$invalidate(9, server_avatar = $$props.server_avatar);
    		if ('user_avatar' in $$props) $$invalidate(10, user_avatar = $$props.user_avatar);
    		if ('header_avatar' in $$props) $$invalidate(11, header_avatar = $$props.header_avatar);
    		if ('head_avatar' in $$props) $$invalidate(36, head_avatar = $$props.head_avatar);
    		if ('idleVideoSrc' in $$props) $$invalidate(12, idleVideoSrc = $$props.idleVideoSrc);
    		if ('pendingHook' in $$props) pendingHook = $$props.pendingHook;
    		if ('on_video_received' in $$props) $$invalidate(13, on_video_received = $$props.on_video_received);
    		if ('on_enter' in $$props) $$invalidate(14, on_enter = $$props.on_enter);
    		if ('on_cache_check' in $$props) $$invalidate(15, on_cache_check = $$props.on_cache_check);
    		if ('skipTalkingVideo' in $$props) $$invalidate(16, skipTalkingVideo = $$props.skipTalkingVideo);
    		if ('on_video_synth_error' in $$props) $$invalidate(17, on_video_synth_error = $$props.on_video_synth_error);
    		if ('asr' in $$props) $$invalidate(18, asr = $$props.asr);
    		if ('asrModal' in $$props) $$invalidate(19, asrModal = $$props.asrModal);
    		if ('websocketReady' in $$props) $$invalidate(20, websocketReady = $$props.websocketReady);
    		if ('videoMixerReady' in $$props) $$invalidate(21, videoMixerReady = $$props.videoMixerReady);
    		if ('sessionCount' in $$props) $$invalidate(22, sessionCount = $$props.sessionCount);
    		if ('theme' in $$props) $$invalidate(23, theme = $$props.theme);
    		if ('VideoMixer' in $$props) $$invalidate(24, VideoMixer = $$props.VideoMixer);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*logged_username*/ 2) {
    			$$invalidate(2, is_admin = logged_username === "admin");
    		}

    		if ($$self.$$.dirty[0] & /*logged_username*/ 2) {
    			if (logged_username !== "anonymous") $$invalidate(7, login_modal = false);
    		}

    		if ($$self.$$.dirty[0] & /*logged_username, access_token, _user_id*/ 26) {
    			if (logged_username) {
    				restartWebSocket(logged_username, access_token, _user_id);
    			}
    		}

    		if ($$self.$$.dirty[0] & /*opmode, is_admin*/ 5 | $$self.$$.dirty[1] & /*head_avatar*/ 32) {
    			if (opmode === "opsp" && is_admin) {
    				$$invalidate(10, user_avatar = head_avatar);
    				$$invalidate(11, header_avatar = head_avatar);
    				$$invalidate(9, server_avatar = "");
    			} else {
    				$$invalidate(10, user_avatar = "");
    				$$invalidate(11, header_avatar = head_avatar);
    				$$invalidate(9, server_avatar = head_avatar);
    			}
    		}
    	};

    	return [
    		opmode,
    		logged_username,
    		is_admin,
    		access_token,
    		_user_id,
    		language,
    		auth_controller,
    		login_modal,
    		name,
    		server_avatar,
    		user_avatar,
    		header_avatar,
    		idleVideoSrc,
    		on_video_received,
    		on_enter,
    		on_cache_check,
    		skipTalkingVideo,
    		on_video_synth_error,
    		asr,
    		asrModal,
    		websocketReady,
    		videoMixerReady,
    		sessionCount,
    		theme,
    		VideoMixer,
    		$error,
    		$timerShouldBeHidden,
    		$isFullScreen,
    		$isLocaleLoaded,
    		maybeRequestNextVideo,
    		showPendingHook,
    		handleVideoFromChat,
    		handleUserInput,
    		processSkip,
    		HandleDisplayChatMessage,
    		body_DOMStringMap,
    		head_avatar,
    		authenticationcontroller_binding,
    		authenticationcontroller_logged_username_binding,
    		authenticationcontroller_access_token_binding,
    		authenticationcontroller__user_id_binding,
    		switch_instance_idleVideoSrc_binding,
    		switch_instance_sessionCount_binding,
    		switch_instance_name_binding,
    		switch_instance_opmode_binding,
    		switch_instance_skipTalkingVideo_binding,
    		switch_instance_on_video_synth_error_binding,
    		switch_instance_on_video_received_binding,
    		switch_instance_on_enter_binding,
    		switch_instance_on_cache_check_binding,
    		ready_handler,
    		talking_end_handler,
    		replay_handler,
    		avatarClick_handler,
    		chat_asr_binding,
    		chat_name_binding,
    		chat_server_avatar_binding,
    		chat_header_avatar_binding,
    		chat_user_avatar_binding,
    		chat_opmode_binding,
    		chat_language_binding,
    		asr_handler,
    		replay_handler_1,
    		login_auth_controller_binding,
    		cancel_handler,
    		microphoneaccess_asrModal_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance, create_fragment, safe_not_equal, { body_DOMStringMap: 35 }, add_css, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*body_DOMStringMap*/ ctx[35] === undefined && !('body_DOMStringMap' in props)) {
    			console_1.warn("<App> was created without expected prop 'body_DOMStringMap'");
    		}
    	}

    	get body_DOMStringMap() {
    		throw new Error_1("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set body_DOMStringMap(value) {
    		throw new Error_1("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const target = document.getElementById("talking-head");
    const app = new App({
        target,
        props: {
            body_DOMStringMap: target.dataset,
        },
    });

    var primary="130, 80, 223";var secondary="0, 122, 80";var danger="249, 219, 223";var shadow="200, 200, 200";var body="240, 240, 240";var background="30, 30, 30";var dark = {primary:primary,"primary-dimmed":"94, 52, 170",secondary:secondary,danger:danger,shadow:shadow,body:body,background:background,"chat-background":"rgba(var(--primary), 0.6)","download-button-font":"0, 163, 137","download-button-background":"255, 255, 255"};

    var dark$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        primary: primary,
        secondary: secondary,
        danger: danger,
        shadow: shadow,
        body: body,
        background: background,
        'default': dark
    });

    return app;

})();
